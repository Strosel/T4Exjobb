//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define PLC_INFO_UPDATE_TIME                    250       //Update time in cywork for CPU values
#define PLC_INFO_DEVICE_ID_CPU_REGISTER         16#0F02   //Device ID from wb_cpu_register from  FPGA
#define PLC_INFO_CPU_REGISTER_OFFSET_CPU_TEMP   16#0A     //Offset of wb_cpu_register for CPU Temperature
#define PLC_INFO_CONVERT_TO_1_10_CELSIUS        10        //Multiplier to convert temperature to 1/10°C
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_pci.h"
#include "..\..\Source\interfaces\lsl_st_syssernum.h"
#include "..\..\Class\PLC_Info\XRegs.h"
#include <.\LoaderItf.h>
#include "..\..\Source\interfaces\lsl_st_sysinfo.h"

(*!
<Class
	Name               = "PLC_Info"
	Revision           = "1.68"
	GUID               = "{558D9A35-A514-4887-AA7B-B932E22A038E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\PLC_Info\C-IPC.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(652,120)"
	Comment            = "class to show extra information about different CPUs.">
	<Channels>
		<Server Name="ApplicationName" GUID="{A21DC7CD-FB10-4EE2-94C4-563AECB7CC68}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the name of the application which runs on the CPU.&#13;&#10;&#13;&#10;use this channel to access the string functions"/>
		<Server Name="BatteryOk" GUID="{4CE7B2CB-8A5C-4EEF-8422-CE1718AC7C64}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Low warning | 1 = OK"/>
		<Server Name="CPU_Name" GUID="{87A390C1-6C7F-4074-AAA7-09C8A4263635}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="CPUBoardName" GUID="{11E47FAA-DE77-484A-B6C7-5CA48F7433B8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server shows the name of the CPU Board.&#13;&#10;&#13;&#10;use this channel to access the string functions."/>
		<Server Name="CPUFamily" GUID="{41E60102-1ED0-4DCF-99B3-7AD6E2EB3FD8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUFeatures" GUID="{7756EEEC-B59B-4371-9868-FA7561697A8D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUIDString" GUID="{34CDC86B-BCDB-4B54-A80C-0AB2CA513ABC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Pointer to a 12 byte string"/>
		<Server Name="CPUModel" GUID="{EA9AD75B-BC1D-42D9-9468-C112236506C8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUStepping" GUID="{50B695C8-5438-4117-92DA-751CAAD55B1F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="CPUTemperature" GUID="{264519E2-5D5B-4CD4-8895-6D370FA12D78}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual temperature of processor in °C&#13;&#10;&#13;&#10;-2147483632 = not supported by device"/>
		<Server Name="CPUType" GUID="{D4C5933D-7561-43AE-9266-B54D7CCF8485}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="see CPUID command"/>
		<Server Name="FanOk" GUID="{D6D9FD5F-78D8-42F9-8E1A-6D98184DF8A1}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Fan fault&#13;&#10;1 = OK&#13;&#10;&#13;&#10;-2147483632 = not supported by device"/>
		<Server Name="GetSysInfoID" GUID="{B600C727-1034-4F33-A76A-C1A51B37DD6F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Use this server to read system information from the CPU.&#13;&#10;Write the desired ID on this server. (IDs are descriped in the Headerfile &quot;lsl_st_sysinfo.h&quot; which is attached to this class).&#13;&#10;&#13;&#10;Return Values: &#13;&#10;0 ... OK (Value from the requested ID is shown on the servers SysInfoVal or SysInfoStr).&#13;&#10;-1 ... Unknown ID&#13;&#10;-2 ... Information for given ID not available on this CPU.&#13;&#10;-3 ... Invalid Buffer or Buffer Length (Check Server SysInfoType and Requested ID).&#13;&#10;&#13;&#10;16#80000010 ... Feature not available on this CPU."/>
		<Server Name="ProjectRevision" GUID="{4241F0FD-C175-4570-85BD-9F58034C43F2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Revision of the current project in the Format 16#0000xxyy&#13;&#10;where xx is the major revision and yy the minor revision (like 16#00000103 for v1.3)"/>
		<Server Name="SerNum" GUID="{004E30EC-F8AE-46F7-9FB0-26B9D6ED3F3A}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the serial number of the CPU."/>
		<Server Name="State" GUID="{5EE971A9-0DC5-41CA-8034-9B5B85EC643C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the class.&#13;&#10;&#13;&#10;0 .. Everything ok&#13;&#10;&lt;&gt; 0 .. Error"/>
		<Server Name="Supply24VOk" GUID="{5508CB8B-34B1-45D6-B991-D2FC4DE5039E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Low warning | 1 = OK"/>
		<Server Name="SysInfoString" GUID="{E5CBE70B-8B44-4800-921B-C66E4DBD5073}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the string of the requested SysInfo ID.&#13;&#10;&#13;&#10;use this channel to access the string functions"/>
		<Server Name="SysInfoType" GUID="{72BD7EBC-8C95-4B66-8E3C-83875CD4C9F5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Select the type of the system information.&#13;&#10;0 .. 4 Byte Value&#13;&#10;1 .. String"/>
		<Server Name="SysInfoValue" GUID="{148A59B1-6BF6-4D42-8352-488ED17A5BA4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the value of the requested SysInfo ID."/>
		<Server Name="TemperatureOk" GUID="{1F6FF22B-500D-453C-8FD9-9BC54D12CADA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = High warning&#13;&#10;1 = OK&#13;&#10;&#13;&#10;-2147483632 = not supported by device"/>
		<Server Name="WhoAmI" GUID="{6CABAB76-3CA7-4121-8768-A29B3954CF3C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server shows the type of CPU."/>
		<Server Name="XilinxVersion" GUID="{6C63AA4A-B06D-4171-8CAA-F8D1487A189B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual version of xilinx.&#13;&#10;&#13;&#10;16#80000010 .. not supported by device."/>
		<Client Name="AppliName" Required="true" Internal="true"/>
		<Client Name="CPUBoard" Required="true" Internal="true"/>
		<Client Name="String0" Required="true" Internal="true"/>
		<Client Name="String1" Required="true" Internal="true"/>
		<Client Name="SysInfo" Required="true" Internal="true"/>
		<Client Name="To_TaskObjectControl" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_pci.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_syssernum.h" Include="true"/>
			<File Path=".\Class\PLC_Info\cpu_id.c"/>
			<File Path=".\Source\interfaces\Lsl_st_ifssr.h" Include="false"/>
			<File Path=".\Class\PLC_Info\XRegs.h" Include="true"/>
			<File Path=".\LoaderItf.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_sysinfo.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="renste"/>
		<Dokumentation Revision="1.68" Date="05.03.2018" Author="EisMic" Company="Sigmatek" Description="Added support for CP731-K.&#13;&#10;Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="1.67" Date="26.07.2017" Author="EisMic" Company="Sigmatek" Description="CPUTemperature server is now thread-safe."/>
		<Dokumentation Revision="1.66" Date="26.01.2017" Author="EisMic" Company="Sigmatek" Description="Added more support for PC3xx CPUs.&#13;&#10;Added server for CPU Board Name.&#13;&#10;Added servers to get Systeminformations via the SYSINFO OS-interface."/>
		<Dokumentation Revision="1.65" Date="25.01.2016" Author="EisMic" Company="Sigmatek" Description="Added support to read CPU Temperature on ARM-CPUs."/>
		<Dokumentation Revision="1.64" Date="11.11.2015" Author="ZoePat" Company="Sigmatek" Description="Use the headerfile LoaderItf.h for declaration of function LDR_GetPrjInfo() to prevent compiler error if someone includes the LoaderItf.h as global headerfile."/>
		<Dokumentation Revision="1.63" Date="01.09.2015" Author="EisMic" Company="Sigmatek" Description="Corrected check if temperature sensor is avaialable at hardware for ETVs."/>
		<Dokumentation Revision="1.62" Date="23.10.2014" Author="EisMic" Company="Sigmatek" Description="Prevented access error when trying to get xilinx version at arm-cpus."/>
		<Dokumentation Revision="1.61" Date="04.09.2014" Author="PieSte" Company="Sigmatek" Description="Implemented release version on Edge2- Platform. Initialized not supported features/servers with invalid values."/>
		<Dokumentation Revision="1.60" Date="06.03.2014" Author="EisMic&#13;&#10;RamAnd&#13;&#10;" Company="Sigmatek" Description="BatteryOk and Supply24VOk is now also supported on ARM CPUs.&#13;&#10;Added support for SDIAS PC"/>
		<Dokumentation Revision="1.50" Date="20.01.2014" Author="RamAnd" Company="Sigmatek" Description="Added server ProjectRevision to show the revision of the actual project."/>
		<Dokumentation Revision="1.40" Date="06.12.2013" Author="LanSte" Company="Sigmatek" Description="Added missing h file"/>
		<Dokumentation Revision="1.30" Date="12.09.2013" Author="ZoePat" Company="Sigmatek" Description="Corrected error at EEProm read. Support ARM to read SerNum and AppliName."/>
		<Dokumentation Revision="1.20" Date="30.08.2013" Author="FucHer" Company="Sigmatek" Description="Changed AWL code to Structured Text."/>
		<Dokumentation Revision="1.16" Date="19.03.2012" Author="ZoePat" Company="Sigmatek" Description="BatteryOk and Supply24VOk is now also supported on Edge ETVs."/>
		<Dokumentation Revision="1.15" Date="14.07.2011" Author="BleErn" Company="Sigmatek" Description="Corrected handling of CPU-temperature on ETV-Platform (Only available for all ETV 19&quot; and ETV 1561-H)"/>
		<Dokumentation Revision="1.14" Date="02.05.2011" Author="RamAnd" Company="Sigmatek" Description="Name of application can now also be visualized."/>
		<Dokumentation Revision="1.13" Date="17.03.2010" Author="RamAnd" Company="Sigmatek" Description="Added support for CCP511 and Edge ETVs"/>
		<Dokumentation Revision="1.12" Date="09.11.2009" Author="RamAnd" Company="Sigmatek" Description="Fan and Temperature info is now displayed correctly on ETVs with new FPGA"/>
		<Dokumentation Revision="1.11" Date="17.03.2009" Author="HaaPet" Company="Sigmatek" Description="PH001: display the application name (project name)"/>
		<Dokumentation Revision="1.10" Date="02.02.2009" Author="RamAnd" Company="Sigmatek" Description="corrected for loop count variable type. could have lead to a memory problem."/>
	</RevDoku>
	<Network Name="PLC_Info">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "AppliName"
				GUID       = "{FCD65643-5EB5-4660-B272-DD83947A9B9D}"
				Class      = "String"
				Position   = "(210,1140)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "CPUBoard"
				GUID       = "{27C8094B-20A3-4E3C-BB3E-7C37D506E107}"
				Class      = "String"
				Position   = "(210,1290)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "String0"
				GUID       = "{2A456D16-DF61-49B5-BEAB-DE5021938093}"
				Class      = "String"
				Position   = "(240,330)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "String1"
				GUID       = "{226FE40A-CB64-43F2-93A2-57B7B1968D48}"
				Class      = "String"
				Position   = "(240,750)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "SysInfo"
				GUID       = "{EC89488F-4E28-4A43-AB3F-204EFF8B9B8C}"
				Class      = "String"
				Position   = "(210,1470)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.SerNum" Destination="String0.Data" Vertices="(728,630),(556,420),"/>
			<Connection Source="this.CPU_Name" Destination="String1.Data" Vertices="(728,750),(556,840),"/>
			<Connection Source="this.String0" Destination="String0.Data"/>
			<Connection Source="this.String1" Destination="String1.Data"/>
			<Connection Source="this.AppliName" Destination="AppliName.Data"/>
			<Connection Source="this.ApplicationName" Destination="AppliName.Data" Vertices="(728,1170),(526,1230),"/>
			<Connection Source="this.CPUBoard" Destination="CPUBoard.Data"/>
			<Connection Source="this.CPUBoardName" Destination="CPUBoard.Data" Vertices="(728,1290),(526,1380),"/>
			<Connection Source="this.SysInfo" Destination="SysInfo.Data"/>
			<Connection Source="this.SysInfoString" Destination="SysInfo.Data" Vertices="(728,1530),(526,1560),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
PLC_Info : CLASS
	TYPE
	  s_Version : STRUCT
	    ModelStepping : HSINT;
	    TypeFamily : HSINT;
	    res0 : INT;
	  END_STRUCT;
	  s_cpu_info : STRUCT
	    MaxID : DINT;
	    IDString : ARRAY [0..11] OF CHAR;
	    VersionInformation : s_Version;
	    Res0 : DINT;
	    FeatureInformation : BDINT
	    [
	      1 FPU,
	      2 VME,
	      3 DE,
	      4 PSE,
	      5 TSC,
	      6 MSR,
	      7 PAE,
	      8 MCE,
	      9 CXS,
	      10 APIC,
	      13 MTRR,
	      14 PGE,
	      15 MCA,
	      16 CMOV,
	      24 MMX,
	    ];
	    Res1 : DINT;
	  END_STRUCT;
	  s_DiasInfoType : STRUCT
	    DiasType : UDINT;
	    DiasHWPointer : UDINT;
	    CDIASType : UDINT;
	    CDIASHWPointer : UDINT;
	    CfgRegsType : UDINT;
	    CfgRegsHWPointer : UDINT;
	    XregsType : UDINT;
	    XregsHWPointer : UDINT;
	    PLLType : UDINT;
	    PLLHWPointer : UDINT;
	    EERType : UDINT;
	    EERPointer : UDINT;
	  END_STRUCT;
#pragma pack(push, 1)
	  s_Fan : STRUCT
	    Temperature : INT;
	    Fan1rps : USINT;
	    Fan2rps : USINT;
	    StatusRegister : BSINT
	    [
	      1 PWMactive,
	      2 TwoFanMode,
	      3 Fan1OK,
	      4 Fan2OK,
	      5 TempLimitOK,
	      6 FullSpeed,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  s_SdiasPC : STRUCT
	    CpuTemp : USINT;
	    MemTemp : USINT;
	    SysTemp : USINT;
	    Reserved0 : USINT;
	    PWMHighTime : USINT;
	    PWMPeriod : USINT;
	    Reserved1 : UINT;
	    Fan1rps : UINT;
	    Fan2rps : UINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	State 	: SvrChCmd_IO_State;
	XilinxVersion 	: SvrCh_HDINT;
	BatteryOk 	: SvrCh_DINT;
	Supply24VOk 	: SvrCh_DINT;
	TemperatureOk 	: SvrCh_DINT;
	CPUTemperature 	: SvrCh_DINT;
	FanOk 	: SvrCh_DINT;
	SerNum 	: SvrChCmd_UDINT;
	WhoAmI 	: SvrCh_DM_CPU_Types;
	CPU_Name 	: SvrChCmd_UDINT;
	CPUIDString 	: SvrCh_HDINT;
	CPUModel 	: SvrCh_DINT;
	CPUStepping 	: SvrCh_DINT;
	CPUType 	: SvrCh_DINT;
	CPUFamily 	: SvrCh_DINT;
	CPUFeatures 	: SvrCh_BDINT;
	ApplicationName 	: SvrChCmd_UDINT;
	ProjectRevision 	: SvrCh_HDINT;
	CPUBoardName 	: SvrCh_UDINT;
	GetSysInfoID 	: SvrCh_DINT;
	SysInfoType 	: SvrCh_DINT;
	SysInfoValue 	: SvrCh_DINT;
	SysInfoString 	: SvrCh_UDINT;
  //Clients:
	String0 	: CltChCmd_String;
	To_TaskObjectControl 	: CltChCmd__TaskObjectControl;
	String1 	: CltChCmd_String;
	AppliName 	: CltChCmd_String;
	CPUBoard 	: CltChCmd_String;
	SysInfo 	: CltChCmd_String;
  //Variables:
		us_Firstscan 	: USINT;
		p_XilinxRegs 	: pVoid;
		p_PWMRegs 	: pVoid;
		pSPCIInfo 	: ^LSL_SPCIINFO;
		b_TempOk 	: BOOL;
		b_StateRegsOk 	: BOOL;
		b_CheckFanOk 	: BOOL;
		ud_Timestamp 	: UDINT;
		p_PLCInfo 	: ^LSL_PLCINFO;
		pISysSernum 	: ^LSL_ISYSSERNUM;
		us_NoTask 	: USINT;
		p_period 	: ^UINT;
		ui_TempDivisor 	: UINT;
		ui_TempMult 	: UINT;
		ui_TempOffset 	: UINT;
		cpu_id_data 	: s_cpu_info;
		p_Fan 	: ^s_Fan;
		p_SdiasPc 	: ^s_SdiasPC;
		ErrXREGS 	: UDINT;
		pT_XREGS 	: ^T_XREGS;
		pLSLSysInfo 	: ^LSL_SYSINFO_TYPE;
		p_CPUReg 	: ^DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			InEAX (EAX) 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CPUBoardName::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CPUBoardName::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetSysInfoID::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SysInfoType::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SysInfoString::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SysInfoString::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _TaskObjectControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB PLC_Info::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PLC_INFO
1$UINT, 68$UINT, (SIZEOF(::PLC_Info))$UINT, 
23$UINT, 6$UINT, 0$UINT, 
TO_UDINT(1551372421), "PLC_Info", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::PLC_Info.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::PLC_Info.XilinxVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3261876988), "XilinxVersion", 
(::PLC_Info.BatteryOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3075126500), "BatteryOk", 
(::PLC_Info.Supply24VOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(13545095), "Supply24VOk", 
(::PLC_Info.TemperatureOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1298369681), "TemperatureOk", 
(::PLC_Info.CPUTemperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(435927272), "CPUTemperature", 
(::PLC_Info.FanOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3738308276), "FanOk", 
(::PLC_Info.SerNum.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2137718556), "SerNum", 
(::PLC_Info.WhoAmI.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(808643972), "WhoAmI", 
(::PLC_Info.CPU_Name.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1310162464), "CPU_Name", 
(::PLC_Info.CPUIDString.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4243460179), "CPUIDString", 
(::PLC_Info.CPUModel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1531260384), "CPUModel", 
(::PLC_Info.CPUStepping.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4232916659), "CPUStepping", 
(::PLC_Info.CPUType.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2415762775), "CPUType", 
(::PLC_Info.CPUFamily.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3238091204), "CPUFamily", 
(::PLC_Info.CPUFeatures.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3106788165), "CPUFeatures", 
(::PLC_Info.ApplicationName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(4271568587), "ApplicationName", 
(::PLC_Info.ProjectRevision.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3973626999), "ProjectRevision", 
(::PLC_Info.CPUBoardName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(1556721041), "CPUBoardName", 
(::PLC_Info.GetSysInfoID.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1633840302), "GetSysInfoID", 
(::PLC_Info.SysInfoType.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1045319282), "SysInfoType", 
(::PLC_Info.SysInfoValue.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3658637465), "SysInfoValue", 
(::PLC_Info.SysInfoString.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(225454092), "SysInfoString", 
//Clients:
(::PLC_Info.String0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1600431117), "String0", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::PLC_Info.To_TaskObjectControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2751224004), "To_TaskObjectControl", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::PLC_Info.String1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(677614747), "String1", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::PLC_Info.AppliName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1033413914), "AppliName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::PLC_Info.CPUBoard.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3565581438), "CPUBoard", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::PLC_Info.SysInfo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(121357199), "SysInfo", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_PLC_Info 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_PLC_Info] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION PLC_Info::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_PLC_Info, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerNum.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	SerNum.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerNum.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, CPU_Name.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	CPU_Name.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CPU_Name.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ApplicationName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	ApplicationName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ApplicationName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CPUBoardName.pMeth			:= StoreMethod( #CPUBoardName::Read(), #M_NO_F() );
	IF CPUBoardName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	GetSysInfoID.pMeth			:= StoreMethod( #M_RD_DIRECT(), #GetSysInfoID::Write() );
	IF GetSysInfoID.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SysInfoType.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SysInfoType::Write() );
	IF SysInfoType.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SysInfoString.pMeth			:= StoreMethod( #SysInfoString::Read(), #M_NO_F() );
	IF SysInfoString.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

(*******************************************************************************
*
*	Class for some PLC infos (CIPC and CCL911 at the moment)
*	Created: 	SR 	/ 	17.01.2005
*
*
*   FOR NEWER CHANGES SEE REVISION DOCUMENTATION OF CLASS
*
*
*		1.7 => 1.8	/	14.11.2007	/	Mark:	//ws002
*			read CPU identification of 586+ cpus.
*		1.6 => 1.7	/	25.01.2006	/	Mark:	//#SR005
*			read temperature of ETV 1561
*		1.5 => 1.6	/	08.01.2006	/	Mark:	//#SR004
*			insert Server with CPUName String
*		1.4 => 1.5	/	04.12.2006	/	Mark:	//#SR003
*			bug in ETV when DIAS - Bus not avaiable
*		1.3 => 1.4	/	29.11.2006	/	Mark:	//#SR002
*			make compatible to ETV terminals
*		1.2 => 1.3	/	25.09.2006	/	Mark:	//#SR001
*			make a global type for _WhoAmI Server to show names of CPU's
*		1.1 => 1.2	/	09.09.2005	/	Mark:	//#SR000
*			make compatible to Neureder Teachbox	
*		1.0 => 1.1 	/ 	07.06.2005	/	Mark:	//ws001
*			replacement of pointer offsets with data structures
*	
*******************************************************************************)

FUNCTION __cdecl cpu_id 
VAR_INPUT 
param : UDINT;	
ret0	: ^USINT; 
END_VAR;


//FUNCTION GLOBAL LDR_GetPrjInfo
//VAR_INPUT
//  pRevHi : ^HSINT;
//  pRevLo : ^HSINT;
//  ppName : ^PCHAR;
//END_VAR
//VAR_OUTPUT
//  result : BOOL;
//END_VAR;

#define INVALID	16#80000010

FUNCTION VIRTUAL GLOBAL PLC_Info::Init
VAR
	p_p2cil 			: ^s_DiasInfoType;
	p_sigmatek_devinfo 	: ^PCICONFDATA;
 	a_name				: ARRAY[0..99] OF USINT;  // max 99 chars + 1 byte closing 0
  SingleChar    : UINT;   // OS_EE_Read returns 1byte char and 1byte 0 for closing the string
  i             : UINT;
  retcode       : UDINT;
  startdelay    : UDINT;
  HiRev         : HSINT;
  LoRev         : HSINT;
  pPrjName      : ^CHAR;
	pFunction     : ^void;
END_VAR

	if us_Firstscan = 0 then
    
		WhoAmI$UDINT	:= _WhoAMI;		//#SR001 (cast)
		a_name[0]     := 0;
    
    //Initialize Servers with invalid, will get overwritten if info is available on the CPU
    XilinxVersion         := INVALID;
    BatteryOk$UDINT       := INVALID;
    Supply24VOk$UDINT     := INVALID;
    TemperatureOk$UDINT   := INVALID;
    CPUTemperature$UDINT  := INVALID;
    FanOk$UDINT           := INVALID;
    SerNum$UDINT          := INVALID;
    ApplicationName       := INVALID;
    ProjectRevision       := INVALID;
    GetSysInfoID$UDINT    := INVALID;
    
    //delay for eeprom-read (not available if started too early) - 1ms looks just fine
    startdelay := ops.tAbsolute;
    while (ops.tAbsolute - startdelay) < 2 do // changed to 2 for at least 1ms delay
    end_while;
    
    //Get CPU - Name
    if ( _LSL_POS^.piSSR^.EE_Read <> NIL ) then
      for i := 0 to 15 do
        retcode := OS_SSR_EE_Read(16#70 + i, #SingleChar);
        if ( SingleChar < 32 | SingleChar = 255 ) then
          a_name[i] := 0;
          exit;
        else
          a_name[i] := SingleChar$USINT; // copy only the char
        end_if;
      end_for;
      String1.WriteDataOff( udLen:= i, udOff := 0, pData := #a_name[ 0 ] );
    end_if;

    //Get OS-Interface for system info
    if OS_CILGET(INTERFACE_LSL_SYSINFO, #pLSLSysInfo) <> SYS_ERR_NONE then
      pLSLSysInfo := NIL;
    else
      GetSysInfoID$UDINT := 0; //Do not show Invalid if we got the CIL-Interface
    end_if;
    
    //Get CPU Boardname
    if pLSLSysInfo then
      retcode$DINT := OS_SYSINFO_GET_PROP(pLSLSysInfo, LSL_SYSINFO_DMI_BOARD_NAME, #a_name[0], sizeof(a_name));
      //Check for error code
      if retcode = LSL_SYSINFO_ERR_NONE then
        CPUBoard.WriteDataOff( udLen:= _strlen(src:=#a_name[0]) + 1, udOff := 0, pData := #a_name[ 0 ] ); //+1 for zero term
      end_if;      
    end_if;    

		//Look which CPU we've got
		case WhoAmI of						

//**********************************************************************************************************************************************************
			C_IPC_CPU:

				State.uiIO_Flags  := 0;
				us_Firstscan      := 1;

#ifdef _LSL_TARGETARCH_X86
				cpu_id( 0, ( #cpu_id_data.MaxID )$^usint );
#endif
#ifdef _LSL_TARGETARCH_ARM
        cpu_id_data.MaxID := 0;
        _memcpy(#cpu_id_data.IDString[0], "ARM ARM ARM ", cntr:=12);
#endif
				if( cpu_id_data.MaxID >= 1 )then
#ifdef _LSL_TARGETARCH_X86
					cpu_id( 1, ( #cpu_id_data.VersionInformation )$^usint );
#endif
#ifdef _LSL_TARGETARCH_ARM
          cpu_id_data.VersionInformation.ModelStepping := 0;
          cpu_id_data.VersionInformation.TypeFamily    := 0;
          cpu_id_data.FeatureInformation := 0;
#endif
				end_if;
        
				CPUIDString := ( #cpu_id_data.IDString )$hdint;
				CPUModel    := ( cpu_id_data.VersionInformation.ModelStepping shr 4 ) and 16#0f;
				CPUStepping := cpu_id_data.VersionInformation.ModelStepping and 16#0f;
				CPUType     := ( cpu_id_data.VersionInformation.TypeFamily shr 4 ) and 16#03;
				CPUFamily   := cpu_id_data.VersionInformation.TypeFamily and 16#0f;
				CPUFeatures := cpu_id_data.FeatureInformation;

				// then we have got a CIPC
				if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
					p_sigmatek_devinfo 	:= SPCIINFO_FINDDEVICE( 0x0000,0 );
          
          if p_sigmatek_devinfo then
            XilinxVersion := to_udint( p_sigmatek_devinfo^.Version );       
          end_if;

					if p_sigmatek_devinfo^.Version >= 16#12 then
					// only possible with Xilinx version 1.2

						b_StateRegsOk := 1; 
						b_TempOk      := 1;

						// check fan check ok
						p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0E28,0 );
				
						if p_sigmatek_devinfo <> NIL then
							p_PWMRegs := SPCIINFO_GETADDRESS( p_sigmatek_devinfo );
					
							if p_PWMRegs <> NIL then
								b_CheckFanOk := 1;
							end_if;
						end_if;				
						
					elsif p_sigmatek_devinfo^.Version = 16#11 then
					// only possible with Xilinx version 1.1
						b_StateRegsOk := 1; 
					end_if;

					if OS_CILGET( "DiasInfo", #p_p2cil ) = SYS_ERR_NONE then
						//p_XilinxRegs	:= ( p_p2cil+28 )^;
						p_XilinxRegs := ( p_p2cil^.XregsHwPointer )$^void; //ws001
					
					//#SR003 start
						if ( p_XilinxRegs = NIL ) then
							us_NoTask := 1;
						end_if;	
					else
						us_NoTask := 1;
					//#SR003 end
					end_if;
				
				//#SR003 start
				else
					us_NoTask := 1;
				end_if;				

//**********************************************************************************************************************************************************
			CCL911_CPU, Teachbox_CPU, ETV_CPU, CCP511_CPU, ETVEDGE_CPU:
      
				State.uiIO_Flags  := 0;
				us_Firstscan      := 1;
		
#ifdef _LSL_TARGETARCH_X86
				cpu_id( 0, ( #cpu_id_data.MaxID )$^usint );
#endif
				if( cpu_id_data.MaxID >= 1 )then
#ifdef _LSL_TARGETARCH_X86
					cpu_id( 1, ( #cpu_id_data.VersionInformation )$^usint );
#endif
				end_if;
        
				CPUIDString := ( #cpu_id_data.IDString )$hdint;
				CPUModel    := ( cpu_id_data.VersionInformation.ModelStepping shr 4 ) and 16#0f;
				CPUStepping := cpu_id_data.VersionInformation.ModelStepping and 16#0f;
				CPUType     := ( cpu_id_data.VersionInformation.TypeFamily shr 4 ) and 16#03;
				CPUFamily   := cpu_id_data.VersionInformation.TypeFamily and 16#0f;
				CPUFeatures := cpu_id_data.FeatureInformation;

				// then we have got a CIPC
				if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
					p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0000,0 );
          
          if p_sigmatek_devinfo then
            XilinxVersion := to_udint( p_sigmatek_devinfo^.Version );
          end_if;

					if OS_CILGET( "DiasInfo", #p_p2cil ) = SYS_ERR_NONE then
						//p_XilinxRegs	:= ( p_p2cil + 28 )^;
						p_XilinxRegs := ( p_p2cil^.XregsHwPointer )$^void; //ws001

					//#SR003 start
						if ( p_XilinxRegs = NIL ) then
							us_NoTask := 1;
						end_if;	
					else
            p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0730,0 );
            if ( p_sigmatek_devinfo <> NIL ) then
              p_XilinxRegs      := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^UINT;
              us_NoTask         := 0;
              BatteryOk$UDINT   := 0;
              Supply24VOk$UDINT := 0;
            else
              us_NoTask := 1;
            end_if;
					//#SR003 end
					end_if;

					//#SR005 start
					//look for temperature
          p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0E70,0 );
          if p_sigmatek_devinfo = NIL then
            if ( XilinxVersion <= 16#13 ) then
              p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0920,0 );
            else
              p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0920,16#10 );
            end_if;          

            //look if device is found
            if ( p_sigmatek_devinfo <> NIL ) then
              p_period := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^UINT;
              // According to SilBer (SA 18936): only ETV1561H & all 19" ETV's do have a temperature sensor
              if   WhoAmI = ETV_CPU 
                 & _strcmp(str1:="ETV 1561-H", str2:=#a_name[0]) <> 0
                 & _memcmp(ptr1:="ETV 19", ptr2:=#a_name[0], cntr:=6) <> 0 then
                p_period := NIL;
              end_if;

              //start task
              if ( p_period <> NIL ) then

                case ( ( p_sigmatek_devinfo + 13 )$^USINT )^ of
                  16#30: 	
                      ui_TempDivisor 	:= 10;
                      ui_TempMult		  := 1;
                      ui_TempOffset 	:= 273;
                      us_NoTask       := 0;
                  16#31:	
                      ui_TempDivisor 	:= 1;
                      ui_TempMult		  := 1;
                      ui_TempOffset 	:= 273;
                      us_NoTask       := 0;
                  16#32:	
                      ui_TempDivisor 	:= 1;
                      ui_TempMult		  := 10;
                      ui_TempOffset 	:= 273;
                      us_NoTask       := 0;
                  16#38:	
                      ui_TempDivisor 	:= 10;
                      ui_TempMult		  := 1;
                      ui_TempOffset 	:= 0;
                      us_NoTask       := 0;
                  16#39:	
                      ui_TempDivisor 	:= 1;
                      ui_TempMult		  := 1;
                      ui_TempOffset 	:= 0;
                      us_NoTask       := 0;
                  16#3A:	
                      ui_TempDivisor 	:= 1;
                      ui_TempMult		  := 10;
                      ui_TempOffset 	:= 0;
                      us_NoTask       := 0;
                end_case;
              end_if;
            else
              p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0700,0 );
              if p_sigmatek_devinfo <> NIL then
                p_SdiasPc := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^s_SdiasPC;
              end_if;
            end_if;
          else
            // According to SilBer (SA 18936): only ETV1561H & all 19" ETV's do have a temperature sensor
            p_Fan := ( SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) )$^s_Fan;
            if   WhoAmI = ETV_CPU 
               & _strcmp(str1:="ETV 1561-H", str2:=#a_name[0]) <> 0
               & _memcmp(ptr1:="ETV 19", ptr2:=#a_name[0], cntr:=6) <> 0 then
              p_Fan := NIL;
            end_if;
          end_if;
					//#SR005 end

				//#SR003 start
				else
					us_NoTask := 1;
				//#SR003 end
				end_if;
			
//**********************************************************************************************************************************************************
      ARM_IMX6_CPU :    // e.g.: HZS 731-H, HGT 1035-H  CP111   

        State.uiIO_Flags := 0;
        us_Firstscan := 1;
        us_NoTask := 0;
          
        ErrXREGS := OS_CILGET("IXREGS", #pT_XREGS);

        if ErrXREGS$SYS_ERROR <> SYS_ERR_NONE then
          pT_XREGS := NIL;
        end_if;    
        
        if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
          p_sigmatek_devinfo := SPCIINFO_FINDDEVICE( 0x0000,0 );
          //Check pointer, because if hardware has no fpga inside the pointer is nil
          if p_sigmatek_devinfo then
            XilinxVersion := to_udint( p_sigmatek_devinfo^.Version );   
          end_if;
        end_if;              
                
        // at the moment we have not more informations avaliable
        // it would be best if we get an OS-Interface for CPUInfo


//**********************************************************************************************************************************************************
      StandardPC_CPU: //For PC3xx
 
        State.uiIO_Flags  := 0;
        us_Firstscan      := 1;
        us_NoTask         := 0;
        
#ifdef _LSL_TARGETARCH_X86
				cpu_id( 0, ( #cpu_id_data.MaxID )$^usint );
#endif
#ifdef _LSL_TARGETARCH_ARM
        cpu_id_data.MaxID := 0;
        _memcpy(#cpu_id_data.IDString[0], "ARM ARM ARM ", cntr:=12);
#endif
				if( cpu_id_data.MaxID >= 1 )then
#ifdef _LSL_TARGETARCH_X86
					cpu_id( 1, ( #cpu_id_data.VersionInformation )$^usint );
#endif
#ifdef _LSL_TARGETARCH_ARM
          cpu_id_data.VersionInformation.ModelStepping := 0;
          cpu_id_data.VersionInformation.TypeFamily    := 0;
          cpu_id_data.FeatureInformation := 0;
#endif
				end_if;
        
				CPUIDString := ( #cpu_id_data.IDString )$hdint;
				CPUModel    := ( cpu_id_data.VersionInformation.ModelStepping shr 4 ) and 16#0f;
				CPUStepping := cpu_id_data.VersionInformation.ModelStepping and 16#0f;
				CPUType     := ( cpu_id_data.VersionInformation.TypeFamily shr 4 ) and 16#03;
				CPUFamily   := cpu_id_data.VersionInformation.TypeFamily and 16#0f;
				CPUFeatures := cpu_id_data.FeatureInformation;
        
        //Try if we can get the IXRegs Register. To get battery status information (CP731-K)
        ErrXREGS := OS_CILGET("IXREGS", #pT_XREGS);

        if ErrXREGS$SYS_ERROR <> SYS_ERR_NONE then
          pT_XREGS := NIL;
        end_if;    
                
        p_CPUReg := NIL;
                
        //Try if we can get the CPU_Register Device from the FPGA, to read the CPU Temperature (needed for CP731-K)
        if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
          p_sigmatek_devinfo := SPCIINFO_FINDDEVICE(PLC_INFO_DEVICE_ID_CPU_REGISTER,0);
          //Check pointer, because if hardware has no fpga inside the pointer is nil
          if p_sigmatek_devinfo then
            p_CPUReg$pVoid := SPCIINFO_GETADDRESS(p_sigmatek_devinfo);
          end_if;
        end_if;
        
//**********************************************************************************************************************************************************
			else //Unknown or not supported CPU

				State.uiIO_Flags.WrongHW := 1;
				State.uiIO_Flags.PhysicAccessOff := 1;
        
//**********************************************************************************************************************************************************
		end_case;

    if State.uiIO_Flags = 0 then								//#SR002 CPUName <> Undefined then		//#SR000
		
			//*** System get Serialnumber ***************************************
			if OS_CILGET( "ISYSSERNUM", #pISysSernum ) = SYS_ERR_NONE then
			
				p_PLCInfo := ISYSSERNUM_SERNUMGETPLCINFO();
							
				if p_PLCInfo <> NIL then
					String0.WriteDataOff(udLen:=_StrLen(#p_PLCInfo^.szSerialNumber[0]), udOff:=0, pData:=#p_PLCInfo^.szSerialNumber[0]);
          
          //PH001: also get the application name
          AppliName.WriteDataOff(udLen:=_StrLen(#p_PLCInfo^.szApplication[0]), udOff:=0, pData:=#p_PLCInfo^.szApplication[0]);

          pFunction := _FindFctName("LDR_GetPrjInfo");
          if ( pFunction <> NIL ) then
            pFunction $ LDR_GetPrjInfo((#HiRev)$^BYTE, (#LoRev)$^BYTE, #pPrjName);
          
            ProjectRevision := (HiRev SHL 8) OR LoRev;
          end_if;
				end_if;
			end_if;

			//look if we need a task
			if ( us_NoTask = 0 ) then		//#SR003
				ud_Timestamp := ops.tAbsolute - 1secs;
				CyWork(0);
				To_TaskObjectControl.AddCyclicObject(	  pObj		:= this
														, udMode	:= 2 // TASK_TIMED
														, udTime	:= 100ms
														, udPhase	:= 0
														);
			end_if;							//#SR003
		end_if;
	end_if;

END_FUNCTION //VIRTUAL GLOBAL PLC_Info::Init


FUNCTION VIRTUAL GLOBAL PLC_Info::CyWork
	VAR_INPUT
		InEAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state 	: UDINT;
	END_VAR
  VAR
  	XilinxRegs        : SINT;       // 8 bit signed int
    retval : DINT;
    tmpCPUTemperature : DINT;
  END_VAR

  case WhoAmI of
  
    ARM_IMX6_CPU:
    //*****************************************************************************

      if ops.tAbsolute - ud_Timestamp >= PLC_INFO_UPDATE_TIME then
        ud_Timestamp := ops.tAbsolute;

        if pT_XREGS then
          BatteryOk := pT_XREGS^.Batt_funct$funct_XREGS_BattGood();
          Supply24VOk := pT_XREGS^.Power_funct$funct_XREGS_PowerGood();
        end_if;
        
        //Get CPU Temperature        
        if pLSLSysInfo then
        
          //Use temporary variable for value to be thread safe (server CPU Temperature will only be written one time)
          retval := OS_SYSINFO_GET_PROP(pLSLSysInfo, LSL_SYSINFO_ID_TEMPSENS_CPU0, #tmpCPUTemperature, sizeof(tmpCPUTemperature));
          
          if retval = LSL_SYSINFO_ERR_NONE then
            //Convert to °C
            tmpCPUTemperature := tmpCPUTemperature / 1000;
          else
            tmpCPUTemperature := INVALID$DINT;
          end_if;
          
          CPUTemperature := tmpCPUTemperature;
        
        end_if;
      end_if;
      
    StandardPC_CPU:
    //*****************************************************************************
    
      if ops.tAbsolute - ud_Timestamp >= PLC_INFO_UPDATE_TIME then
        ud_Timestamp := ops.tAbsolute;
        
        //Get CPU Temperature        
        if pLSLSysInfo then
          
          //Check if we got a valid pointer to the CPU Reg (e.g. at CP731)
          if p_CPUReg then
            tmpCPUTemperature  := ((p_CPUReg + PLC_INFO_CPU_REGISTER_OFFSET_CPU_TEMP)^$UINT -273) * PLC_INFO_CONVERT_TO_1_10_CELSIUS;
          else
            //Use temporary variable for value to be thread safe (server CPU Temperature will only be written one time)        
            retval := OS_SYSINFO_GET_PROP(pLSLSysInfo, LSL_SYSINFO_ID_TEMPSENS_CPU0, #tmpCPUTemperature, sizeof(tmpCPUTemperature));
            
            if retval = LSL_SYSINFO_ERR_NONE then
              //Convert to °C
              tmpCPUTemperature := tmpCPUTemperature / 1000;
            else
              tmpCPUTemperature := INVALID$DINT;
            end_if;
          end_if;
          
          CPUTemperature := tmpCPUTemperature;          
        
        end_if;
        
        if pT_XREGS then
          BatteryOk := pT_XREGS^.Batt_funct$funct_XREGS_BattGood();
          Supply24VOk := pT_XREGS^.Power_funct$funct_XREGS_PowerGood();    
        end_if;
      end_if;
      
    C_IPC_CPU:
    //*****************************************************************************

      //Update CIPC
      if ops.tAbsolute - ud_Timestamp >= PLC_INFO_UPDATE_TIME then
        ud_Timestamp := ops.tAbsolute;
        
        if b_StateRegsOk then
          XilinxRegs := (p_XilinxRegs+2)^$SINT;
          XilinxRegs := XilinxRegs XOR 2#110;

          if XilinxRegs AND 2#00000001 then
            BatteryOk := 1;
          else
            BatteryOk := 0;
          end_if;
          
          if XilinxRegs AND 2#00000010 then
            Supply24VOk := 1;
          else
            Supply24VOk := 0;
          end_if;
          
          if XilinxRegs AND 2#00000100 then
            TemperatureOk := 1;
          else
            TemperatureOk := 0;
          end_if;
        end_if;

        //UpdateFanTemp
        if b_TempOk then
          CPUTemperature := (p_XilinxRegs+1)^$SINT;
        end_if;

        //UpdateFan
        if b_CheckFanOk then
          if p_XilinxRegs^$SINT | (p_PWMRegs+4)^$SINT < 16#C then
            FanOk := 1;
          else
            FanOk := 0;
          end_if;
        end_if;
      end_if;

    CCL911_CPU:
    //*****************************************************************************

      //Update CCL911 standard
      if ops.tAbsolute - ud_Timestamp >= PLC_INFO_UPDATE_TIME  then
        ud_Timestamp := ops.tAbsolute;

        XilinxRegs := (p_XilinxRegs+1)^$SINT;

        if XilinxRegs AND 2#00000001 then
          Supply24VOk := 1;
        else
          Supply24VOk := 0;
        end_if;

        if XilinxRegs AND 2#00000010 then
          BatteryOk := 1;
        else
          BatteryOk := 0;
        end_if;
      end_if;

    Teachbox_CPU:
    //*****************************************************************************

      //Neureder Teachbox     //#SR002 cmp.d		CPUName,CCL911Neureder
      if ops.tAbsolute - ud_Timestamp >= PLC_INFO_UPDATE_TIME then
        ud_Timestamp := ops.tAbsolute;
      
        XilinxRegs := p_XilinxRegs^$SINT;
        
        if XilinxRegs AND 2#00000001 then
          BatteryOk := 1;
        else
          BatteryOk := 0;
        end_if;

        if XilinxRegs AND 2#00001000 then
          Supply24VOk := 1;
        else
          Supply24VOk := 0;
        end_if;
      end_if;


    ETV_CPU,
    ETVEDGE_CPU,
    CCP511_CPU:
    //*****************************************************************************

      //ETV Terminals
      if ops.tAbsolute - ud_Timestamp >= PLC_INFO_UPDATE_TIME then
        ud_Timestamp := ops.tAbsolute;
      
        if p_XilinxRegs <> NIL then
          XilinxRegs := p_XilinxRegs^$SINT;
        
          if XilinxRegs AND 2#00000001 then
            BatteryOk := 1;
          else
            BatteryOk := 0;
          end_if;

          if XilinxRegs AND 2#00001000 then
            Supply24VOk := 1;
          else
            Supply24VOk := 0;
          end_if;
        end_if;

        //Look4Temp
        if p_Period <> NIL then
          CPUTemperature := p_Period^ * ui_TempMult / ui_TempDivisor - ui_TempOffset;
        else
          //Look4Temp2
          if p_Fan <> NIL then
            CPUTemperature := p_Fan^.Temperature - 273;   //convert kelvin to celcius
            
            // check both fan bits
            if p_Fan^.StatusRegister.Fan1OK & p_Fan^.StatusRegister.Fan2OK then
              FanOk := 1;
            else
              FanOk := 0;
            end_if;

            if p_Fan^.StatusRegister.TempLimitOK then
              TemperatureOk := 1;
            else
              TemperatureOk := 0;
            end_if;
          else
            //Look4Temp3
            if p_SdiasPc <> NIL then
              CPUTemperature := p_SdiasPc^.CpuTemp;
            end_if;
          end_if;
        end_if;
      end_if;
  end_case;
  
  state := READY;

END_FUNCTION //VIRTUAL GLOBAL PLC_Info::CyWork


FUNCTION VIRTUAL GLOBAL PLC_Info::CPUBoardName::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	CPUBoardName := CPUBoard.Data.Read();
	output := CPUBoardName;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PLC_Info::CPUBoardName::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	CPUBoardName := input;
	result := (CPUBoard.Data.Write(CPUBoardName))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PLC_Info::GetSysInfoID::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
 	  a_name				: ARRAY[0..99] OF USINT;  // max 99 chars + 1 byte closing 0  	
  END_VAR
  
  if pLSLSysInfo then
    
    //4 Byte Value
    if SysInfoType = 0 then
    
      GetSysInfoID := OS_SYSINFO_GET_PROP(pLSLSysInfo, input$LSL_SYSINFO_ID, #SysInfoValue, sizeof(SysInfoValue));
            
    // String
    elsif SysInfoType = 1 then
        
      GetSysInfoID := OS_SYSINFO_GET_PROP(pLSLSysInfo, input$LSL_SYSINFO_ID, #a_name[0], sizeof(a_name));
      //Check for error code
      if GetSysInfoID = LSL_SYSINFO_ERR_NONE then
        SysInfo.WriteDataOff( udLen:= _strlen(src:=#a_name[0]) + 1, udOff := 0, pData := #a_name[ 0 ] );
      end_if;      
    end_if;
  end_if;
  
	result := GetSysInfoID;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PLC_Info::SysInfoString::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	SysInfoString := SysInfo.Data.Read();
	output := SysInfoString;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PLC_Info::SysInfoString::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	SysInfoString := input;
	result := (SysInfo.Data.Write(SysInfoString))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PLC_Info::SysInfoType::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if input then
    SysInfoType := 1;
  else
    SysInfoType := 0;
  end_if;

	result := SysInfoType;

END_FUNCTION
