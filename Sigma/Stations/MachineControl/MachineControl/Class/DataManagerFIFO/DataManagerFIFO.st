//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define MEMORY_Mark_DataMngFiFo    8 
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DataManagerFIFO"
	Revision           = "1.0"
	GUID               = "{97C2EA56-900F-4095-BA42-C27E7F65B176}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(450,120)"
	Comment            = "Provides functionality of a FIFO-Buffer for TCPCom classes.">
	<Channels>
		<Server Name="ClassSvr" GUID="{A4FD9C76-0C78-4655-9661-D667618CB16B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zeigt die aktuelle Anzahl der Einträge im FIFO.&#13;&#10;&#13;&#10;Shows the current amount of entries in the FIFO."/>
		<Client Name="Section" Required="true" Internal="true"/>
		<Client Name="StdLib" Required="false" Internal="false" Comment="Objekt Kanal auf die Klasse  _StdLib&#13;&#10;&#13;&#10;Object Channel to class _StdLib to access memory functions."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HötAnt"/>
		<Dokumentation Revision="1.0" Date="2015-01-08" Author="ObeChr" Company="Sigmatek" Description="Prepared class for library"/>
		<Dokumentation Revision="0.1" Date="2014-05-20" Author="HötAnt" Company="Sigmatek" Description="Created class"/>
	</RevDoku>
	<Network Name="DataManagerFIFO">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "Section"
				GUID       = "{0F29AD40-A242-4A68-B0F2-590F2BF91363}"
				Class      = "CriticalSection"
				Position   = "(180,420)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Section" Destination="Section.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
DataManagerFIFO : CLASS
	TYPE
#pragma pack(push, 1)
	  t_s_Header : STRUCT  //! <Type Comment="Konfiguration der Nachricht.&#13;&#10;&#13;&#10;Configuration of the message." Name="t_s_Header"/>
	    Prio : DINT;  //! <Type Comment="Priorität der Nachricht&#13;&#10;" Name="t_s_Header.Prio"/>
	    Timeout : UDINT;  //! <Type Comment="Timeout für die Nachricht [ms ]&#13;&#10;" Name="t_s_Header.Timeout"/>
	    Timestamp : UDINT;  //! <Type Comment="Zeitstempel , wann die Nachricht&#13;&#10;aufgegeben wurde.&#13;&#10;" Name="t_s_Header.Timestamp"/>
	    JobID : DINT;  //! <Type Comment="Eindeutige Job ID&#13;&#10;" Name="t_s_Header.JobID"/>
	    Valid : BOOL;  //! <Type Comment="TRUE  .. Eintrag ist gültig.&#13;&#10;FALSE .. Eintrag wurde gelöscht.&#13;&#10;" Name="t_s_Header.Valid"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Info : STRUCT  //! <Type Comment="Informationen der Nachricht.&#13;&#10;&#13;&#10;Information of the message." Name="t_s_Info"/>
	    SourceID : DINT;  //! <Type Comment="Von wem kommt die Nachricht.&#13;&#10;" Name="t_s_Info.SourceID"/>
	    DestinationID : DINT;  //! <Type Comment="Zu wem soll die Nachricht.&#13;&#10;" Name="t_s_Info.DestinationID"/>
	    pThis : ^void;  //! <Type Comment="THIS Pointer des Senders&#13;&#10;für die Status CallBacks.&#13;&#10;" Name="t_s_Info.pThis"/>
	    pCallback : ^void;  //! <Type Comment="Funktionspointer der CallBack Funktion&#13;&#10;um die Status Infos weiterzugeben.&#13;&#10;" Name="t_s_Info.pCallback"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_e_Entry : STRUCT  //! <Type Public="true" Comment="Informationen über die Nachricht.&#13;&#10;&#13;&#10;Information about the message." Name="t_e_Entry"/>
	    Header : t_s_Header;  //! <Type Comment="Konfiguration der Nachricht.&#13;&#10;&#13;&#10;Configuration of the message.&#13;&#10;" Name="t_e_Entry.Header"/>
	    Info : t_s_Info;  //! <Type Comment="Informationen der Nachricht.&#13;&#10;&#13;&#10;Information of the message." Name="t_e_Entry.Info"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Data : STRUCT  //! <Type Public="true" Comment="Daten der Nachricht.&#13;&#10;&#13;&#10;Data of the message." Name="t_s_Data"/>
	    ptr : pVoid;  //! <Type Comment="Pointer auf die Daten.&#13;&#10;" Name="t_s_Data.ptr"/>
	    size : UDINT;  //! <Type Comment="Größe der Nachricht.&#13;&#10;" Name="t_s_Data.size"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_DataCell : STRUCT  //! <Type Comment="Ein Eintrag im FIFO&#13;&#10;&#13;&#10;One entry of the FIFO." Name="t_s_DataCell"/>
	    EntrieInfo : t_e_Entry;  //! <Type Comment="Informationen der Nachricht." Name="t_s_DataCell.EntrieInfo"/>
	    Data : t_s_Data;  //! <Type Comment="Daten der Nachricht.&#13;&#10;" Name="t_s_DataCell.Data"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_UDINT;
  //Clients:
	Section 	: CltChCmd_CriticalSection;
	StdLib 	: CltChCmd__StdLib;
  //Variables:
		Data : ARRAY [0..1000] OF t_s_DataCell;
			//! <Variable Comment="Alle FIFO Einträge.&#13;&#10;&#13;&#10;FIFO entries." Name="Data"/>
		RdIndex 	: UDINT;			//! <Variable Comment="Lesezeiger&#13;&#10;&#13;&#10;Readpointer" Name="RdIndex"/>
		WrIndex 	: UDINT;			//! <Variable Comment="Schreibzeiger&#13;&#10;&#13;&#10;Writepointer" Name="WrIndex"/>
  //Functions:
				//! <Function Comment="Initialisierung der Variablen.&#13;&#10;&#13;&#10;Initialisation of the variables." Name="DataManagerFIFO"/>
	FUNCTION DataManagerFIFO
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Fügt einen Eintrag hinzu.&#13;&#10;&#13;&#10;Adds an entry to the FIFO." Name="Put"/>
	FUNCTION GLOBAL Put
		VAR_INPUT
			pEntrieInfo 	: ^DataManagerFIFO::t_e_Entry;			//! <Variable Comment="Pointer auf die Informationen der Nachricht.&#13;&#10;" Name="Put.pEntrieInfo"/>
			ptr 	: ^void;			//! <Variable Comment="Pointer auf die Daten&#13;&#10;" Name="Put.ptr"/>
			length 	: UDINT;			//! <Variable Comment="Länge der Daten&#13;&#10;" Name="Put.length"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE ... konnte nicht eingetragen werden.&#13;&#10;TRUE .... wurde erfolgreich eingetragen.&#13;&#10;" Name="Put.retcode"/>
		END_VAR;
				//! <Function Comment="Holt einen Eintrag aus dem Buffer.&#13;&#10;&#13;&#10;Fetches an entry from the FIFO buffer." Name="Get"/>
	FUNCTION GLOBAL Get
		VAR_INPUT
			pdst 	: ^void;			//! <Variable Comment="Pointer wohin die Daten kopiert werden sollen.&#13;&#10;" Name="Get.pdst"/>
			plength 	: ^UDINT;			//! <Variable Comment="Hier wird die Länge der kopierten Daten&#13;&#10;draufgeschrieben.&#13;&#10;" Name="Get.plength"/>
			pEntrieInfo 	: ^DataManagerFIFO::t_e_Entry;			//! <Variable Comment="Pointer auf die Informationen der&#13;&#10;Nachricht.&#13;&#10;" Name="Get.pEntrieInfo"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE .. Kein Eintrag im Buffer.&#13;&#10;TRUE ... Eintrag wurde ausgelesen.&#13;&#10;" Name="Get.retcode"/>
		END_VAR;
				//! <Function Comment="Löscht einen Job aus dem Buffer.&#13;&#10;( wird nicht gelöscht , sondern wird als&#13;&#10;ungültig markiert )&#13;&#10;&#13;&#10;Deletes a job from the buffer (job is not deleted but marked as canceled)." Name="DeleteJob"/>
	FUNCTION GLOBAL DeleteJob
		VAR_INPUT
			JobId 	: DINT;			//! <Variable Comment="ID des zu löschenden Jobs." Name="DeleteJob.JobId"/>
			pEntrieInfo 	: ^t_e_Entry;			//! <Variable Comment="Wird von der Funktion beschrieben , wenn&#13;&#10;der zu Löschende Job gefunden wurde.&#13;&#10;" Name="DeleteJob.pEntrieInfo"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="False .. ID not found&#13;&#10;True  .. Entry marked as invalid&#13;&#10;" Name="DeleteJob.retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using CriticalSection
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DataManagerFIFO::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DATAMANAGERFIFO
1$UINT, 0$UINT, (SIZEOF(::DataManagerFIFO))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2873804345), "DataManagerFIFO", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::DataManagerFIFO.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::DataManagerFIFO.Section.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(305562869), "Section", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
(::DataManagerFIFO.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_DataManagerFIFO 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DataManagerFIFO] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DataManagerFIFO::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_DataManagerFIFO, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= DataManagerFIFO();

END_FUNCTION

//{{LSL_IMPLEMENTATION

#define CELL_CNT (sizeof(Data) / sizeof(Data[0]))


FUNCTION DataManagerFIFO::DataManagerFIFO
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;
  _memset(#Data[0], 0, sizeof(Data));
  RdIndex := 0;
  WrIndex := 0;

END_FUNCTION


FUNCTION GLOBAL DataManagerFIFO::Put
	VAR_INPUT
		pEntrieInfo 	: ^DataManagerFIFO::t_e_Entry;
		ptr 	: ^void;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    ph : ^void;
    wrx : udint;
  end_var

  retcode := false;
  if((ptr <> nil) & (length > 0)) then
    ph := StdLib.MallocV1(length,MEMORY_Mark_DataMngFiFo);
    if(ph <> nil) then
      _memcpy(ph, ptr, length);

      Section.SectionStart(); // *********************
      
      wrx := WrIndex - RdIndex;
      if(wrx < CELL_CNT) then
        wrx            := WrIndex mod CELL_CNT;
        Data[wrx].Data.ptr  := ph;
        Data[wrx].Data.size := length;
        Data[wrx].EntrieInfo := pEntrieInfo^;
        WrIndex        += 1;
        retcode        := true;
        ph             := nil;
        
        ClassSvr := WrIndex - RdIndex;
        
      end_if;
      
      Section.SectionStop(); // *********************
      
      if(ph <> nil) then
        StdLib.Free(ph); // ausserhalb section weil ggf. lange dauert
      end_if;
      
    end_if;
  end_if;

END_FUNCTION


FUNCTION GLOBAL DataManagerFIFO::Get
	VAR_INPUT
		pdst 	: ^void;
		plength 	: ^UDINT;
		pEntrieInfo 	: ^DataManagerFIFO::t_e_Entry;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    rd : udint;
    cell : t_s_DataCell;
  end_var

  retcode  := false;
  plength^ := 0;
  
  
  
  if(RdIndex < WrIndex) then
  
    Section.SectionStart(); // *********************
    rd := RdIndex mod CELL_CNT;
    cell          := Data[rd];
    Data[rd].Data.ptr  := nil;
    Data[rd].Data.size := 0;
    _memset(#Data[rd].EntrieInfo,0,sizeof(t_e_Entry));
    RdIndex       += 1;
    
    if(RdIndex = WrIndex) then
      RdIndex := 0;
      WrIndex := 0;
    end_if;
    
    ClassSvr := WrIndex - RdIndex;
    
    retcode  := true;
    Section.SectionStop(); // *********************
  end_if;

  

  if(retcode = true) then
    // ausserhalb section weil ggf. lange dauert
    if pdst <> NIL then
      _memcpy(pdst, cell.data.ptr, cell.data.size);
    end_if;
    pEntrieInfo^ := cell.EntrieInfo;
    StdLib.Free(cell.data.ptr);
    plength^ := cell.data.size;
  end_if;

END_FUNCTION






FUNCTION GLOBAL DataManagerFIFO::DeleteJob
	VAR_INPUT
		JobId 	: DINT;
		pEntrieInfo 	: ^t_e_Entry;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	x : dint;
  END_VAR

  
  // Rückgabewert setzen
  retcode := FALSE;
  
  Section.SectionStart(); // *********************
  
  // Alle Einträge durchsuchen
  for x:= 0 to CELL_CNT do
  
    // Stimmt die ID überein
    if JobId = Data[x].EntrieInfo.Header.JobID then
      // Eintrag als ungültig markieren.
      Data[x].EntrieInfo.Header.Valid := FALSE;
      
      pEntrieInfo^ := Data[x].EntrieInfo;
      // Rückgabewert setzen
      retcode := TRUE;
      // und abbrechen.
      exit;
    end_if;
  
  end_for;
  
  Section.SectionStop(); // *********************

END_FUNCTION
