//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\TCPCommunicationLogViewer\TCPCommunicationLogViewer.h"

(*!
<Class
	Name               = "TCPCommunicationLogViewer"
	Revision           = "1.4"
	GUID               = "{14F2219D-3F51-4BAB-A2B6-A091BF152E6A}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "1 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(672,120)"
	Comment            = "Die Klasse kann zum Visualisieren des &#13;&#10;Log-Buffers der Klasse TCPCommunication verwendet werden.&#13;&#10;&#13;&#10;Can be used to visualise the log buffer of the class TCPCommunication.">
	<Channels>
		<Server Name="ExportToUSB" GUID="{DE3D52C7-AFE5-42C1-9438-966763768FD0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Exportiert die aktuellen Einträge in ein&#13;&#10;Excel File. Kann nur ausgeführt werden , wenn&#13;&#10;das Logging angehalten wurde.&#13;&#10;&#13;&#10;Initiates the export of the actual log entries to an excel file. Export can only be started if logging is deactivated."/>
		<Server Name="TimeStampRelative" GUID="{9830934A-280E-46ED-B5F9-7F83982383BC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="0..Absolute&#13;&#10;1..Relative zum letzten Eintrag&#13;&#10;&#13;&#10;0..Show absolute timestamps&#13;&#10;1..Show timestamps relative to the entry before"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="Muß nicht verbunden werden. ( OS Interface Classe )&#13;&#10;&#13;&#10;Wird benötigt um die Daten in eine Excel-File zu exportieren.&#13;&#10;&#13;&#10;Objekt Kanal : _FileSys&#13;&#10;&#13;&#10;&#13;&#10;Connection to the os-interface to access file functions (does not have to be connected)."/>
		<Client Name="coTCPCommunication" Required="true" Internal="false" Comment="Verbindung zur Kommunikation.&#13;&#10;Objekt Kanal : TCPCommunication&#13;&#10;&#13;&#10;( über diesen Client werden die anzuzeigenden&#13;&#10;Daten ausgelesen )&#13;&#10;&#13;&#10;&#13;&#10;Connection to the communication class (to read out the data to display)."/>
		<Client Name="SysDate" Required="true" Internal="false" Comment="To access system date (connect to Server SysDate of Class SysDateTime)"/>
		<Client Name="SysTime" Required="true" Internal="false" Comment="To access system time (connect to Server SysTime of Class SysDateTime)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\TCPCommunicationLogViewer\TCPCommunicationLogViewer.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HötAnt"/>
		<Dokumentation Revision="1.4" Date="2016-08-16" Author="HubChr" Company="Sigmatek" Description="Types of Clients SysDate and SysTime are changed back since Compilerwarning is now taken care of in Lasal2"/>
		<Dokumentation Revision="1.3" Date="2016-07-22" Author="HubChr" Company="Sigmatek" Description="Changed Types of SysDate and SysTime to suppress compiler warning."/>
		<Dokumentation Revision="1.2" Date="2015-11-13" Author="HubChr" Company="Sigmatek" Description="Corrected spelling mistakes in MakeLineTxt()"/>
		<Dokumentation Revision="1.1" Date="2015-11-11" Author="HötAnt" Company="Sigmatek" Description="added new Messages"/>
		<Dokumentation Revision="1.0" Date="2015-01-08" Author="ObeChr" Company="Sigmatek" Description="Prepared class for library"/>
		<Dokumentation Revision="0.1" Date="2014-06-26" Author="HötAnt" Company="Sigmatek" Description="Created class"/>
	</RevDoku>
	<Network Name="TCPCommunicationLogViewer">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C181EFB6-C0E5-4DE1-A516-852778CDB571}"
				Class      = "_ScrollArea2"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ActPos"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="ExtendedScrollBar" Value="1"/>
					<Client Name="LineHighness"/>
					<Client Name="LineWidth" Value="0"/>
					<Client Name="Lse"/>
					<Client Name="VerticalLevel" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(886,210),(714,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(886,270),(714,270),"/>
			<Connection Source="this.ActPos" Destination="_base.ActPos" Vertices="(886,330),(714,330),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.VerticalLevel" Destination="this.VerticalLevel" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.LineWidth" Destination="this.LineWidth" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.LineHighness" Destination="this.LineHighness" Vertices="(218,390),(38,390),"/>
			<Connection Source="_base.ExtendedScrollBar" Destination="this.ExtendedScrollBar" Vertices="(218,450),(38,450),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _ScrollArea2

TCPCommunicationLogViewer : CLASS
: _ScrollArea2
	TYPE
	  t_e_ExportState :  //! <Type Public="true" Comment="Zeit den Status des Export an." Name="t_e_ExportState"/>
	  (
	    ExportState_NoAction,  //! <Type Comment="es wird nichts gemacht." Name="t_e_ExportState.ExportState_NoAction"/>
	    ExportState_Start,  //! <Type Comment="Export gestartet" Name="t_e_ExportState.ExportState_Start"/>
	    ExportState_Ready,  //! <Type Comment="Export fertig&#13;&#10;" Name="t_e_ExportState.ExportState_Ready"/>
	    ExportState_WaitTouch,  //! <Type Comment="Warten auf Touch um Export abzuschließen" Name="t_e_ExportState.ExportState_WaitTouch"/>
	    ExportState_Error,
	    ExportState_WaitTouch2
	  )$UDINT;
	  t_e_ExportSteps :
	  (
	    Export_CheckEntries,
	    Export_CreateDriectory,
	    Export_WaitCreateDirectory,
	    Export_CreateFile,
	    Export_WaitFileCreate,
	    Export_Line,
	    Export_WaitForWrite,
	    Export_CloseFile,
	    Export_WaitCloseFile
	  )$UDINT;
	  t_e_TxtType :
	  (
	    TextType_Typ,
	    TextType_Command,
	    TextType_TimeStamp,
	    TextType_Length,
	    TextType_SourceID,
	    TextType_DestinationID,
	    TextType_DestinationCMD,
	    TextType_Prio,
	    TextType_JobID,
	    TextType_TimeOut,
	    TextType_This,
	    TextType_Callback,
	    TextType_State,
	    TextType_ExportDPNE,
	    TextType_ExportProgress,
	    TextType_ExportFinish,
	    TextType_ExportWaitTouch,
	    TextType_ExportError
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_ExportUSB : STRUCT
	    eExportSteps : t_e_ExportSteps;
	    dNr : DINT;
	    dAsyncID : DINT;
	    dFileHandle : DINT;
	    dIndexAct : DINT;
	    dAsyncResult : DINT;
	    udLength : UDINT;
	    aDPNE : ARRAY [0..999] OF CHAR;
	    udTimeStampRefresh : UDINT;
	    udTimeStampStartExport : UDINT;
	    udTimeStampStopExport : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	TimeStampRelative 	: SvrCh_DINT;
	ExportToUSB 	: SvrCh_t_e_ExportState_PTofCls_TCPCommunicationLogViewer;
  //Clients:
	coTCPCommunication 	: CltChCmd_TCPCommunication;
	SysDate 	: CltCh_HDINT;
	SysTime 	: CltCh_HDINT;
	coFileSys 	: CltChCmd__FileSys;
  //Variables:
		udoldBegin 	: UDINT;
		sExportData 	: t_s_ExportUSB;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="method is called every time when redraw of a single line is necessary.&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
	
	FUNCTION OutTabLine
		VAR_INPUT
			pRoom 	: ^_ROOM;
			Description 	: BOOL := FALSE;
		END_VAR;
	
	FUNCTION MakeLineTxt
		VAR_INPUT
			ptxt 	: ^_CHAR;
			txtType 	: t_e_TxtType;			//! <Variable Comment="0..Type ausgeben.&#13;&#10;1..Commando ausgeben.&#13;&#10;2..Timestamp&#13;&#10;3..Länge&#13;&#10;4..SouceID&#13;&#10;5..DestinationID&#13;&#10;6..Priorität ausgeben&#13;&#10;7..JobID&#13;&#10;8..Timeout&#13;&#10;9..Objectname&#13;&#10;10.Callback&#13;&#10;11.Statusmeldungen&#13;&#10;&#13;&#10;" Name="MakeLineTxt.txtType"/>
			pEntrie 	: ^TCPCommunication::t_s_LogEntry;
			pEntrie2 	: ^TCPCommunication::t_s_LogEntry;
		END_VAR;
	
	FUNCTION AddTxtToLine
		VAR_INPUT
			pLine 	: ^_ASCII;
			pTxt 	: ^_CHAR;
		END_VAR;
	
	FUNCTION AddTabToLine
		VAR_INPUT
			pLine 	: ^_ASCII;
		END_VAR;
	
	FUNCTION AddCRLFToLine
		VAR_INPUT
			pLine 	: ^_ASCII;
		END_VAR;
	
	FUNCTION ExportToUSB_A;
	
	FUNCTION CreateDPNE
		VAR_INPUT
			pChar 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TimeStampRelative::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd TCPCommunication


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TCPCommunicationLogViewer::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_TCPCOMMUNICATIONLOGVIEWER
1$UINT, 4$UINT, (SIZEOF(::TCPCommunicationLogViewer))$UINT, 
2$UINT, 4$UINT, 0$UINT, 
TO_UDINT(185738949), "TCPCommunicationLogViewer", //Class
TO_UDINT(2779823616), "_ScrollArea2", 0$UINT, 8$UINT, //Baseclass
//Servers:
(::TCPCommunicationLogViewer.TimeStampRelative.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3099395915), "TimeStampRelative", 
(::TCPCommunicationLogViewer.ExportToUSB.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2855666341), "ExportToUSB", 
//Clients:
(::TCPCommunicationLogViewer.coTCPCommunication.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2628164504), "coTCPCommunication", TO_UDINT(3704218787), "TCPCommunication", 1$UINT, 14$UINT, 
(::TCPCommunicationLogViewer.SysDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1714210210), "SysDate", 
(::TCPCommunicationLogViewer.SysTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2737203869), "SysTime", 
(::TCPCommunicationLogViewer.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 19$UINT, 
END_FUNCTION


#define USER_CNT_TCPCommunicationLogViewer 23

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TCPCommunicationLogViewer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TCPCommunicationLogViewer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _ScrollArea2::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_TCPCommunicationLogViewer;
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TimeStampRelative.pMeth			:= StoreMethod( #M_RD_DIRECT(), #TimeStampRelative::Write() );
	IF TimeStampRelative.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ExportToUSB.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ExportToUSB.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma usingltd RamRingBuffer

FUNCTION __CDECL VIRTUAL GLOBAL TCPCommunicationLogViewer::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  // Anzahl der Einträge im Buffer auslesen + 1 für Überschrift.
  Scroll.position.no := to_dint(coTCPCommunication.RamRingBuffer.GetNoOfRecords()+1);
  
  // Base aufrufen , damit initialisiert wird.
  _ScrollArea2::IF_Start(pio, firsttime);

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL TCPCommunicationLogViewer::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  VAR
    txt        : ARRAY [0..300] of _CHAR; 
    color      : _COLOR; 
    att        : _ATTRIB; 
    TmpEntrie  : TCPCommunication::t_s_LogEntry;
    TmpEntrie2 : TCPCommunication::t_s_LogEntry;
    TabRoom    : _room;
    attrib     : _ATTRIB;
    TabLength  : _KOORD;
    TabWidth   : _KOORD;
    faktorx    : REAL;
  END_VAR
  
  // Initialisieren der localen Variable.
  _memset(dest:=#TmpEntrie, usByte:=0, cntr:=sizeof(TmpEntrie));
  _memset(dest:=#TmpEntrie2, usByte:=0, cntr:=sizeof(TmpEntrie2));

  // ************************************************************************************************************************* 
  // ***************************           Loggingeinträge ausgeben.                 *****************************************
  // *************************************************************************************************************************
  if ExportToUSB = ExportState_NoAction then
  
    // aktuellen Room der Zeile umkopieren , um diese zu verändern . ( Spalten erzeugen )
    TabRoom := pr^;
    
    // Linken Rand hinzufügen.
    TabRoom.xy1.x +=TCPCommLogViewer_Tab_Left;
    
    // Erste Spalte definieren.
    TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Type;

    // abhängig ob die Zeile angewählt ist oder nicht. ( Color und Attribut setzen )
    if(state = TRUE) then
      color := ps^.color_activ; 
      attrib := ps^.attrib_activ;
    else
      color := ps^.color_inactiv;
      attrib := ps^.attrib_inactiv;
    end_if; 

    // Hintergrund der Zeile ausgeben. ( Thema )
    LineBackGround(ps, pr, GetBackColor(color));
    
    
    // Nur ausgeben , wenn auch ein Eintrag im Buffer ist. ( Achtung  : ein Eintrag ist die Überschrift -> keine Daten )
    if(line < ps^.position.no) then

      // ************************************************************************************************************************* 
      // ***************************           Überschrift ausgeben                      *****************************************
      // *************************************************************************************************************************
      if line = 0 then
      
        // --------------------------------------------------------------------------------------------------------------
        // Type ausgeben.
        // --------------------------------------------------------------------------------------------------------------
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Typ, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // Commando ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_CMD;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Command, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // Timestamp ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Timestamp;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeStamp, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // Länge ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Length;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Length, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // SourceID ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_SourcID;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_SourceID, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // DestinationID ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_DestID;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_DestinationID, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // Destination CMD ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_DestCMD;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_DestinationCMD, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
      
        // --------------------------------------------------------------------------------------------------------------
        // Priorität ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Prio;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Prio, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
      
        // --------------------------------------------------------------------------------------------------------------
        // JobID ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_JobID;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_JobID, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
      
        // --------------------------------------------------------------------------------------------------------------
        // Timeout ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Timeout;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeOut, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // Objekt namen - Thispointer ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_ObjectName;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_This, pEntrie:=NIL, pEntrie2:=NIL);
        att := T_LEFTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP;
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
        
        // --------------------------------------------------------------------------------------------------------------
        // Callback ausgeben
        // --------------------------------------------------------------------------------------------------------------
        TabRoom.xy1.x := TabRoom.xy2.x;
        TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Callback;
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Callback, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom,TRUE);
      
      // ************************************************************************************************************************* 
      // ***************************           Buffereinträge ausgeben                   *****************************************
      // *************************************************************************************************************************
      else
        
        // Eintrag aus Buffer holen. ( Eintrag 0 ist der neuste Eingrag. )
        coTCPCommunication.RamRingBuffer.GetRecord(pdst:=#TmpEntrie, pos:=to_udint(ps^.position.no-1-line));
        
        // Soll die Zeit relative ausgegeben werden , wird der Eintrag davor benötigt.
        if TimeStampRelative = TRUE then
          coTCPCommunication.RamRingBuffer.GetRecord(pdst:=#TmpEntrie2, pos:=to_udint(ps^.position.no-1-line-1));
        end_if;
        
        // --------------------------------------------------------------------------------------------------------------
        // Type ausgeben.
        // --------------------------------------------------------------------------------------------------------------

        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Typ, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        OutTabLine(pRoom:=#TabRoom);
        
        // --------------------------------------------------------------------------------------------------------------
        // Statusmeldungen ausgeben.
        // --------------------------------------------------------------------------------------------------------------
        if TmpEntrie.TCPType = 2 then
        
          // Room anpassen an restliche Zeile
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := pr^.xy2.x;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_State, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));

        else
        
          // --------------------------------------------------------------------------------------------------------------
          // Commando ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_CMD;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Command, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // TimeStamp ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Timestamp;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeStamp, pEntrie:=#TmpEntrie, pEntrie2:=#TmpEntrie2);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // Länge ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Length;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Length, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // SourceID ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_SourcID;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_SourceID, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // DestinationID ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_DestID;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_DestinationID, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // Destination CMD ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_DestCMD;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_DestinationCMD, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // Priorität ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Prio;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Prio, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // JobID ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_JobID;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_JobID, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // Timeout ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Timeout;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeOut, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // Objekt Namen ausgeben sonst Thispointer
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_ObjectName;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_This, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          // Atrribut erzeugen , das immer Linksbündig ausgegeben werden soll. ( Name kannn lange sein )
          att := T_LEFTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP;
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
          
          // --------------------------------------------------------------------------------------------------------------
          // Callback ausgeben
          // --------------------------------------------------------------------------------------------------------------
          TabRoom.xy1.x := TabRoom.xy2.x;
          TabRoom.xy2.x := TabRoom.xy1.x + TCPCommLogViewer_Tab_Callback;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Callback, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          // Atrribut erzeugen , das immer Linksbündig ausgegeben werden soll. ( Name kannn lange sein )
          att := T_LEFTBOUND or T_MIDBOUND or T_COPY or T_SOLID or T_PROP;
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=att, col:=Graphic.MakeColor(INVISIBLE, color));
          OutTabLine(pRoom:=#TabRoom);
      
        end_if;
      
      end_if;   
   
    end_if;


  // ************************************************************************************************************************* 
  // ***************************           Wenn Exportiert wird , wird der Status augegeben          *************************
  // *************************************************************************************************************************
  else
    
    // Zeile immer inaktive ausgeben.
    color := ps^.color_inactiv;
    attrib := ps^.attrib_inactiv;
    
    ps^.nobck := FALSE;
     
    // Hintergrund der Zeile ausgeben. ( Thema )
    LineBackGround(ps, pr, GetBackColor(color));
    
    // aktuellen Room der Zeile umkopieren , um diese zu verändern . ( Spalten erzeugen )
    TabRoom := pr^;
    
    // Linken Rand hinzufügen.
    TabRoom.xy1.x +=TCPCommLogViewer_Tab_Left;
    
    case line of
      
      1:// --------------------------------------------------------------------------------------------------------------
        // Export Path ausgeben.
        // --------------------------------------------------------------------------------------------------------------
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_ExportDPNE, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        
      2:// --------------------------------------------------------------------------------------------------------------
        // Export Progress Text ausgeben
        // --------------------------------------------------------------------------------------------------------------
        MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_ExportProgress, pEntrie:=NIL, pEntrie2:=NIL);
        lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        
      3:// --------------------------------------------------------------------------------------------------------------
        // Export Progress Bar ausgeben
        // -------------------------------------------------------------------------------------------------------------- 
        
        // Room für Bar erstellen
        TabRoom := pr^;
        TabRoom.xy1.x += TCPCommLogViewer_Tab_Left_Bar;
        TabRoom.xy2.x -= TCPCommLogViewer_Tab_Right_Bar;
        TabRoom.xy1.y += 2;
        TabRoom.xy2.y -= 2;
        // Bar ausgeben.
        DrawButton(#TabRoom, attrib, ps^.frametype, TCPCommLogViewer_Bar_Color_Bg, color);
        
        // Room für ColorCurse erstellen
        TabRoom.xy1.x += TCPCommLogViewer_Tab_Left_ColorCurse;
        TabRoom.xy2.x -= TCPCommLogViewer_Tab_Right_ColorCurse;
        TabRoom.xy1.y += 3;
        TabRoom.xy2.y -= 3;
        // Berechnungen für die richtige länge des Balkens
        TabLength := TabRoom.xy2.x - TabRoom.xy1.x;
        TabWidth  := TabRoom.xy2.y - TabRoom.xy1.y;
        faktorx := to_real(TabLength) / to_real(sExportData.dNr);
        // ColorCurse ausgeben.
        color_course(#TabRoom, to_int(to_real(sExportData.dIndexAct)*faktorx), TCPCommLogViewer_Bar_Color_Start, TCPCommLogViewer_Bar_Color_Stop, attrib);
        
      
      4:// --------------------------------------------------------------------------------------------------------------
        // Export Finished ausgeben
        // --------------------------------------------------------------------------------------------------------------
        
        if (ExportToUSB <> ExportState_Error) & (ExportToUSB <> ExportState_WaitTouch2) then
          if sExportData.dNr = (sExportData.dIndexAct-1) then
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_ExportFinish, pEntrie:=NIL, pEntrie2:=NIL);
            lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
          end_if;
        else
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_ExportError, pEntrie:=NIL, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        end_if;
       
      5:// --------------------------------------------------------------------------------------------------------------
        // Export Touch the sceen for data.
        // --------------------------------------------------------------------------------------------------------------
        if sExportData.dNr = (sExportData.dIndexAct-1) | ExportToUSB = ExportState_WaitTouch2 then
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_ExportWaitTouch, pEntrie:=NIL, pEntrie2:=NIL);
          lse.Out_TextAlign(txt:=#txt[0], pr:=#TabRoom, font:=ps^.font, att:=attrib, col:=Graphic.MakeColor(INVISIBLE, color));
        end_if; 
        
      
       
    end_case;

    
        
    
  end_if;
  
END_FUNCTION
#pragma warning(disable:137);
FUNCTION __CDECL VIRTUAL GLOBAL TCPCommunicationLogViewer::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR
  
  // Base Class aufrufen , sonst geht nichts mehr
  _ScrollArea2::IF_Run(pio, input);
  
  // Ändert sich die Anzahl der Einträge im Buffer , muß neu ausgegeben werden.
  if Scroll.position.no$udint <> (coTCPCommunication.RamRingBuffer.GetNoOfRecords()+1) then
    Scroll.position.no$udint := (coTCPCommunication.RamRingBuffer.GetNoOfRecords()+1);
    LetsDraw :=TRUE;
  else
    // Ist der Buffer voll , auf den Index achten, änder sich dieser , muß neu ausgegeben werden.
    if coTCPCommunication.RamRingBuffer.head.begin <> udoldBegin then
      udoldBegin := coTCPCommunication.RamRingBuffer.head.begin;
      LetsDraw :=TRUE;
    end_if;
  end_if;

END_FUNCTION
#pragma warning(default:137);
FUNCTION TCPCommunicationLogViewer::OutTabLine
	VAR_INPUT
		pRoom 	: ^_ROOM;
		Description 	: BOOL;(* := FALSE *)
	END_VAR
  
  // Vertikale Line am Rechten Rand des Rooms ausgeben. ( Spalte )
  Graphic.Line(x1:=pRoom^.xy2.x, y1:=pRoom^.xy1.y, x2:=pRoom^.xy2.x, y2:=pRoom^.xy2.y, attrib:=T_COPY OR T_SOLID, color:=BLACK);
  // Horizontale Line am unteren Rand des Rooms aufgen . ( Zeile für Überschrift )
  if Description = TRUE then
    Graphic.Line(x1:=pRoom^.xy1.x, y1:=pRoom^.xy2.y, x2:=pRoom^.xy2.x, y2:=pRoom^.xy2.y, attrib:=T_COPY OR T_SOLID, color:=BLACK);
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL TCPCommunicationLogViewer::TimeStampRelative::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	result := TimeStampRelative := input;
  // Refresh auslösen
  LetsDraw :=TRUE;

END_FUNCTION


FUNCTION TCPCommunicationLogViewer::MakeLineTxt
	VAR_INPUT
		ptxt 	: ^_CHAR;
		txtType 	: t_e_TxtType;
		pEntrie 	: ^TCPCommunication::t_s_LogEntry;
		pEntrie2 	: ^TCPCommunication::t_s_LogEntry;
	END_VAR
  VAR
  	Numtxt     : ARRAY [0..50] of _CHAR;
    ObjectName : ARRAY [0..300] of _CHAR;
  END_VAR

  //*************************************************************************************************************************
  //*************************             Überschriften erstellen                ********************************************
  //*************************************************************************************************************************
  if pEntrie = NIL & pEntrie2 = NIL then
  
    case txtType of
    
      TextType_Typ://Type ausgeben.
        StrCpy(ptxt, sizeof(_CHAR), "Direction", sizeof(_ASCII));
        
      TextType_Command://Commando ausgeben.
        StrCpy(ptxt, sizeof(_CHAR), "CMD", sizeof(_ASCII));
        
      TextType_TimeStamp://Timestamp
        if TimeStampRelative = TRUE then
          StrCpy(ptxt, sizeof(_CHAR), "Timediff", sizeof(_ASCII));
        else
          StrCpy(ptxt, sizeof(_CHAR), "Timestamp", sizeof(_ASCII));
        end_if;
      
      TextType_Length://Länge
        StrCpy(ptxt, sizeof(_CHAR), "Length", sizeof(_ASCII));
        
      TextType_SourceID://SouceID
        StrCpy(ptxt, sizeof(_CHAR), "Source ID", sizeof(_ASCII));
      
      TextType_DestinationID://DestinationID ( Byte 1-3  of DestinationID )
        StrCpy(ptxt, sizeof(_CHAR), "Destination ID", sizeof(_ASCII));
        
      TextType_DestinationCMD: // Destination CMD (  Byte 4 of Destination ID )
        StrCpy(ptxt, sizeof(_CHAR), "Dest. CMD", sizeof(_ASCII));
      
      TextType_Prio://Priorität ausgeben
        StrCpy(ptxt, sizeof(_CHAR), "Prio", sizeof(_ASCII));
      
      TextType_JobID://JobID
        StrCpy(ptxt, sizeof(_CHAR), "Job ID", sizeof(_ASCII));
      
      TextType_TimeOut://Timeout
        StrCpy(ptxt, sizeof(_CHAR), "Timeout", sizeof(_ASCII));
      
      TextType_This://Objectname
        StrCpy(ptxt, sizeof(_CHAR), "Object Name - ThisPointer", sizeof(_ASCII));
      
      TextType_Callback://Callback  
        StrCpy(ptxt, sizeof(_CHAR), "Callback", sizeof(_ASCII));
        
      TextType_ExportDPNE: // Pfad ausgeben , wohin exportiert wird.
        StrCpy(ptxt, sizeof(_CHAR), "Export started : ", sizeof(_ASCII));
        StrCat(p0:=ptxt, x1:=sizeof(_CHAR), p2:=#sExportData.aDPNE[0], x3:=sizeof(CHAR));
        
      TextType_ExportProgress: // Progress Bar Text ausgeben.
        StrCpy(ptxt, sizeof(_CHAR), "total Lines : ", sizeof(_ASCII));
        lse.Str_DToA(pt:=#Numtxt[0], value:= sExportData.dNr, format:=16#0800, chr_size:=sizeof(_CHAR));
        StrCat(p0:=ptxt, x1:=sizeof(_CHAR), p2:=#Numtxt[0], x3:=sizeof(_CHAR));
        StrCat(p0:=ptxt, x1:=sizeof(_CHAR), p2:=" exported : ", x3:=sizeof(CHAR));
        lse.Str_DToA(pt:=#Numtxt[0], value:= sExportData.dIndexAct-1, format:=16#0800, chr_size:=sizeof(_CHAR));
        StrCat(p0:=ptxt, x1:=sizeof(_CHAR), p2:=#Numtxt[0], x3:=sizeof(_CHAR));
        
      TextType_ExportFinish:  // Export ist abgeschlossen. Dauer des Vorgangs ausgeben.
        StrCpy(ptxt, sizeof(_CHAR), "Export finished after :", sizeof(_ASCII));
        lse.Str_DToA(pt:=#Numtxt[0], value:= to_dint((sExportData.udTimeStampStopExport-sExportData.udTimeStampStartExport)/1000), format:=16#0800, chr_size:=sizeof(_CHAR));
        StrCat(p0:=ptxt, x1:=sizeof(_CHAR), p2:=#Numtxt[0], x3:=sizeof(_CHAR));
        StrCat(p0:=ptxt, x1:=sizeof(_CHAR), p2:="s !", x3:=sizeof(CHAR));
        
      TextType_ExportWaitTouch: // User mitteilen das er touchen muß , damit er wieder die Ansicht mit den Einträgen bekommt.
        StrCpy(ptxt, sizeof(_CHAR), "Touch the screen to finish the operation !", sizeof(_ASCII));
        
      TextType_ExportError: // User mitteilen das ein Fehler aufgetreten ist
        StrCpy(ptxt, sizeof(_CHAR), "Error !! Please check the USB-Stick", sizeof(_ASCII));
        
    end_case;

  
  
  //*************************************************************************************************************************
  //*************************             Zeileneinträge erstellen                ********************************************
  //*************************************************************************************************************************
  else
  
    if pEntrie <> NIL then
    
      case txtType of
      
        TextType_Typ://Type ausgeben.
          case pEntrie^.TCPType of
        
            0: // Send Command
              StrCpy(ptxt, sizeof(_CHAR), "Send", sizeof(_ASCII));
              
            1: // Recive Command
              StrCpy(ptxt, sizeof(_CHAR), "Recive", sizeof(_ASCII));
              
            2: // Status Command
              StrCpy(ptxt, sizeof(_CHAR), "Status", sizeof(_ASCII));
              
          end_case;
          
        TextType_Command://Commando ausgeben.
          case pEntrie^.Header.Commando of
            
            PCMD_Alive :
              StrCpy(ptxt, sizeof(_CHAR), "ALI", sizeof(_ASCII));
              
            PCMD_Data  :
              StrCpy(ptxt, sizeof(_CHAR), "DAT", sizeof(_ASCII));
                
            PCMD_Acknowledge :
              StrCpy(ptxt, sizeof(_CHAR), "ACK", sizeof(_ASCII));
              
          end_case;
          
        TextType_TimeStamp://Timestamp
          // Unterscheidung ob absolut oder Relative 
          if pEntrie2 <> NIL then
            if TimeStampRelative = TRUE then
              lse.Str_DToA(pt:=ptxt, value:=(pEntrie^.TimeStamp - pEntrie2^.TimeStamp)$dint, format:=16#0800, chr_size:=sizeof(_CHAR));
            else
              lse.Str_DToA(pt:=ptxt, value:=pEntrie^.TimeStamp$dint, format:=16#0800, chr_size:=sizeof(_CHAR));
            end_if;
          end_if;
          
        TextType_Length://Länge
          lse.Str_DToA(pt:=ptxt, value:=(pEntrie^.Header.PackageSize - sizeof(TCPCommunication::t_s_LogEntry.Header))$dint, format:=16#0800, chr_size:=sizeof(_CHAR));
        
        TextType_SourceID://SouceID
          if pEntrie^.Header.SourceID <> -1 then
            lse.Str_DToA(pt:=ptxt, value:=(pEntrie^.Header.SourceID and 16#00FFFFFF), format:=16#0800, chr_size:=sizeof(_CHAR));
          else
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_DestinationID://DestinationID ( Byte 1-3  of DestinationID )
          if pEntrie^.Header.DestinationID <> -1 then
            lse.Str_DToA(pt:=ptxt, value:=(pEntrie^.Header.DestinationID and 16#00FFFFFF), format:=16#0800, chr_size:=sizeof(_CHAR));
          else
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
          
        TextType_DestinationCMD: // Destination CMD (  Byte 4 of Destination ID )
          if pEntrie^.Header.DestinationID <> -1 then
            lse.Str_DToA(pt:=ptxt, value:=((pEntrie^.Header.DestinationID and 16#FF000000$dint) shr 24), format:=16#0800, chr_size:=sizeof(_CHAR));
          else
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_Prio://Priorität ausgeben
          if pEntrie^.Prio <> -1 then
            lse.Str_DToA(pt:=ptxt, value:=pEntrie^.Prio, format:=16#0001, chr_size:=sizeof(_CHAR));
          else
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_JobID://JobID
          if pEntrie^.Header.JobId <> -1 then
            lse.Str_DToA(pt:=ptxt, value:=pEntrie^.Header.JobId, format:=16#0800, chr_size:=sizeof(_CHAR));
          else
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_TimeOut://Timeout
          if pEntrie^.TimeOut$dint <> -1 then
            lse.Str_DToA(pt:=ptxt, value:=pEntrie^.TimeOut$dint, format:=16#0800, chr_size:=sizeof(_CHAR));
          else
            // leeren Eintrag ausgeben.
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_This://Objectname
          
          if pEntrie^.Header.pThisSource <> NIL then
            // Wert auf Hex wandeln
            lse.Str_DToH(pt:=#Numtxt[0], value:=pEntrie^.Header.pThisSource$dint, format:=16#0400, chr_size:=sizeof(_CHAR));
            // 16# einfügen
            Lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:="16#", size2:=sizeof(_ASCII));
            // gewandelten Wert anfügen
            Lse.Str_Cat(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=#Numtxt[0], size2:=sizeof(_CHAR));
            // nur wenn der ThisPointer von der eigenen PLC ist wird das Objekt ermittelt.
            //if pEntrie^.Header.pThisSource <> NIL & pEntrie^.TCPType = 0 & pEntrie^.Header.Commando = PCMD_Data then
            if pEntrie^.Header.pThisSource <> NIL & pEntrie^.Header.Commando = PCMD_Data then
              if pEntrie^.TCPType = 0 |  coTCPCommunication.ConnectionType = TCPCommunication::InternConnection then
                if _GetObjName(pThis:=(pEntrie^.Header.pThisSource)$^VirtualBase, pName:=(#ObjectName[0])$^char) > 0 then       
                  // Objektname konnte ermittelt werden. Original Text überschreiben.
                  StrCpy(ptxt, sizeof(_CHAR), #ObjectName[0], sizeof(_ASCII));
                end_if;
              end_if;
            end_if;
          else
            // leeren Eintrag ausgeben.
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_Callback://Callback 
        
          if pEntrie^.Header.pCallBackSource <> NIL then
            // Wert auf Hex wandeln
            lse.Str_DToH(pt:=#Numtxt[0], value:=pEntrie^.Header.pCallBackSource$dint, format:=16#0400, chr_size:=sizeof(_CHAR));
            // 16# einfügen
            Lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:="16#", size2:=sizeof(_ASCII));
            // gewandelten Wert anfügen
            Lse.Str_Cat(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=#Numtxt[0], size2:=sizeof(_CHAR));
          else
            // leeren Eintrag ausgeben.
            lse.Str_Cpy(pt1:=ptxt, size1:=sizeof(_CHAR), pt2:=" ", size2:=sizeof(_ASCII));
          end_if;
        
        TextType_State://Statusmeldungen
          case pEntrie^.Header.Commando of 
          
            PCMD_ConnectionOK :
              StrCpy(ptxt, sizeof(_CHAR), "connection OK", sizeof(_ASCII));
              
            PCMD_ConnectionClosed  :
              StrCpy(ptxt, sizeof(_CHAR), "connection closed", sizeof(_ASCII));
                
            PCMD_ConnectionTimeOut :
              StrCpy(ptxt, sizeof(_CHAR), "timeout alive signal", sizeof(_ASCII));
              
            PCMD_TryToConnect :
              StrCpy(ptxt, sizeof(_CHAR), "try to connect", sizeof(_ASCII));
              
            PCMD_ComDeactivated : 
              StrCpy(ptxt, sizeof(_CHAR), "Communication deactivated", sizeof(_ASCII));
              
            PCMD_ComActivated : 
              StrCpy(ptxt, sizeof(_CHAR), "Communication activated", sizeof(_ASCII));
              
              
          end_case;
      
      end_case;
    
    end_if;
    
  end_if;

END_FUNCTION





FUNCTION TCPCommunicationLogViewer::AddTxtToLine
	VAR_INPUT
		pLine 	: ^_ASCII;
		pTxt 	: ^_CHAR;
	END_VAR
  
  lse.Str_Cat(pt1:=pline, size1:=sizeof(_ASCII), pt2:=pTxt, size2:=sizeof(_CHAR));

END_FUNCTION

FUNCTION TCPCommunicationLogViewer::AddTabToLine
	VAR_INPUT
		pLine 	: ^_ASCII;
	END_VAR
  VAR
  	txt : array [0..2] of char;
  END_VAR

  txt[0]:= _TAB;
  txt[1]:= 0;
  
  lse.Str_Cat(pt1:=pline, size1:=sizeof(_ASCII), pt2:=#txt[0], size2:=sizeof(_ASCII));

END_FUNCTION


FUNCTION TCPCommunicationLogViewer::AddCRLFToLine
	VAR_INPUT
		pLine 	: ^_ASCII;
	END_VAR
  VAR
  	txt : array [0..2] of char;
  END_VAR
  
  txt[0] := 13;
  txt[1] := 10;
  txt[2] := 0;
  
  lse.Str_Cat(pt1:=pline, size1:=sizeof(_ASCII), pt2:=#txt[0], size2:=sizeof(_ASCII));
  
END_FUNCTION


FUNCTION TCPCommunicationLogViewer::ExportToUSB_A
VAR
  txt        : ARRAY [0..999] of _CHAR;  
  OneLine    : ARRAY [0..999] of _ASCII;  
  TmpEntrie  : TCPCommunication::t_s_LogEntry;
  TmpEntrie2 : TCPCommunication::t_s_LogEntry;
END_VAR

  
  CASE sExportData.eExportSteps OF
  
    Export_CheckEntries:
      sExportData.udTimeStampStartExport := ops.tAbsolute;
      // Anzahl der Einträge auslesen
      sExportData.dNr$udint := coTCPCommunication.RamRingBuffer.GetNoOfRecords();
      // nur wenn Einträge vorhanden sind wird exportiert.
      if sExportData.dNr > 0 then
        sExportData.eExportSteps :=Export_CreateDriectory ;
      end_if;
  
    Export_CreateDriectory:
      // Verzeichniss Asynchron anlegen.
      sExportData.dAsyncID := coFileSys.CreateDirectory_A(Async:=1, dirname:=TCPCommLogViewer_ExportPath);
      sExportData.eExportSteps := Export_WaitCreateDirectory ;
    
    Export_WaitCreateDirectory:
      // Warten bis Aktion abgeschlossen ist.
      if coFileSys.GetAsyncState(ID:=sExportData.dAsyncID$udint, Erg:=#sExportData.dAsyncResult) = 0 then
        sExportData.eExportSteps := Export_CreateFile;  
      end_if;
      
    Export_CreateFile:
      // Filenamen erstellen.
      CreateDPNE(pChar:=#sExportData.aDPNE[0]);
      // File Asynchron anlegen.
      sExportData.dAsyncID := coFileSys.FileOpen_A(Async:=1, filename:=#sExportData.aDPNE[0], attributes:= ATT_CREATE_ALWAYS);
      sExportData.eExportSteps := Export_WaitFileCreate;
    
    Export_WaitFileCreate: 
      // Warten bis Aktion abgeschlossen ist.
      if coFileSys.GetAsyncState(ID:=sExportData.dAsyncID$udint, Erg:=#sExportData.dFileHandle) = 0 then
        // Überprüfen ob das anlegen funktoniert hat.
        if sExportData.dFileHandle >= 0 then
          sExportData.eExportSteps := Export_Line;
          sExportData.dIndexAct :=0;
        else
          ExportToUSB := ExportState_Error;
        end_if;
      end_if;
    
    Export_Line:
      if sExportData.dIndexAct <= (sExportData.dNr) then

        // Initialisieren der localen Variable.
        _memset(dest:=#TmpEntrie, usByte:=0, cntr:=sizeof(TmpEntrie));
        _memset(dest:=#TmpEntrie2, usByte:=0, cntr:=sizeof(TmpEntrie2));

        // ************************************************************************************************************************* 
        // ***************************           Überschrift ausgeben                      *****************************************
        // *************************************************************************************************************************
        if sExportData.dIndexAct = 0 then
        
          // --------------------------------------------------------------------------------------------------------------
          // Type ausgeben.
          // --------------------------------------------------------------------------------------------------------------
          OneLine[0] :=0;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Typ, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);

          
          // --------------------------------------------------------------------------------------------------------------
          // Commando ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Command, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // Timestamp ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeStamp, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // Länge ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Length, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // SourceID ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_SourceID, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // DestinationID ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_DestinationID, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
        
          // --------------------------------------------------------------------------------------------------------------
          // Priorität ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Prio, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
        
          // --------------------------------------------------------------------------------------------------------------
          // JobID ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_JobID, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
        
          // --------------------------------------------------------------------------------------------------------------
          // Timeout ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeOut, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // Objekt namen - Thispointer ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_This, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // Callback ausgeben
          // --------------------------------------------------------------------------------------------------------------
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Callback, pEntrie:=NIL, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddCRLFToLine(pLine:=#OneLine[0]);

          sExportData.udLength := lse.Str_Size(pt1:=#OneLine[0], size1:=sizeof(_ASCII));
          sExportData.dAsyncID := coFileSys.FileWrite_AV1(Async:=1, handle:=sExportData.dFileHandle, buffer:=#OneLine[0], sExportData.udLength);
          sExportData.eExportSteps := Export_WaitForWrite;
          
        
        // ************************************************************************************************************************* 
        // ***************************           Buffereinträge ausgeben                   *****************************************
        // *************************************************************************************************************************
        else
          
          // Eintrag aus Buffer holen. ( Eintrag 0 ist der neuste Eingrag. )
          coTCPCommunication.RamRingBuffer.GetRecord(pdst:=#TmpEntrie, pos:=to_udint(sExportData.dNr-sExportData.dIndexAct));
          
          // Soll die Zeit relative ausgegeben werden , wird der Eintrag davor benötigt.
          if TimeStampRelative = TRUE then
            coTCPCommunication.RamRingBuffer.GetRecord(pdst:=#TmpEntrie2, pos:=to_udint(sExportData.dNr-sExportData.dIndexAct-1));
          end_if;
          
          // --------------------------------------------------------------------------------------------------------------
          // Type ausgeben.
          // --------------------------------------------------------------------------------------------------------------

          OneLine[0] :=0;
          MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Typ, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
          AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
          AddTabToLine(pLine:=#OneLine[0]);
          
          // --------------------------------------------------------------------------------------------------------------
          // Statusmeldungen ausgeben.
          // --------------------------------------------------------------------------------------------------------------
          if TmpEntrie.TCPType = 2 then
          
            // Room anpassen an restliche Zeile
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_State, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddCRLFToLine(pLine:=#OneLine[0]);
            
          else
          
            // --------------------------------------------------------------------------------------------------------------
            // Commando ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Command, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // TimeStamp ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeStamp, pEntrie:=#TmpEntrie, pEntrie2:=#TmpEntrie2);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // Länge ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Length, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // SourceID ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_SourceID, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // DestinationID ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_DestinationID, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // Priorität ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Prio, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // JobID ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_JobID, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // Timeout ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_TimeOut, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // Objekt Namen ausgeben sonst Thispointer
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_This, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            
            // --------------------------------------------------------------------------------------------------------------
            // Callback ausgeben
            // --------------------------------------------------------------------------------------------------------------
            MakeLineTxt(ptxt:=#txt[0], txtType:=TextType_Callback, pEntrie:=#TmpEntrie, pEntrie2:=NIL);
            AddTxtToLine(pLine:=#OneLine[0], pTxt:=#txt[0]);
            AddTabToLine(pLine:=#OneLine[0]);
            AddCRLFToLine(pLine:=#OneLine[0]);
            
          end_if;
          
          // Länge der Zeile ermitteln.
          sExportData.udLength := lse.Str_Size(pt1:=#OneLine[0], size1:=sizeof(_ASCII));
          // Zeile Asynchron ins File schreiben.
          sExportData.dAsyncID := coFileSys.FileWrite_AV1(Async:=1, handle:=sExportData.dFileHandle, buffer:=#OneLine[0], sExportData.udLength);
          sExportData.eExportSteps := Export_WaitForWrite;
  
        end_if;

        
      else
        sExportData.eExportSteps:= Export_CloseFile;
      end_if;
      
    Export_WaitForWrite:
      // Warten bis Aktion beendet ist.
      if coFileSys.GetAsyncState(ID:=sExportData.dAsyncID$udint, Erg:=#sExportData.dAsyncResult) = 0 then
        // Prüfen ob alles geschrieben wurde.
        if sExportData.dAsyncResult = sExportData.udLength$dint then
          // Index für nächste Zeile erhöhen
          sExportData.dIndexAct +=1;
          sExportData.eExportSteps := Export_Line;
        else
          ExportToUSB := ExportState_Error;
        end_if;
      end_if;
      
    Export_CloseFile:
      // File Asynchron wieder schließen.
      sExportData.dAsyncID := coFileSys.FileClose_A(Async:=1, handle:=sExportData.dFileHandle);
      sExportData.eExportSteps := Export_WaitCloseFile;
  
    Export_WaitCloseFile:
      // warten bis Aktion abgeschlossen ist.
      if coFileSys.GetAsyncState(ID:=sExportData.dAsyncID$udint, Erg:=#sExportData.dAsyncResult) = 0 then
        // Visu mitteilen das Export abgeschlossen ist.
        ExportToUSB :=ExportState_Ready;
        // Rücksetzen des Schrittschaltwerks.
        sExportData.eExportSteps:= Export_CheckEntries ;
        // Zeit für die Berechnung der Dauer merken.
        sExportData.udTimeStampStopExport := ops.tAbsolute;
      end_if;
    
  
  END_CASE;


  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL TCPCommunicationLogViewer::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  if pe^.ftype = _EVENT_HIDPRESS then
    // Wird ein Event registriert , so wird wird wieder auf die Ansicht der Einträge umgeschaltet.
    if (ExportToUSB = ExportState_WaitTouch) | (ExportToUSB = ExportState_WaitTouch2 )then
      // Rücksetzen der Statusvariable.
      ExportToUSB :=ExportState_NoAction;
      // Rücksetzen des Schrittschaltwerkes
      sExportData.eExportSteps := Export_CheckEntries;
      // Ausgabe aktualisieren.
      LetsDraw :=TRUE;
      // Kernel mitteilen , das er nichts mit dem Event machen soll.
      retcode := _IDIDIT;
    else
      // Kernel soll sich um das Event kümmern.
      retcode := _ScrollArea2::GetEvent(ped, pe);
    end_if;
  else
    // Kernel soll sich um das Event kümmern.
    retcode := _ScrollArea2::GetEvent(ped, pe);
  end_if;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL TCPCommunicationLogViewer::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  // es soll exportiert werden.
  if ExportToUSB = ExportState_Start then
    // Es kann nur exportiert werden , wenn gerade nicht mitgelogged wird.
    if coTCPCommunication.LogEnable = 0 then
      // Export Vorgang durchlaufen.
      ExportToUSB_A();
      // Refresh für ScrollArea erzeugen , damit der Status aktualisiert wird.
      if (ops.tAbsolute - sExportData.udTimeStampRefresh) > 100 then
        // Zeitmerker aktualisieren.
        sExportData.udTimeStampRefresh := ops.tAbsolute;
        // Refresh auslösen.
        LetsDraw :=TRUE;
      end_if;
    end_if;
  // Export fertig. Status in der ScrollArea aktualisieren.  
  elsif ExportToUSB = ExportState_Ready then
    // Refresh auslösen.
    LetsDraw :=TRUE;
    // Status auf warten auf Touch eingabe setzen.
    ExportToUSB :=ExportState_WaitTouch;
  elsif ExportToUSB = ExportState_Error then
    // Refresh auslösen.
    LetsDraw :=TRUE;
    // Status auf warten auf Touch eingabe setzen.
    ExportToUSB :=ExportState_WaitTouch2;
  end_if;

	state := READY;

END_FUNCTION


FUNCTION TCPCommunicationLogViewer::CreateDPNE
	VAR_INPUT
		pChar 	: ^CHAR;
	END_VAR
  VAR
  	locDate : hdint;
    locTime : hdint;
    ConvDate : _DATE;
    ConvTime : _TIME;
    FileName : array [0..99] of char;
    Numtxt : array [0..9] of char;
  END_VAR

  // Pfad kopieren.
  _strcpy(dest:=pChar, src:=TCPCommLogViewer_ExportPath);
  // Backslash einfügen
  _strcat(dest:=pChar, src:="\");
  
  SysDate := SysDate.Read();
  SysTime := SysTime.Read();
  
  // Zeit und Datum einlesen.
  locDate := SysDate;
  locTime := SysTime;
  
  // Zeit und Datum von HEX auf Type wandeln.
  lasal_to_DATE(p0:=#ConvDate, x1:=locDate$dint);
  lasal_to_TIME(p0:=#ConvTime, x1:=locTime$dint);
  
  // Datum erzeugen.
  // Tag convertiern und einfügen.
  lse.Str_DToA(pt:=#Numtxt[0], value:= ConvDate.day , format:=16#102, chr_size:=sizeof(_ASCII));
  _strcpy(dest:=#FileName[0], src:=#Numtxt[0]);
  // Monat convertiern und einfügen.
  lse.Str_DToA(pt:=#Numtxt[0], value:= ConvDate.month , format:=16#102, chr_size:=sizeof(_ASCII));
  _strcat(dest:=#FileName[0], src:=#Numtxt[0]);
  // Jahr convertiern und einfügen.
  lse.Str_DToA(pt:=#Numtxt[0], value:= ConvDate.year , format:=16#104, chr_size:=sizeof(_ASCII));
  _strcat(dest:=#FileName[0], src:=#Numtxt[0]);
  // Trennung von Datum und Uhrzeit einfügen.
  _strcat(dest:=#FileName[0], src:="-");
  
  // Zeit erzeugen
  // Stunden convertiern und einfügen.
  lse.Str_DToA(pt:=#Numtxt[0], value:= ConvTime.hour , format:=16#102, chr_size:=sizeof(_ASCII));
  _strcat(dest:=#FileName[0], src:=#Numtxt[0]);
  // Minuten convertiern und einfügen.
  lse.Str_DToA(pt:=#Numtxt[0], value:= ConvTime.minute , format:=16#102, chr_size:=sizeof(_ASCII));
  _strcat(dest:=#FileName[0], src:=#Numtxt[0]);
  // Seckunden convertiern und einfügen.
  lse.Str_DToA(pt:=#Numtxt[0], value:= ConvTime.second , format:=16#102, chr_size:=sizeof(_ASCII));
  _strcat(dest:=#FileName[0], src:=#Numtxt[0]);
  
  // String auf Ziel umkopieren.
  _strcat(dest:=pChar, src:=#FileName[0]);
  
  // Dateiendung anhängen.
  _strcat(dest:=pChar, src:=TCPCommLogViewer_ExportExtension);

END_FUNCTION
