//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_SyncTimeHMI"
	Revision           = "2.0"
	GUID               = "{861E4EDF-4F06-4F3E-8390-CB2ECE4E815E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,180)"
	Comment            = "class reads date and time from two clients (within the adjusted zycletime)&#13;&#10;and writes these values to the servers">
	<Channels>
		<Server Name="sSyncDate" GUID="{3D757C3C-6FDA-4992-BF44-5E487B23E66E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server for sync date - also input is possible"/>
		<Server Name="sSyncTime" GUID="{1369DF3B-1062-4103-A355-B85C08AAC6B1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="server for sync time - also input is possible"/>
		<Client Name="ActDate" Required="true" Internal="false" Comment="actual date"/>
		<Client Name="ActTime" Required="true" Internal="false" Comment="actual time"/>
		<Client Name="SetDate" Required="false" Internal="false" Comment="destination date (e.g. for Machine Control)"/>
		<Client Name="SetTime" Required="false" Internal="false" Comment="destination time (e.g. for Machine Control)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_SyncTimeHMI\_SyncTimeHMI_de.pdf"/>
			<File Path=".\Class\_SyncTimeHMI\_SyncTimeHMI_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="2.0" Date="2018-02-07" Author="KaiAnd" Company="Sigmatek" Description="Implemented functionality to take over date &amp; time of inputs on server vars&#13;&#10;--&gt; server for date &amp; time now have write() mwthods for inputs&#13;&#10;--&gt; new destination clients SetDate and SetTime (optional)"/>
		<Dokumentation Revision="1.1" Date="2016-10-10" Author="HubChr" Company="Sigmatek" Description="Added documentation pdfs."/>
		<Dokumentation Revision="1.0" Date="2015-11-11" Author="hötant" Company="Sigmatek" Description="creation of class"/>
	</RevDoku>
</Class>
*)
_SyncTimeHMI : CLASS
  //Servers:
	sSyncDate 	: SvrChCmd_DATE_LSL;
	sSyncTime 	: SvrCh_TIME_LSL;
  //Clients:
	ActDate 	: CltCh_HDINT;
	ActTime 	: CltCh_HDINT;
	SetDate 	: CltCh_HDINT;
	SetTime 	: CltCh_HDINT;
  //Variables:
		IsCon_SetDate 	: DINT;			//! <Variable Comment="&quot;Is Connected&quot; flag ..." Name="IsCon_SetDate"/>
		IsCon_SetTime 	: DINT;			//! <Variable Comment="&quot;Is Connected&quot; flag ..." Name="IsCon_SetTime"/>
		TimeStampSync 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sSyncDate::Read
		VAR_OUTPUT
			output (EAX) 	: DATE_LSL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sSyncDate::Write
		VAR_INPUT
			input (EAX) 	: DATE_LSL;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DATE_LSL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sSyncTime::Read
		VAR_OUTPUT
			output (EAX) 	: TIME_LSL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL sSyncTime::Write
		VAR_INPUT
			input (EAX) 	: TIME_LSL;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: TIME_LSL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _SyncTimeHMI::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__SYNCTIMEHMI
2$UINT, 0$UINT, (SIZEOF(::_SyncTimeHMI))$UINT, 
2$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3877617373), "_SyncTimeHMI", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_SyncTimeHMI.sSyncDate.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1467776267), "sSyncDate", 
(::_SyncTimeHMI.sSyncTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2457260596), "sSyncTime", 
//Clients:
(::_SyncTimeHMI.ActDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2248193448), "ActDate", 
(::_SyncTimeHMI.ActTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1124735639), "ActTime", 
(::_SyncTimeHMI.SetDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2685983570), "SetDate", 
(::_SyncTimeHMI.SetTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1695708269), "SetTime", 
END_FUNCTION


#define USER_CNT__SyncTimeHMI 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__SyncTimeHMI] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _SyncTimeHMI::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__SyncTimeHMI, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Write		:= #Write();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	sSyncDate.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF sSyncDate.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sSyncTime.pMeth			:= StoreMethod( #sSyncTime::Read(), #sSyncTime::Write() );
	IF sSyncTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _SyncTimeHMI::Init

  if (_FirstScan) then

    //-------------------------------------------------------------------------
    //  check client-connnections and set flags                         V.2.0
    //-------------------------------------------------------------------------
    IsCon_SetDate := FALSE;
    IsCon_SetTime := FALSE;
    if (IsClientConnected(#SetDate)) then   IsCon_SetDate := TRUE; end_if;
    if (IsClientConnected(#SetTime)) then   IsCon_SetTime := TRUE; end_if;
    //-------------------------------------------------------------------------

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SyncTimeHMI::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	state := READY;

  //---------------------------------------------------------------------------
  //  TimeSync without inputs on sSync-servers ... V.2.0
  //---------------------------------------------------------------------------
  ActDate := ActDate.Read();
  ActTime := ActTime.Read();

  if ((ops.tAbsolute - TimeStampSync) >= 20000) then
    TimeStampSync := ops.tAbsolute;

    if (IsCon_SetDate = TRUE) then
      SetDate := ActDate ;
      SetDate.Write(ActDate);
    end_if;

    if (IsCon_SetTime = TRUE) then
      SetTime := ActTime ;
      SetTime.Write(ActTime);
    end_if;

  end_if;  
  //---------------------------------------------------------------------------

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SyncTimeHMI::sSyncDate::Read
	VAR_OUTPUT
		output (EAX) 	: DATE_LSL;
	END_VAR

 output := sSyncDate := ActDate := ActDate.Read();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SyncTimeHMI::sSyncTime::Read
	VAR_OUTPUT
		output (EAX) 	: TIME_LSL;
	END_VAR

	output := sSyncTime := ActTime := ActTime.Read();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SyncTimeHMI::sSyncDate::Write
	VAR_INPUT
		input (EAX) 	: DATE_LSL;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DATE_LSL;
	END_VAR

	sSyncDate := input;
	result := sSyncDate;


  // write input date to destination
  ActDate := sSyncDate ;
  ActDate.Write(sSyncDate);

  if (IsCon_SetDate = TRUE) then
    SetDate := sSyncDate ;
    SetDate.Write(sSyncDate);
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _SyncTimeHMI::sSyncTime::Write
	VAR_INPUT
		input (EAX) 	: TIME_LSL;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: TIME_LSL;
	END_VAR

	sSyncTime := input;
	result := sSyncTime;

  // write input time to destination
  ActTime := sSyncTime ;
  ActTime.Write(sSyncTime);

  if (IsCon_SetTime = TRUE) then
    SetTime := sSyncTime ;
    SetTime.Write(sSyncTime);
  end_if;

END_FUNCTION

