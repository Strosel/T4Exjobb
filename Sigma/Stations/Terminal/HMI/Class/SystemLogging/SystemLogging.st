//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
//texts for indicating type of loginformation
#define LOG_TYPE_ERROR    ("ERROR:")
#define LOG_TYPE_WARNING  ("WARNING:")
#define LOG_TYPE_DEBUG    ("DEBUG:")
#define LOG_TYPE_INFO     ("INFO:")
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SystemLogging"
	Revision           = "1.5"
	GUID               = "{1C76D14C-2FF2-49B0-A195-51D42B5A2F0E}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,420)"
	Comment            = "class used for logging events with two &#13;&#10;optional paramaters,loglevel,extended &#13;&#10;logging and trace message">
	<Channels>
		<Server
			Name           = "ClassSvr"
			GUID           = "{0790C810-03F7-4896-8B8E-462E3AEEF679}"
			Visualized     = "false"
			Initialize     = "false"
			WriteProtected = "true"
			Retentive      = "false"
			Comment        = "--&gt; counts the simple log-messages &#13;&#10;--&gt; works as command channel for new entries">
			<NewInst>
				<Function Name="CMD_LogEventText">
					<InputParameter>
						<Parameter Name="aPara0"/>
					</InputParameter>
					<OutputParameter>
						<Parameter Name="ret_code"/>
					</OutputParameter>
				</Function>
			</NewInst>
		</Server>
		<Server Name="DebugCnt" GUID="{761F26BF-6F0B-48CF-BAF7-E72478326DAD}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="counts the LOG_TYPE_DEBUG message"/>
		<Server Name="ErrorCnt" GUID="{3A0CB576-5F2E-43DF-8C63-B34FFE12CB27}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="counts the LOG_TYPE_ERROR messages"/>
		<Server Name="ExtLoggingActive" GUID="{E458EE41-51F9-468A-9AF2-9A7CDE56DEDC}" Visualized="true" Initialize="true" DefValue="TRUE" WriteProtected="false" Retentive="SRam" Comment="TRUE = extended logging activated"/>
		<Server Name="InfoCnt" GUID="{0856D59F-18B4-4985-BEE4-E0E2B1613E72}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="counts the LOG_TYPE_INFO messages"/>
		<Server Name="WarningCnt" GUID="{1B4B9142-19DF-472A-8E60-2CE51E0ACD54}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="counts the LOG_TYPE_WARNING messages&#13;&#10;"/>
		<Client Name="ActivateTrace" Required="true" Internal="false" DefValue="1" Comment="1 = activate LASAL Debugger Tracing"/>
		<Client Name="toSysMsg" Required="false" Internal="false" Comment="object channel to sysmsg-class for using print functions for logging events"/>
	</Channels>
	<RevDoku>
		<Owner Company="sigmatek" Author="BraLis"/>
		<Dokumentation Revision="1.5" Date="2016-10-04" Author="KaiAnd" Company="sigmatek" Description="implemented LogEventText() via command channel (NewInst)"/>
		<Dokumentation Revision="1.4" Date="2016-04-27" Author="KaiAnd" Company="sigmatek" Description="-- comments for all servers, clients and methods implemented (to become a LIB)"/>
		<Dokumentation Revision="1.3" Date="2015-12-02" Author="HoeAnt" Company="sigmatek" Description="added new Methode LogEvent (use the correct ULPrintFln Methods depending the amount of additional parameters)"/>
		<Dokumentation Revision="1.2&#13;&#10;" Date="2015-09-29" Author="BraLis" Company="sigmatek" Description="this class is instead of the TRACE-Messages&#13;&#10;insert 3 methods; one with just a text, one with a text and one parameter and one with a text and two parameters&#13;&#10;"/>
		<Dokumentation Revision="1.1&#13;&#10;" Date="2015-09-25" Author="BraLis" Company="sigmatek" Description="Rename the class&#13;&#10;&#13;&#10;"/>
		<Dokumentation Revision="1.0&#13;&#10;" Date="2014-09-24" Company="sigmatek"/>
	</RevDoku>
</Class>
*)
SystemLogging : CLASS
	TYPE
	  CmdClassSvr :  //! <Type Public="true" Name="CmdClassSvr"/>
	  (
	    CMD_LogEventText
	  )$UINT;
	  LogInfo :  //! <Type Public="true" Comment="defines different loglevels" Name="LogInfo"/>
	  (
	    _NoInfo,
	    _Error,
	    _Warning,
	    _Debug,
	    _Info
	  )$USINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	ExtLoggingActive 	: SvrCh_DINT;
	ErrorCnt 	: SvrCh_UDINT;
	WarningCnt 	: SvrCh_UDINT;
	DebugCnt 	: SvrCh_UDINT;
	InfoCnt 	: SvrCh_UDINT;
  //Clients:
	toSysMsg 	: CltChCmd__SysMsg;
	ActivateTrace 	: CltCh_DINT;
  //Variables:
  //Functions:
				//! <Function Comment="logs events and displays trace message" Name="LogEventText"/>
	FUNCTION GLOBAL LogEventText
		VAR_INPUT
			pChar 	: ^CHAR;			//! <Variable Comment="pointer on 0-terminated string which has to be logged" Name="LogEventText.pChar"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="0 = no error / &lt;0 = error" Name="LogEventText.bSuccessful"/>
		END_VAR;
				//! <Function Comment="logs events with 1 optional DINT-parameter and displays trace message" Name="LogEventPara1"/>
	FUNCTION GLOBAL LogEventPara1
		VAR_INPUT
			pChar 	: ^CHAR;			//! <Variable Comment="pointer on 0-terminated string which has to be logged" Name="LogEventPara1.pChar"/>
			dPara1 	: DINT := 0;			//! <Variable Comment="parameter 1 to be logged" Name="LogEventPara1.dPara1"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="0 = no error / &lt;0 = error" Name="LogEventPara1.bSuccessful"/>
		END_VAR;
				//! <Function Comment="logs events with 2 optional DINT-parameters and displays trace message" Name="LogEventPara2"/>
	FUNCTION GLOBAL LogEventPara2
		VAR_INPUT
			pChar 	: ^CHAR;			//! <Variable Comment="pointer on 0-terminated string which has to be logged" Name="LogEventPara2.pChar"/>
			dPara1 	: DINT := 0;			//! <Variable Comment="parameter 1 to be logged" Name="LogEventPara2.dPara1"/>
			dPara2 	: DINT := 0;			//! <Variable Comment="parameter 2 to be logged" Name="LogEventPara2.dPara2"/>
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;			//! <Variable Comment="0 = no error / &lt;0 = error" Name="LogEventPara2.bSuccessful"/>
		END_VAR;
				//! <Function Comment="logs events with eventtype and displays trace message" Name="LogEvent"/>
	FUNCTION GLOBAL LogEvent
		VAR_INPUT
			pText 	: ^CHAR;			//! <Variable Comment="pointer on 0-terminated string which has to be logged" Name="LogEvent.pText"/>
			pPara1 	: ^DINT;			//! <Variable Comment="pointer to optional parameter 2" Name="LogEvent.pPara1"/>
			pPara2 	: ^DINT;			//! <Variable Comment="pointer to optional parameter 2" Name="LogEvent.pPara2"/>
			ExtendedLogging 	: BOOL;			//! <Variable Comment="FALSE = log message always / &#13;&#10;TRUE = only log message if server &quot;ExtLoggingActive&quot; is activated" Name="LogEvent.ExtendedLogging"/>
			LogInfo 	: LogInfo;			//! <Variable Comment="loglevel of specific message" Name="LogEvent.LogInfo"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 = no error / &lt;0 = error" Name="LogEvent.retcode"/>
		END_VAR;
	
	FUNCTION ClassSvr::CMD_LogEventText
		VAR_INPUT
			aPara0 	: DINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: IprStates;
		END_VAR;
				//! <Function Name="ClassSvr.NewInst" Hidden="true"/>
	FUNCTION VIRTUAL GLOBAL ClassSvr::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _SysMsg


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SystemLogging::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SYSTEMLOGGING
1$UINT, 5$UINT, (SIZEOF(::SystemLogging))$UINT, 
6$UINT, 2$UINT, 0$UINT, 
TO_UDINT(90452573), "SystemLogging", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SystemLogging.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::SystemLogging.ExtLoggingActive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3830491325), "ExtLoggingActive", 
(::SystemLogging.ErrorCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(987008716), "ErrorCnt", 
(::SystemLogging.WarningCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3421176171), "WarningCnt", 
(::SystemLogging.DebugCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(440796679), "DebugCnt", 
(::SystemLogging.InfoCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(491365813), "InfoCnt", 
//Clients:
(::SystemLogging.toSysMsg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1640010845), "toSysMsg", TO_UDINT(792524216), "_SysMsg", 0$UINT, 0$UINT, 
(::SystemLogging.ActivateTrace.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3993478552), "ActivateTrace", 
END_FUNCTION


#define USER_CNT_SystemLogging 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SystemLogging] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SystemLogging::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SystemLogging, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ExtLoggingActive.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ExtLoggingActive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//{{LSL_HIDDEN_FUNCTION
FUNCTION VIRTUAL GLOBAL SystemLogging::ClassSvr::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
	CASE pPara^.uiCmd$CmdClassSvr OF
		CMD_LogEventText:
			ret_code := CMD_LogEventText(pPara^.aPara[0]);
			pResult^.uiLng := 0 + sizeof(pResult^.uiLng);
	ELSE

	END_CASE;


END_FUNCTION
//}}LSL_HIDDEN_FUNCTION

FUNCTION GLOBAL SystemLogging::LogEventText
	VAR_INPUT
		pChar 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  
  // check input-paramter
  if (pChar = NIL) then
    bSuccessful := false;
    return;
  end_if;
  
  // check for option Trace-Message
  //-------------------------------------------------------------------
  if (ActivateTrace) then

    // set Trace-Message
    TRACE(pChar);
  
  end_if; 
  
  // entry in logfile with 0 parameter
  toSysMsg.ULPrintfln0(pMsg := pChar);  

  // count log-messages
  ClassSvr += 1;
  
  // set returncode
  bSuccessful := true;

END_FUNCTION


FUNCTION GLOBAL SystemLogging::LogEventPara1
	VAR_INPUT
		pChar 	: ^CHAR;
		dPara1 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  
  // check input-paramter
  if (pChar = NIL) then
    bSuccessful := false;
    return;
  end_if;
  
  // check for option Trace-Message
  //-------------------------------------------------------------------
  if (ActivateTrace) then

    // set Trace-Message
    TRACE(pChar);
  
  end_if;
    
  // entry in logfile with 1 parameter 
  toSysMsg.ULPrintfln1(pMsg := pChar, dParam1 := dPara1);
  
  // count log-messages
  ClassSvr += 1;
  
  // set returncode
  bSuccessful := true;

END_FUNCTION


FUNCTION GLOBAL SystemLogging::LogEventPara2
	VAR_INPUT
		pChar 	: ^CHAR;
		dPara1 	: DINT;(* := 0 *)
		dPara2 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR

  // check input-paramter
  if (pChar = NIL) then
    bSuccessful := false;
    return;
  end_if;
  

  // check for option Trace-Message
  //-------------------------------------------------------------------
  if (ActivateTrace) then

    // set Trace-Message
    TRACE(pChar);
  
  end_if;
    
  // entry in logfile with 2 parameter
  toSysMsg.ULPrintfln2(pMsg := pChar, dParam1 := dPara1, dParam2 := dPara2);
    
  // count log-messages
  ClassSvr += 1;
  
  // set returncode
  bSuccessful := true;
  
END_FUNCTION

FUNCTION GLOBAL SystemLogging::LogEvent
	VAR_INPUT
		pText 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		ExtendedLogging 	: BOOL;
		LogInfo 	: LogInfo;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR  
    tmpString : ARRAY [0..199] OF CHAR;
    tmpPara1 : DINT;
    tmpPara2 : DINT;
    optPara : USINT;
  END_VAR
  
  //initialize
  retcode := -1;
  optPara := 0;
  
  if (pText <> NIL) then

    //check if we are allowed to log AddEventfromPLC
    if ((ExtendedLogging = ExtLoggingActive) | ExtendedLogging = FALSE) then
      
      //reset memory
      _memset(#tmpString[0], 0, sizeof(tmpString));
      
      //******************************************************************
      //**  add AddEventfromPLC info
      //******************************************************************
      case LogInfo of
      
      _NoInfo:
        
      _Error:
      
        _strcpy(#tmpString[0], LOG_TYPE_ERROR);   
        ErrorCnt += 1;
      
      _Warning:
      
        _strcpy(#tmpString[0], LOG_TYPE_WARNING); 
        WarningCnt += 1;
      
      _Debug:
      
        _strcpy(#tmpString[0], LOG_TYPE_DEBUG);
        DebugCnt += 1;
      
      _Info:
      
        _strcpy(#tmpString[0], LOG_TYPE_INFO);
        InfoCnt += 1;
      
      end_case;
      
      //check if text is not too big
      if ( _strlen(pText) <= (sizeof(tmpString) - _strlen(#tmpString[0])) ) then
        
        //add eventtext to string
        _strcat(#tmpString[0], pText);
        
        // check for option Trace-Message
        //-------------------------------------------------------------------
        if (ActivateTrace) then

          // set Trace-Message
          TRACE(#tmpString[0]);
        
        end_if;
        

        if ((pPara1 <> NIL) & (pPara2 <> NIL)) then
        
          //check if there is space for parameters
          if ( _strlen("( %d, %d )") <= (sizeof(tmpString) - _strlen(#tmpString[0])) ) then
            _strcat(#tmpString[0], "( %d, %d )");
            tmpPara1 := pPara1^;
            tmpPara2 := pPara2^;  
            optPara := 3;
          end_if;

        elsif ((pPara1 <> NIL) | (pPara2 <> NIL)) then

          //check if there is space for parameters
          if ( _strlen("( %d )") <= (sizeof(tmpString) - _strlen(#tmpString[0])) ) then
            _strcat(#tmpString[0], "( %d )");
            if (pPara1 <> NIL) then
              tmpPara1 := pPara1^;
              optPara := 1;
            else
              tmpPara2 := pPara2^;
              optPara := 2;
            end_if;
          end_if;  
          
        end_if;
        
        //check if only one parameter is written into logfile
        if (optPara = 1) then
          retcode := toSysMsg.ULPrintfln1(pMsg:=#tmpString[0], dParam1:=tmpPara1); 
        elsif (optPara = 2) then
          retcode := toSysMsg.ULPrintfln1(pMsg:=#tmpString[0], dParam1:=tmpPara2); 
        elsif (optPara = 3) then
          retcode := toSysMsg.ULPrintfln2(pMsg:=#tmpString[0], dParam1:=tmpPara1, dParam2:=tmpPara2);         
        else
          retcode := toSysMsg.ULPrintfln0(pMsg:=#tmpString[0]);
        end_if;
        
      end_if;
      
    end_if;
  
  end_if;

END_FUNCTION


FUNCTION SystemLogging::CMD_LogEventText
	VAR_INPUT
		aPara0 	: DINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR

	ret_code := READY;

  //-------------------------------------------------------------------------------------------------------------
  // Command 01: LogEventText
  //   IN: pPara^.aPara[0] ... pointer to the text string
  //-------------------------------------------------------------------------------------------------------------
  if (aPara0 <> NIL) then

    LogEventText(pChar:=aPara0$^CHAR);

  end_if;
  //-------------------------------------------------------------------------------------------------------------

END_FUNCTION
