//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define USB_DATA_CMD                  16#10
#define USB_DataExchangeBase_Timeout  10ms
#define continue goto LABEL_continue
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_Usb.h"

(*!
<Class
	Name               = "USB_DataExchange"
	Revision           = "1.13"
	GUID               = "{149A4171-9004-41E5-BB80-6A454CB38E21}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\USB.ico"
	SharedCommandTable = "true"
	Objectsize         = "(476,120)">
	<Channels>
		<Server Name="State" GUID="{AAD64C7E-579C-4AF2-A2A8-C93E4578886B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Display class state&#13;&#10;0..Ok&#13;&#10;-2..USB not supported&#13;&#10;-3..out of memory"/>
		<Client Name="To_MultiTask" Required="false" Internal="false"/>
		<Client Name="To_StdLib" Required="false" Internal="false" Comment="automatically connected to StdLib"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_Usb.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="stewer"/>
		<Dokumentation Revision="1.13" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="1.12" Date="08.03.2016" Author="PieSte" Company="Sigmatek" Description="Add methode USB_InitDevicePipe to initialize specific pipes."/>
		<Dokumentation Revision="1.11" Date="26.08.2014" Author="PieSte" Company="Sigmatek" Description="Insert taskdelay in WaitEventMethode to allow call of other methods between while loop. This is needed for edge2 cpu."/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="ZoePat" Company="Sigmatek" Description="Corrected wrong for-loop index type"/>
		<Dokumentation Revision="1.7" Date="06.09.2012" Author="BleErn" Company="Sigmatek" Description="Made compatible with Salamander OS"/>
		<Dokumentation Revision="1.6" Date="18.10.2010" Author="BleErn" Company="Sigmatek" Description="fixed incorrect revision documentation"/>
		<Dokumentation Revision="1.4" Date="11.08.2008" Author="renste" Company="Sigmatek" Description="sometimes variant is not send correct -&gt; repeate it if an error occure"/>
	</RevDoku>
</Class>
*)
USB_DataExchange : CLASS
	TYPE
#pragma pack(push, 1)
	  t_Device : STRUCT
	    us_used : USINT;
	    p_CallbackIsoIn : pVoid;
	    p_CallbackIsoOut : pVoid;
	    p_CallbackAsyOut : pVoid;
	    p_CallbackAsyIn : pVoid;
	    p_This : pVoid;
	    p_PipeIsoIn : pVoid;
	    p_PipeIsoOut : pVoid;
	    p_PipeAsyIn : pVoid;
	    p_PipeAsyOut : pVoid;
	    p_BufIsoIn : ^USINT;
	    p_BufIsoOut : ^USINT;
	    p_BufAsyIn : ^USINT;
	    p_BufAsyOut : ^USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_OneDataSend : STRUCT
	    us_Command : USINT;
	    us_SubCommand : USINT;
	    us_Data1 : USINT;
	    us_Data2 : USINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	State 	: SvrChCmd_DINT;
  //Clients:
	To_StdLib 	: CltChCmd__StdLib;
	To_MultiTask 	: CltChCmd__MultiTask;
  //Variables:
		us_Firstscan 	: USINT;
		pUSB 	: PIUSBCONFIG;
		p_Device 	: PDEVDATA;
		p_Interface 	: PINTDATA;
		p_Configuration 	: PCONFDATA;
		p_PipeIsoIn 	: PPIPEDATA;
		p_PipeAsyIn 	: PPIPEDATA;
		p_PipeAsyOut 	: PPIPEDATA;
		p_DataOut 	: ^USINT;
		s_AsyncData 	: t_OneDataSend;
		sd_AsyOutReady 	: DINT;
		sd_AsyInReady 	: DINT;
		USBdevices : ARRAY [0..49] OF t_Device;

		sd_ResetCounter 	: DINT;
		sd_ResetErrorCode 	: DINT;
		p_DataOut_ISO 	: ^USINT;
		sd_LastError 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION GLOBAL USB_InitDevice
		VAR_INPUT
			ui_VendorID 	: UINT;
			ui_ProductID 	: UINT;
			ui_Variant 	: UINT;
			p_CallbackIsoIn 	: pVoid;
			p_CallbackAsyOut 	: pVoid;
			p_CallbackAsyIn 	: pVoid;
			p_this 	: pVoid;
			p_PipeIsoIn 	: ^pVoid;
			p_PipeAsyOut 	: ^pVoid;
			p_PipeAsyIn 	: ^pVoid;
			p_Index 	: ^USINT;
			p_Firmware 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL USB_InitDevicePipe
		VAR_INPUT
			ui_VendorID 	: UINT;
			ui_ProductID 	: UINT;
			ui_Variant 	: UINT;
			ui_VendorClass 	: UINT;
			ui_VendorSubClass 	: UINT;
			ui_VendorProtocol 	: UINT;
			ui_PipeMaxPacketSize 	: UINT := 64;
			p_CallbackIsoIn 	: pVoid := NIL;
			p_CallbackIsoOut 	: pVoid := NIL;
			p_CallbackAsyOut 	: pVoid := NIL;
			p_CallbackAsyIn 	: pVoid := NIL;
			p_this 	: pVoid;
			p_PipeIsoIn 	: ^pVoid := NIL;
			p_PipeIsoOut 	: ^pVoid := NIL;
			p_PipeAsyIn 	: ^pVoid := NIL;
			p_PipeAsyOut 	: ^pVoid := NIL;
			p_Index 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL USB_ReadEEPROM
		VAR_INPUT
			us_index 	: USINT;
			pus_buffer 	: ^USINT;
			p_OutReady 	: ^DINT;
			p_InReady 	: ^DINT;
			us_length 	: USINT := 255;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SendAsyncData
		VAR_INPUT
			us_index 	: USINT;
			us_command 	: USINT;
			pus_data 	: ^USINT;
			us_len 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL WaitEventTimeout
		VAR_INPUT
			pEvent 	: ^DINT;
			ud_Timeout 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ExecuteIO
		VAR_INPUT
			p_Pipe 	: pVoid;
			p_Data 	: ^USINT;
			us_Len 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION USB_Callback
		VAR_INPUT
			p_Pipe 	: PPIPEDATA;
			sd_ErrorCode 	: DINT;
			p_Data 	: pVoid;
			sd_DataLength 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ResetUSB
		VAR_INPUT
			p_pipe 	: ^void;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ExecuteIO_ISO
		VAR_INPUT
			p_Pipe 	: pVoid;
			p_Data 	: ^USINT;
			us_Len 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SendAsyncData_ISO
		VAR_INPUT
			us_index 	: USINT;
			us_command 	: USINT;
			pus_data 	: ^USINT;
			us_len 	: USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetDeviceCount
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL USB_ClearDevice
		VAR_INPUT
			us_index 	: USINT;
		END_VAR;
	
	FUNCTION GLOBAL USB_GetDevice
		VAR_INPUT
			us_Device 	: USINT;
		END_VAR
		VAR_OUTPUT
			us_online 	: UDINT;
		END_VAR;
				//! <Function Comment="Searches for a specific USB device. First found is returned!" Name="USB_FindDevice"/>
	FUNCTION GLOBAL USB_FindDevice
		VAR_INPUT
			ui_DeviceClass 	: UINT;			//! <Variable Comment="0..255 or 65535 for &quot;do not care&quot;" Name="USB_FindDevice.ui_DeviceClass"/>
			ui_SubClass 	: UINT;			//! <Variable Comment="0..255 or 65535 for &quot;do not care&quot;" Name="USB_FindDevice.ui_SubClass"/>
			ui_Protocol 	: UINT;			//! <Variable Comment="0..255 or 65535 for &quot;do not care&quot;" Name="USB_FindDevice.ui_Protocol"/>
			ui_StartIndex 	: UINT;			//! <Variable Comment="Starting index for search" Name="USB_FindDevice.ui_StartIndex"/>
			pui_VendorID 	: ^UINT;
			pui_ProductID 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL USB_FindDeviceByVendor
		VAR_INPUT
			ui_VendorID 	: UINT;
			ui_ProductID 	: UINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL USB_DetachDevice
		VAR_INPUT
			ui_VendorID 	: UINT;
			ui_ProductID 	: UINT;
			i_Interface 	: INT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB USB_DataExchange::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_USB_DATAEXCHANGE
1$UINT, 13$UINT, (SIZEOF(::USB_DataExchange))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1659734526), "USB_DataExchange", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::USB_DataExchange.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
//Clients:
(::USB_DataExchange.To_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2139173287), "To_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::USB_DataExchange.To_MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2145650779), "To_MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_USB_DataExchange 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_USB_DataExchange] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION USB_DataExchange::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_USB_DataExchange, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
(************************************************************************************
*
*	Class for USB communication
*	Created : Sigmatek / 2007
*	Changes :
*		
*************************************************************************************)

FUNCTION VIRTUAL GLOBAL USB_DataExchange::Init

  //first init
  if ( us_Firstscan = 0 ) then
    // Init erledigt!
    us_Firstscan := 1;   
    
    // test if interface already exist	
    if ( OS_CILGET( "USBCONFIG", #pUSB ) ) then
      State := -2;
      return;
    end_if;
    
    State := 0;

  end_if;
    
END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_InitDevice
	VAR_INPUT
		ui_VendorID 	: UINT;
		ui_ProductID 	: UINT;
		ui_Variant 	: UINT;
		p_CallbackIsoIn 	: pVoid;
		p_CallbackAsyOut 	: pVoid;
		p_CallbackAsyIn 	: pVoid;
		p_this 	: pVoid;
		p_PipeIsoIn 	: ^pVoid;
		p_PipeAsyOut 	: ^pVoid;
		p_PipeAsyIn 	: ^pVoid;
		p_Index 	: ^USINT;
		p_Firmware 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    sd_index    : DINT;
    sd_count    : DINT;
    sd_found    : DINT;
    p_DevDesc   : PDEVDESC; 
    us_cmd      : USINT;
    us_config   : USINT;
    ui_steps    : UINT;
    b_fm_ok     : BOOL;
  END_VAR
  
  // Mit Fehler vorbelegen
  sd_retval := -1; sd_found := 0;
  
  //look for class ok
  if ( State <> 0 ) then
    return;
  end_if;
  
  // Anzahl
  sd_count := USB_iUSBGetDevCount();
  
  // suche Gerät
  for sd_index := 0 to sd_count-1 do
  
    if( USBdevices[ sd_index ].us_used = 0 )then
    
      // Hole Zeiger
      p_Device := USB_iUSBGetDevDataByIndex( sd_index );
      // Fehler
      if p_Device = nil then 
        sd_retval := -1;
        continue;
      end_if;
      // Hole Deskriptor
      p_DevDesc := USB_iUSBGetDevDesc( p_Device );
      // Fehler
      if p_DevDesc = nil then 
        sd_retval := -1;
        continue;
      end_if;
      // richtiges Gerät?
      if p_DevDesc^.idVendor = ui_VendorID  &  p_DevDesc^.idProduct = ui_ProductID then        
        // suche Interface
        p_Interface := USB_iUSBFindInterface( p_Device, USB_VENDOR_SPECIFIC_CLASS, USB_VENDOR_SPECIFIC_SUBCLASS, USB_VENDOR_SPECIFIC_PROTOCOL, 0, #p_Configuration );
        // Fehler
        if p_Interface = nil | p_Configuration = nil then 
          sd_retval := -1;
          continue;
        end_if;
        
        // Iso In
        p_PipeIsoIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_INT, USB_PIPE_DIR_INPUT, #USB_Callback(), this );
        // Fehler
        if p_PipeIsoIn = nil then 
          sd_retval := -1;
          continue;
        end_if;
        
        //Reset Pipe
        sd_retval := ResetUSB( p_pipe := p_PipeIsoIn^ );
        
        if ( sd_retval <> 0 ) then
          sd_retval := -1;
          continue;
        end_if;
      
        // Asy Out
        p_PipeAsyOut^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_OUTPUT, #USB_Callback(), this );
        // Fehler
        if p_PipeAsyOut = nil then 
          sd_retval := -1;
          continue;
        end_if;
  
        //Reset Pipe
        sd_retval := ResetUSB( p_pipe := p_PipeAsyOut^ );
        
        if ( sd_retval <> 0 ) then
          sd_retval := -1;
          continue;
        end_if;
  
        // Asy In
        p_PipeAsyIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_INPUT, #USB_Callback(), this );
        // Fehler
        if p_PipeAsyIn = nil then 
          sd_retval := -1;
          continue;
        end_if;
  
        //Reset Pipe
        sd_retval := ResetUSB( p_pipe := p_PipeAsyIn^ );
        
        if ( sd_retval <> 0 ) then
          sd_retval := -1;
          continue;
        end_if;
  
        //reset counter because first we don't need
        sd_ResetCounter := 0;
  
        if( ui_Variant <> 65535 )then

          ui_steps := 3;
          sd_LastError := 16#7FFF_FFFF;

          //because sometimes first read don't work
          while ( sd_LastError <> 0 & ui_steps > 0 ) do      
            
            ui_steps -= 1;

            //-----------------------------------------------------------------------------------------------
            //look for right device in config data
            // set ready flag
            sd_AsyOutReady := 0;
            
            //config byte
            us_cmd := 16#F3;
            
            // Execute
            sd_retval := USB_iUSBExecuteIO( p_PipeAsyOut^, #us_cmd, 1 );
            
            // Fehler
            if sd_retval <> 0 then
              sd_retval := -1;
              continue;
            end_if;
          
            // warten auf ready flag
            if( WaitEventTimeout( #sd_AsyOutReady, USB_DataExchangeBase_Timeout ) )then
              sd_retval := -1;
              continue;
            end_if;
          
            // set ready flag
            sd_AsyInReady := 0;
            // Execute
            sd_retval := USB_iUSBExecuteIO( p_PipeAsyIn^, #us_config, 1 );
            // Fehler
            if sd_retval <> 0 then
              sd_retval := -1;
              continue;
            end_if;
          
            // warten aufready flag
            if( WaitEventTimeout( #sd_AsyInReady, USB_DataExchangeBase_Timeout ) )then
              sd_retval := -1;
              continue;
            end_if;
          end_while;
        end_if;
        
        ui_steps := 3;
        b_fm_ok := FALSE;
        
        //check firmware version
        while ( b_fm_ok = FALSE & ui_steps > 0 ) do      
          //-----------------------------------------------------------------------------------------------
          //get FW Version
          // set ready flag
          sd_AsyOutReady := 0;
          
          //config byte
          us_cmd := 16#F4;
          
          // Execute
          sd_retval := USB_iUSBExecuteIO( p_PipeAsyOut^, #us_cmd, 1 );
          
          // Fehler
          if sd_retval <> 0 then
            sd_retval := -1;
            continue;
          end_if;
        
          // warten aufready flag
          if( WaitEventTimeout( #sd_AsyOutReady, USB_DataExchangeBase_Timeout ) )then
            sd_retval := -1;
            
            if ui_steps > 0 then
              //reset command
              sd_ResetErrorCode := ResetUSB( p_pipe := p_PipeAsyOut^ );
              
              sd_AsyOutReady := 1;
              ui_steps -= 1;
            end_if;  
            continue;
          
          else
  
            // set ready flag
            sd_AsyInReady := 0;
            // Execute
            sd_retval := USB_iUSBExecuteIO( p_PipeAsyIn^, p_Firmware, 1 );
            // Fehler
            if sd_retval <> 0 then
              sd_retval := -1;
              continue;
            end_if;
          
            // warten aufready flag
            if( WaitEventTimeout( #sd_AsyInReady, USB_DataExchangeBase_Timeout ) )then
              sd_retval := -2;
      
              if ui_steps > 0 then
                //reset command
                sd_ResetErrorCode := ResetUSB( p_pipe := p_PipeAsyIn^ );
              
                sd_AsyInReady := 1;
                ui_steps -= 1;
              end_if;  
              continue;
            else
              b_fm_ok := TRUE;
            end_if;
          end_if;
        end_while;
      
        //look if it is right config
        if( ui_Variant <> 65535 )then
          if ( us_config = ui_Variant ) then
            // Iso In
            p_PipeIsoIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_INT, USB_PIPE_DIR_INPUT, p_CallbackIsoIn, p_this );
            // Fehler
            if p_PipeIsoIn = nil then 
              sd_retval := -1;
              continue;
            end_if;
          
            // Asy Out
            p_PipeAsyOut^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_OUTPUT, p_CallbackAsyOut, p_this );
            // Fehler
            if p_PipeAsyOut = nil then 
              sd_retval := -1;
              continue;
            end_if;
          
            // Asy In
            p_PipeAsyIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_INPUT, p_CallbackAsyIn, p_this );
            // Fehler
            if p_PipeAsyIn = nil then 
              sd_retval := -1;
              continue;
            end_if;
            sd_found := 1;
            USBdevices[ sd_index ].us_used          := 1;
            USBdevices[ sd_index ].p_CallbackIsoIn  := p_CallbackIsoIn;
            USBdevices[ sd_index ].p_CallbackAsyIn  := p_CallbackAsyIn;
            USBdevices[ sd_index ].p_CallbackAsyOut := p_CallbackAsyOut;
            USBdevices[ sd_index ].p_This           := p_this;
            USBdevices[ sd_index ].p_PipeIsoIn      := p_PipeIsoIn^;
            USBdevices[ sd_index ].p_PipeAsyIn      := p_PipeAsyIn^;
            USBdevices[ sd_index ].p_PipeAsyOut     := p_PipeAsyOut^;
            USBdevices[ sd_index ].p_BufIsoIn$^void := To_Stdlib.Malloc( 64 );
            USBdevices[ sd_index ].p_BufAsyIn$^void := To_Stdlib.Malloc( 64 );
            USBdevices[ sd_index ].p_BufAsyOut$^void := To_Stdlib.Malloc( 64 );
            if( ( USBdevices[ sd_index ].p_BufIsoIn = NIL ) | 
                ( USBdevices[ sd_index ].p_BufAsyIn = NIL ) |
                ( USBdevices[ sd_index ].p_BufAsyOut = NIL ) )then
              if( USBdevices[ sd_index ].p_BufIsoIn <> NIL )then
                To_Stdlib.Free( USBdevices[ sd_index ].p_BufIsoIn );
              end_if;
              if( USBdevices[ sd_index ].p_BufAsyIn <> NIL )then
                To_Stdlib.Free( USBdevices[ sd_index ].p_BufAsyIn );
              end_if;
              if( USBdevices[ sd_index ].p_BufAsyOut <> NIL )then
                To_Stdlib.Free( USBdevices[ sd_index ].p_BufAsyOut );
              end_if;
              USBdevices[ sd_index ].us_used := 0;
              sd_index := 0;
              sd_found := 0;
            end_if;
            p_Index^ := sd_index$usint;
            exit;
          else
            sd_found := 0;
          end_if;
        else
          // Iso In
          p_PipeIsoIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_INT, USB_PIPE_DIR_INPUT, p_CallbackIsoIn, p_this );
          // Fehler
          if p_PipeIsoIn = nil then 
            sd_retval := -1;
            continue;
          end_if;
        
          // Asy Out
          p_PipeAsyOut^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_OUTPUT, p_CallbackAsyOut, p_this );
          // Fehler
          if p_PipeAsyOut = nil then 
            sd_retval := -1;
            continue;
          end_if;
        
          // Asy In
          p_PipeAsyIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_INPUT, p_CallbackAsyIn, p_this );
          // Fehler
          if p_PipeAsyIn = nil then 
            sd_retval := -1;
            continue;
          end_if; 
          
          USBdevices[ sd_index ].us_used          := 1;
          USBdevices[ sd_index ].p_CallbackIsoIn  := p_CallbackIsoIn;
          USBdevices[ sd_index ].p_CallbackAsyIn  := p_CallbackAsyIn;
          USBdevices[ sd_index ].p_CallbackAsyOut := p_CallbackAsyOut;
          USBdevices[ sd_index ].p_This           := p_this;
          USBdevices[ sd_index ].p_PipeIsoIn      := p_PipeIsoIn^;
          USBdevices[ sd_index ].p_PipeAsyIn      := p_PipeAsyIn^;
          USBdevices[ sd_index ].p_PipeAsyOut     := p_PipeAsyOut^;
          USBdevices[ sd_index ].p_BufIsoIn$^void := To_Stdlib.Malloc( 64 );
          USBdevices[ sd_index ].p_BufAsyIn$^void := To_Stdlib.Malloc( 64 );
          USBdevices[ sd_index ].p_BufAsyOut$^void := To_Stdlib.Malloc( 64 );
          if( ( USBdevices[ sd_index ].p_BufIsoIn = NIL ) | 
              ( USBdevices[ sd_index ].p_BufAsyIn = NIL ) |
              ( USBdevices[ sd_index ].p_BufAsyOut = NIL ) )then
            if( USBdevices[ sd_index ].p_BufIsoIn <> NIL )then
              To_Stdlib.Free( USBdevices[ sd_index ].p_BufIsoIn );
            end_if;
            if( USBdevices[ sd_index ].p_BufAsyIn <> NIL )then
              To_Stdlib.Free( USBdevices[ sd_index ].p_BufAsyIn );
            end_if;
            if( USBdevices[ sd_index ].p_BufAsyOut <> NIL )then
              To_Stdlib.Free( USBdevices[ sd_index ].p_BufAsyOut );
            end_if;
            USBdevices[ sd_index ].us_used := 0;
            sd_index := 0;
            sd_found := 0;
          else
            p_Index^ := sd_index$usint;
            sd_found := 1;
          end_if;      
          exit;
        end_if;
      end_if;
    end_if;
    LABEL_continue:
  end_for;  

  if ( sd_found = 0 ) then
    sd_retval := -1;
    return;
  end_if;

  // alles OK
  sd_retval := 0;
  
END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_InitDevicePipe
	VAR_INPUT
		ui_VendorID 	: UINT;
		ui_ProductID 	: UINT;
		ui_Variant 	: UINT;
		ui_VendorClass 	: UINT;
		ui_VendorSubClass 	: UINT;
		ui_VendorProtocol 	: UINT;
		ui_PipeMaxPacketSize 	: UINT;(* := 64 *)
		p_CallbackIsoIn 	: pVoid;(* := NIL *)
		p_CallbackIsoOut 	: pVoid;(* := NIL *)
		p_CallbackAsyOut 	: pVoid;(* := NIL *)
		p_CallbackAsyIn 	: pVoid;(* := NIL *)
		p_this 	: pVoid;
		p_PipeIsoIn 	: ^pVoid;(* := NIL *)
		p_PipeIsoOut 	: ^pVoid;(* := NIL *)
		p_PipeAsyIn 	: ^pVoid;(* := NIL *)
		p_PipeAsyOut 	: ^pVoid;(* := NIL *)
		p_Index 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    sd_index    : DINT;
    sd_count    : DINT;
    sd_found    : DINT;
    p_DevDesc   : PDEVDESC; 
  END_VAR
  
  // Mit Fehler vorbelegen
  sd_retval := -1; sd_found := 0;
  
  //look for class ok
  if ( State <> 0 ) then
    return;
  end_if;
  
  // Anzahl
  sd_count := USB_iUSBGetDevCount();
  
  // suche Gerät
  for sd_index := 0 to sd_count-1 do  
    
      // Hole Zeiger
      p_Device := USB_iUSBGetDevDataByIndex( sd_index );
      // Fehler
      if p_Device = nil then 
        sd_retval := -1;
        continue;
      end_if;
      
      // Hole Deskriptor
      p_DevDesc := USB_iUSBGetDevDesc( p_Device );
      // Fehler
      if p_DevDesc = nil then 
        sd_retval := -1;
        continue;
      end_if;
      
      // richtiges Gerät?
      if p_DevDesc^.idVendor = ui_VendorID  &  p_DevDesc^.idProduct = ui_ProductID then        
        // suche Interface
        p_Interface := USB_iUSBFindInterface( p_Device, ui_VendorClass, ui_VendorSubClass, ui_VendorProtocol, 0, #p_Configuration );
        // Fehler
        if p_Interface = nil | p_Configuration = nil then 
          sd_retval := -1;
          continue;
        end_if;
        
        // Iso In
        //************************************************************************************************************************
        if p_CallbackIsoIn & p_PipeIsoIn then
          if p_PipeIsoIn^ = NIL then
            p_PipeIsoIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_INT, USB_PIPE_DIR_INPUT, p_CallbackIsoIn, p_this );
            // Fehler
            if p_PipeIsoIn = nil then 
              sd_retval := -1;
              continue;
            end_if;
            
            //Reset Pipe
            sd_retval := ResetUSB( p_pipe := p_PipeIsoIn^ );
            
            if ( sd_retval <> 0 ) then
              sd_retval := -1;
              continue;
            end_if; 
            //device pipe is ok
            sd_found := 1;
            p_Index^ := sd_index$usint;
            USBdevices[ sd_index ].us_used          := 1;
            USBdevices[ sd_index ].p_CallbackIsoIn  := p_CallbackIsoIn;
            USBdevices[ sd_index ].p_This           := p_this;
            USBdevices[ sd_index ].p_PipeIsoIn      := p_PipeIsoIn^;
  //          USBdevices[ sd_index ].p_BufIsoIn$^void := To_Stdlib.Malloc( ui_PipeMaxPacketSize );
          else          
            sd_retval := -10;
            continue;          
          end_if;
        else
          sd_retval := -10;
          continue;
        end_if;
      
        // Iso Out
        //************************************************************************************************************************
        if p_CallbackIsoOut & p_PipeIsoOut then 
          if p_PipeIsoOut^ = NIL then 
            p_PipeIsoOut^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_INT, USB_PIPE_DIR_OUTPUT, p_CallbackIsoOut, p_this );
            // Fehler
            if p_PipeIsoOut = nil then 
              sd_retval := -1;
              continue;
            end_if;
            
            //Reset Pipe
            sd_retval := ResetUSB( p_pipe := p_PipeIsoOut^ );
            
            if ( sd_retval <> 0 ) then
              sd_retval := -1;
              continue;
            end_if;
            //device pipe is ok
            sd_found := 1;
            p_Index^ := sd_index$usint;
            USBdevices[ sd_index ].us_used          := 1;
            USBdevices[ sd_index ].p_CallbackIsoOut  := p_CallbackIsoOut;
            USBdevices[ sd_index ].p_This           := p_this;
            USBdevices[ sd_index ].p_PipeIsoOut      := p_PipeIsoOut^;
  //          USBdevices[ sd_index ].p_BufIsoOut$^void := To_Stdlib.Malloc( ui_PipeMaxPacketSize );
          else
            sd_retval := -11;
            continue;
          end_if;
        else
          sd_retval := -11;
          continue;
        end_if;
        
        // Asy In
        //************************************************************************************************************************
        if p_CallbackAsyIn & p_PipeAsyIn then  
          if p_PipeAsyIn^ = NIL then 
            p_PipeAsyIn^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_INPUT, p_CallbackAsyIn, p_this );
            // Fehler
            if p_PipeAsyIn = nil then 
              sd_retval := -1;
              continue;
            end_if;
      
            //Reset Pipe
            sd_retval := ResetUSB( p_pipe := p_PipeAsyIn^ );
            
            if ( sd_retval <> 0 ) then
              sd_retval := -1;
              continue;
            end_if;
            //device pipe is ok
            sd_found := 1;
            p_Index^ := sd_index$usint;
            USBdevices[ sd_index ].us_used          := 1;
            USBdevices[ sd_index ].p_CallbackAsyIn  := p_CallbackAsyIn;
            USBdevices[ sd_index ].p_This           := p_this;
            USBdevices[ sd_index ].p_PipeAsyIn      := p_PipeAsyIn^;
  //          USBdevices[ sd_index ].p_BufAsyIn$^void := To_Stdlib.Malloc( ui_PipeMaxPacketSize );
          else
            sd_retval := -12;
            continue;
          end_if;
        else
          sd_retval := -12;
          continue;
        end_if;
    
        // Asy Out
        //************************************************************************************************************************
        if p_CallbackAsyOut & p_PipeAsyOut then
          if p_PipeAsyOut^ = NIL then   
            p_PipeAsyOut^ := USB_iUSBFindPipe( p_Device, p_Interface, USB_PIPE_TYPE_BULK, USB_PIPE_DIR_OUTPUT, p_CallbackAsyOut, p_this );
            // Fehler
            if p_PipeAsyOut = nil then 
              sd_retval := -1;
              continue;
            end_if;
      
            //Reset Pipe
            sd_retval := ResetUSB( p_pipe := p_PipeAsyOut^ );
            
            if ( sd_retval <> 0 ) then
              sd_retval := -1;
              continue;
            end_if;
            //device pipe is ok
            sd_found := 1;
            p_Index^ := sd_index$usint;
            USBdevices[ sd_index ].us_used          := 1;
            USBdevices[ sd_index ].p_CallbackAsyOut  := p_CallbackAsyOut;
            USBdevices[ sd_index ].p_This           := p_this;
            USBdevices[ sd_index ].p_PipeAsyOut      := p_PipeAsyOut^;
  //          USBdevices[ sd_index ].p_BufAsyOut$^void := To_Stdlib.Malloc( ui_PipeMaxPacketSize );
          else
            sd_retval := -13;
            continue;
          end_if;
        else
          sd_retval := -13;
          continue;
        end_if;
  
        //reset counter because first we don't need
        sd_ResetCounter := 0;
        
        p_Index^ := sd_index$usint;
        exit;
      end_if;
    LABEL_continue:
  end_for;  

  if ( sd_found = 0 ) then
    sd_retval := -1;
    return;
  end_if;

  // alles OK
  sd_retval := 0;
  
END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_ReadEEPROM
	VAR_INPUT
		us_index 	: USINT;
		pus_buffer 	: ^USINT;
		p_OutReady 	: ^DINT;
		p_InReady 	: ^DINT;
		us_length 	: USINT;  //#rb000
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  VAR
    // Kommando
    aus_Cmd : array [0..2] of usint;
    // Adresse
    us_Addr : uint;
    // Daten
    us_Data : usint;
    // Warten
    ui_Wait : uint;
  END_VAR;

  //look for class ok
  if ( State <> 0 ) then
    sd_retval := -1;
    return;
  end_if;

  if( us_index > 49 )then
    return;
  end_if;

  // Kommando Lese EEPROM
  aus_Cmd[ 0 ] := 0xF2;
  
  // Schleife über Adresse
  for us_Addr := 0 to us_length do  //#rb000
  
    // Adresse
    aus_Cmd[ 1 ] := us_Addr$USINT;

    // set ready flag
    sd_AsyOutReady := 0;
    p_OutReady^:= 0;
    // Execute
    sd_retval := USB_iUSBExecuteIO( USBdevices[ us_index ].p_PipeAsyOut, #aus_Cmd[ 0 ], 2 );
    // Fehler
    if sd_retval <> 0 then
      return;
    end_if;
  
    if( WaitEventTimeout( p_OutReady, USB_DataExchangeBase_Timeout ) )then     
      sd_retval := -1;
      return;
    end_if;
    
    // set ready flag
    sd_AsyInReady := 0;
    p_InReady^ := 0;
    // Execute
    sd_retval := USB_iUSBExecuteIO( USBdevices[ us_index ].p_PipeAsyIn, #us_Data, 1 );
    // Fehler
    if sd_retval <> 0 then
      return;
    end_if;

    if( WaitEventTimeout( p_InReady, USB_DataExchangeBase_Timeout ) )then
      sd_retval := -2;
      return;
    end_if;

    // sichern
    ( pus_buffer + us_Addr )^ := us_Data;


    // Delay
    for ui_Wait := 0 to 10000 do
    end_for;
  end_for;
  
  // alles OK
  sd_retval := 0;
END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::SendAsyncData
	VAR_INPUT
    us_index    : USINT;
		us_command 	: USINT;
		pus_data 	: ^USINT;
		us_len 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  //look for class ok
  if ( State <> 0 ) then
    sd_retval := -1;
    return;
  end_if;

  if( us_index > 49 )then
    return;
  end_if;

  if( USBdevices[ us_index ].p_BufAsyOut = NIL )then
    sd_retval := -1;
    return;
  end_if;

  USBdevices[ us_index ].p_BufAsyOut^ := us_command;
  To_Stdlib.Memcpy( USBdevices[ us_index ].p_BufAsyOut + 1, pus_data, us_len );
    
  sd_retval := USB_iUSBExecuteIO( USBdevices[ us_index ].p_PipeAsyOut, USBdevices[ us_index ].p_BufAsyOut, us_len + 1 );

END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::WaitEventTimeout
	VAR_INPUT
		pEvent 	: ^DINT;
		ud_Timeout 	: UDINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  var 
    ud_intime : udint;
  end_var
  
  // get the start time
  ud_intime := ops.tAbsolute;
  
  // no event to wait on --> ok
  if( pEvent = NIL )then
    sd_retval := 0;
    return;
  end_if;
  
  // event has already occured --> ok
  if( pEvent^ <> 0 )then
    sd_retval := 0;
    return;
  end_if;
  
  // no timeout given --> not ok
  if( ud_Timeout = 0 )then
    sd_retval := -1;
    return;
  end_if;
  
 // wait loop
  while( ( pEvent^ = 0 ) & ( ops.tAbsolute - ud_intime < ud_Timeout ) )do
    To_MultiTask.TASKDELAY(1); 
  end_while;
  
  // event occured --> ok
  if( pEvent^ )then
    sd_retval := 0;
    return;
  end_if;
  
  // timeout occured --> not ok
  sd_retval := -1;

END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::ExecuteIO
	VAR_INPUT
		p_Pipe 	: pVoid;
		p_Data 	: ^USINT;
		us_Len 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  
  //look for class ok
  if ( State <> 0 ) then
    sd_retval := -1;
    return;
  end_if;

  sd_retval := USB_iUSBExecuteIO( p_Pipe, p_Data, us_Len );

END_FUNCTION

#pragma warning (disable:073)
FUNCTION USB_DataExchange::USB_Callback
	VAR_INPUT
		p_Pipe 	: PPIPEDATA;
		sd_ErrorCode 	: DINT;
		p_Data 	: pVoid;
		sd_DataLength 	: DINT;
	END_VAR

  sd_AsyOutReady := 1;
  sd_AsyInReady := 1;  
  sd_LastError := sd_ErrorCode;
  
END_FUNCTION
#pragma warning (default:073)


FUNCTION GLOBAL USB_DataExchange::ResetUSB
	VAR_INPUT
		p_pipe 	: ^void;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  //look for class ok
  if ( State <> 0 ) then
    sd_retval := -1;
    return;
  end_if;

  if ( _RTOSVersion >= 16#1197 ) then
    sd_retval := USB_iUSBResetIO( p_pipe );
    sd_ResetCounter += 1;
  else
    sd_retval := 0;
  end_if;

END_FUNCTION

FUNCTION GLOBAL USB_DataExchange::ExecuteIO_ISO
	VAR_INPUT
		p_Pipe 	: pVoid;
		p_Data 	: ^USINT;
		us_Len 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  //look for class ok
  if ( State <> 0 ) then
    sd_retval := -1;
    return;
  end_if;

  if ( _RTOSVersion >= 16#1197 ) then
    sd_retval := USB_iUSBExecuteIO( p_Pipe, p_Data, us_Len or 16#8000_0000 );
  else
    sd_retval := USB_iUSBExecuteIO( p_Pipe, p_Data, us_Len );
  end_if;

END_FUNCTION

FUNCTION GLOBAL USB_DataExchange::SendAsyncData_ISO
	VAR_INPUT
    us_index    : USINT;
		us_command 	: USINT;
		pus_data 	: ^USINT;
		us_len 	: USINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR

  //look for class ok
  if ( State <> 0 ) then
    sd_retval := -1;
    return;
  end_if;

  if( us_index > 49 )then
    sd_retval := -1;
    return;
  end_if;
  
  USBdevices[ us_index ].p_BufAsyOut^ := us_command;
  To_Stdlib.Memcpy( USBdevices[ us_index ].p_BufAsyOut + 1, pus_data, us_len );
    
  if ( _RTOSVersion >= 16#1197 ) then
    sd_retval := USB_iUSBExecuteIO( USBdevices[ us_index ].p_PipeAsyOut, USBdevices[ us_index ].p_BufAsyOut, ( us_len + 1 ) or 16#8000_0000 );
  else
    sd_retval := USB_iUSBExecuteIO( USBdevices[ us_index ].p_PipeAsyOut, USBdevices[ us_index ].p_BufAsyOut, us_len + 1 );
  end_if;

END_FUNCTION



FUNCTION GLOBAL USB_DataExchange::USB_ClearDevice
	VAR_INPUT
		us_index 	: USINT;
	END_VAR
  
  //look for class ok
  if ( State <> 0 ) then
    return;
  end_if;

  if( us_index > 49 )then
    return;
  end_if;
  
  USBdevices[ us_index ].us_used := 0;  

END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_GetDevice
	VAR_INPUT
		us_Device 	: USINT;
	END_VAR
	VAR_OUTPUT
		us_online 	: UDINT;
	END_VAR

  if( USB_iUSBGetDevDataByIndex( us_Device ) )then
    us_online := 1;
  else
    us_online := 0;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_FindDevice
	VAR_INPUT
		ui_DeviceClass 	: UINT;
		ui_SubClass 	: UINT;
		ui_Protocol 	: UINT;
		ui_StartIndex 	: UINT;
		pui_VendorID 	: ^UINT;
		pui_ProductID 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		sd_retval 	: DINT;
	END_VAR
  var
    sd_count : dint;
    sd_index : dint;
    p_DevDesc: PDEVDESC; 
    sd_intindex : dint;
    sd_intcount : dint;
    p_IntDesc : PINTDESC;
    p_ConfDesc  : PCONFDESC;
    sd_confindex : usint;
  end_var
  
  // Mit Fehler vorbelegen
  sd_retval := -1;
  
  //look for class ok
  if ( State <> 0 ) then
    return;
  end_if;
  
  // Anzahl
  sd_count := USB_iUSBGetDevCount();
  
  if( ui_StartIndex >= sd_count$uint )then
    return;
  end_if;
  
  // suche Gerät
  for sd_index := to_dint( ui_StartIndex ) to sd_count-1 do
  
    // Hole Zeiger
    p_Device := USB_iUSBGetDevDataByIndex( sd_index );
    // Fehler
    if p_Device = nil then 
      continue;
    end_if;
    // Hole Deskriptor
    p_DevDesc := USB_iUSBGetDevDesc( p_Device );
    // Fehler
    if p_DevDesc = nil then 
      continue;
    end_if;
    
    // richtiges Gerät?
    if( ( ( p_DevDesc^.bDeviceClass = ui_DeviceClass$usint ) | ( ui_DeviceClass = 65535 ) ) &  
        ( ( p_DevDesc^.bDeviceSubClass = ui_SubClass$usint ) | ( ui_SubClass = 65535 ) ) &  
        ( ( p_DevDesc^.bDeviceProtocol = ui_Protocol$usint ) | ( ui_Protocol = 65535 ) ) )then
        
      sd_retval := sd_index;
      if( pui_VendorID <> NIL )then
        pui_VendorID^ := p_DevDesc^.idVendor;
      end_if;
      if( pui_ProductID <> NIL )then
        pui_ProductID^ := p_DevDesc^.idProduct;
      end_if;
      return;
    else
    
      for sd_confindex := 0 to p_DevDesc^.bNumConfigurations - 1 do
      
        p_ConfDesc := USB_iUSBGetConfDesc( p_Device, sd_confindex );
        sd_intcount := USB_iUSBGetInterfaceCount( p_ConfDesc );
        for sd_intindex := 0 to sd_intcount - 1 do
          p_IntDesc := USB_iUSBGetIntDesc( p_ConfDesc, sd_intindex );
          if( p_IntDesc <> NIL )then
            if( ( ( p_IntDesc^.bInterfaceClass = ui_DeviceClass$usint ) | ( ui_DeviceClass = 65535 ) ) &  
                ( ( p_IntDesc^.bInterfaceSubClass = ui_SubClass$usint ) | ( ui_SubClass = 65535 ) ) &  
                ( ( p_IntDesc^.bInterfaceProtocol = ui_Protocol$usint ) | ( ui_Protocol = 65535 ) ) )then
                
              sd_retval := sd_index;
              if( pui_VendorID <> NIL )then
                pui_VendorID^ := p_DevDesc^.idVendor;
              end_if;
              if( pui_ProductID <> NIL )then
                pui_ProductID^ := p_DevDesc^.idProduct;
              end_if;
              return;
            end_if;
          end_if;
        end_for;
      end_for; 
      
    end_if;
    LABEL_continue:
  end_for;
  
END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::GetDeviceCount
	VAR_OUTPUT
		ret0 	: DINT;
	END_VAR

  ret0 := USB_iUSBGetDevCount();

END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_DetachDevice
	VAR_INPUT
		ui_VendorID 	: UINT;
		ui_ProductID 	: UINT;
		i_Interface 	: INT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  
  if pUSB^.ulVersion >= 16#2003 then    
    ErrorCode := USB_iUSBDETACHDRIVER(ui_VendorID, ui_ProductID, i_Interface);
  else
    ErrorCode := -1; //not supported
  end_if;

END_FUNCTION


FUNCTION GLOBAL USB_DataExchange::USB_FindDeviceByVendor
	VAR_INPUT
		ui_VendorID 	: UINT;
		ui_ProductID 	: UINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR  
  VAR
    sd_index    : DINT;
    sd_count    : DINT;
    p_DevDesc   : PDEVDESC; 
  END_VAR
  
  // Mit Fehler vorbelegen  
  ErrorCode := -1;
  
  //look for class ok
  if ( State <> 0 ) then
    return;
  end_if;
  
  // Anzahl
  sd_count := USB_iUSBGetDevCount();
  
  // suche Gerät
  for sd_index := 0 to sd_count-1 do    
    // Hole Zeiger
    p_Device := USB_iUSBGetDevDataByIndex( sd_index );
    // Fehler
    if p_Device = nil then 
      exit;
    end_if;
    
    // Hole Deskriptor
    p_DevDesc := USB_iUSBGetDevDesc( p_Device );
    // Fehler
    if p_DevDesc = nil then 
      exit;
    end_if;
    
    // richtiges Gerät?
    if p_DevDesc^.idVendor = ui_VendorID  &  p_DevDesc^.idProduct = ui_ProductID then
      //device is found, all ok
      ErrorCode := sd_index;
      exit;
    end_if;
  end_for;
  

END_FUNCTION
