//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_Grafix"
	Revision           = "1.2"
	GUID               = "{73FE9201-61D5-11D6-8832-0048545E88BC}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "true"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "This graphic class is used to encapsulate various Lasal RTOS graphics functions. The functions provided by this class functions are typically used along with the LSE Graphics System, however, they can be used on their own without LSE to perform basic drawing operations. &#10;&#10;The class provides the ST_Graph.H and T_GRC.H header files to define the various types, symbol and structure definitions required by the class methods.">
	<Channels>
		<Server Name="Server0" GUID="{73FE9202-61D5-11D6-8832-0048545E88BC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\code\OsiBaseNew.st"/>
			<File Path=".\Source\code\OsiBaseNew.h" Include="false"/>
			<File Path=".\St_grconst.h" Include="false"/>
			<File Path=".\St_graph.h" Include="false"/>
		</Files>
	</Dependencies>
</Class>
*)
_Grafix : CLASS
	TYPE
	  OS_LSE : STRUCT
	    lActive : UDINT;
	    pIniFile : ^USINT;
	    lEnableTask : UDINT;
	    LSE_InstallTask : pVoid;
	    LSE_Close : pVoid;
	    LSE_Restart : pVoid;
	    StoreLST : pVoid;
	    LSE_Memmove : pVoid;
	    LSE_Memcpy : pVoid;
	    LSE_Memset : pVoid;
	    LSE_Memcmp : pVoid;
	    LSE_GetAbsTime : pVoid;
	    LSE_Fread : pVoid;
	    LSE_Fwrite : pVoid;
	    LSE_Fopen : pVoid;
	    LSE_fclose : pVoid;
	    LSE_Flseek : pVoid;
	    LSE_Ftell : pVoid;
	    LSE_filelength : pVoid;
	    LSE_CreateDir : pVoid;
	    LSE_FindFirst : pVoid;
	    LSE_FindNext : pVoid;
	    LSE_FindClose : pVoid;
	    GetSRAMInfo : pVoid;
	    GetPointerToSRAM : pVoid;
	    GetPointerToKeyboard : pVoid;
	    OS_SetTime : pVoid;
	    OS_GetTime : pVoid;
	    OS_Wait : pVoid;
	    GetAddressVar : pVoid;
	    GetAddressObj : pVoid;
	    RegisterVar : pVoid;
	    RegisterObj : pVoid;
	    COM_DeleteQueue : pVoid;
	    COM_Login : pVoid;
	    SYS_SetExternFunction : pVoid;
	    COM_SetData : pVoid;
	    COM_GetData : pVoid;
	    OS_MetaEvent : pVoid;
	    LSE_Main_pMain : pVoid;
	    IRQPLC_FUNCTION : pVoid;
	    CLOSE_FUNCTION : pVoid;
	    LSETimer : pVoid;
	    LSE_ScreenSaver : pVoid;
	    GetPalette : pVoid;
	    HideMouse : pVoid;
	    ShowMouse : pVoid;
	    IfNecHideMouse : pVoid;
	    IfNecShowMouse : pVoid;
	    SetFontAttribute : pVoid;
	    StrWidth : pVoid;
	    InitGraph : pVoid;
	    CloseGraph : pVoid;
	    GetScreenSize : pVoid;
	    Getpixel : pVoid;
	    PutPixel : pVoid;
	    Line : pVoid;
	    Polygon : pVoid;
	    Rectangle : pVoid;
	    Beam : pVoid;
	    OutTextXY : pVoid;
	    OutTextLen : pVoid;
	    Arc : pVoid;
	    Oval : pVoid;
	    Button : pVoid;
	    Scrool : pVoid;
	    Bitmap : pVoid;
	    ActivateFont : pVoid;
	    GetFontSize : pVoid;
	    FreeRegion : pVoid;
	    ActivateRegion : pVoid;
	    DeActivateRegion : pVoid;
	    StartRegion : pVoid;
	    AddRegion : pVoid;
	    EndRegion : pVoid;
	    SubRegion : pVoid;
	    AndRegion : pVoid;
	    XorRegion : pVoid;
	    OrRegion : pVoid;
	    GetActiveRegion : pVoid;
	    GetNoColors : pVoid;
	    GetImage : pVoid;
	    PutImage : pVoid;
	    GetRetrace : pVoid;
	    WaitForRetrace : pVoid;
	    IsGraphInit : pVoid;
	    Memory : pVoid;
	    OutXPixelPool : pVoid;
	    OutYPixelPool : pVoid;
	    OutPixelLine : pVoid;
	    RoomInRegion : pVoid;
	    MakeTrueColor : pVoid;
	    ShowCursor : pVoid;
	    MoveCursor : pVoid;
	    LimitMouse : pVoid;
	    StopMouse : pVoid;
	    StopEvent : pVoid;
	    StartEvent : pVoid;
	    StoreEvent : pVoid;
	    KeyEvent : pVoid;
	    InitMouse : pVoid;
	    ReadPixel : pVoid;
	    WritePixel : pVoid;
	    MakeColor : pVoid;
	    MouseCursorStyle : pVoid;
	    DestroyOffScreen : pVoid;
	    CreateOffScreen : pVoid;
	    GetScreen : pVoid;
	    SetScreen : pVoid;
	    CopyScreen : pVoid;
	    LCD_Contrast : pVoid;
	    LCD_Brightness : pVoid;
	    DrawTLBR : pVoid;
	    SetNewCalibration : pVoid;
	    SetTouchKoords : pVoid;
	    ChrWidth : pVoid;
	    SetGraphicSystem : pVoid;
	    OutChr : pVoid;
	    TxtWidth : pVoid;
	    RefreshRectangle_res : pVoid;
	    PenDashSet : pVoid;
	    PenDashDefine : pVoid;
	    RotateScreen : pVoid;
	    size : UDINT;
	    version : UDINT;
	    SetLed : pVoid;
	    GetPotiVal : pVoid;
	    GetDipswitchVal : pVoid;
	    OS_FindFirstEx : pVoid;
	    OS_FindNextEx : pVoid;
	    MemoryV1 : pVoid;
	    Dummy01 : pVoid;
	    Dummy02 : pVoid;
	    Dummy03 : pVoid;
	    Dummy04 : pVoid;
	    Dummy05 : pVoid;
	    Dummy06 : pVoid;
	    Dummy07 : pVoid;
	    Dummy08 : pVoid;
	    Dummy09 : pVoid;
	    Dummy10 : pVoid;
	    Dummy11 : pVoid;
	    Dummy12 : pVoid;
	    Dummy13 : pVoid;
	    Dummy14 : pVoid;
	    Dummy15 : pVoid;
	    Dummy16 : pVoid;
	    Dummy17 : pVoid;
	    Dummy18 : pVoid;
	    Dummy19 : pVoid;
	    Dummy20 : pVoid;
	    Dummy21 : pVoid;
	    Dummy22 : pVoid;
	    Dummy23 : pVoid;
	    Dummy24 : pVoid;
	    Dummy25 : pVoid;
	    Dummy26 : pVoid;
	    Dummy27 : pVoid;
	    Dummy28 : pVoid;
	    Dummy29 : pVoid;
	    Dummy30 : pVoid;
	    Dummy31 : pVoid;
	    Dummy32 : pVoid;
	    DefineMouseCursorStyle : pVoid;
	    pStoreEventEx : pVoid;
	    pKeyEventEx : pVoid;
	    Dummy36 : pVoid;
	    Dummy37 : pVoid;
	    Dummy38 : pVoid;
	    Dummy39 : pVoid;
	    Dummy40 : pVoid;
	    Dummy41 : pVoid;
	    Dummy42 : pVoid;
	    Dummy43 : pVoid;
	    Dummy44 : pVoid;
	    Dummy45 : pVoid;
	    Dummy46 : pVoid;
	    Dummy47 : pVoid;
	    Dummy48 : pVoid;
	    Dummy49 : pVoid;
	    Dummy50 : pVoid;
	    Dummy51 : pVoid;
	    Dummy52 : pVoid;
	    Dummy53 : pVoid;
	    Dummy54 : pVoid;
	    Dummy55 : pVoid;
	    Dummy56 : pVoid;
	    Dummy57 : pVoid;
	    Dummy58 : pVoid;
	    Dummy59 : pVoid;
	    Dummy60 : pVoid;
	    Dummy61 : pVoid;
	    Dummy62 : pVoid;
	    Dummy63 : pVoid;
	    Dummy64 : pVoid;
	    Dummy65 : pVoid;
	    Dummy66 : pVoid;
	    Dummy67 : pVoid;
	    Dummy68 : pVoid;
	    Dummy69 : pVoid;
	    Dummy70 : pVoid;
	    Dummy71 : pVoid;
	    Dummy72 : pVoid;
	    SetNewCalibrationEx : pVoid;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION _Grafix
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="This method is called to obtain the color value of the pixel at the specified coordinate (x0, y0)." Name="ReadPixel"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ReadPixel
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to set the color value, using the specified attribute, at the specified coordinate (x0, y0)." Name="WritePixel"/>
	FUNCTION __CDECL VIRTUAL GLOBAL WritePixel
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw a line from the starting coordinate (x1, y1) through the ending coordinate (x2, y2) (inclusive) using the specified color and attribute." Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw a polygon. The function will draw each segment according to the specified array of coordinates (dot). The polygon is drawn using the specified color and attribute. The number of vertices is passed in Inuint." Name="Polygon"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Polygon
		VAR_INPUT
			inuint 	: UINT;
			dot 	: ^_DOT;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw a framed rectangle at the specified coordinates (x1, y1, x2, y2) with the specified attribute and color." Name="Rectangle"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Rectangle
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw a filled rectangle at the specified coordinates." Name="Beam"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Beam
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to output a single character on a specified xy position." Name="OutChr"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OutChr
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			chr 	: UINT;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
			chr_size 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to draw and display a text line at the specified coordinates (x0, y0). Note that the string (textptr) must be a NULL terminated string and can be either ASC or Unicode (chr_size)." Name="OutTextXY"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OutTextXY
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			textptr 	: pVoid;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
			chr_size 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to display a text line at the specified coordinates. Note that the string does not have to be NULL terminated. The specified count is a count of CHARACTERS (and not memory bytes) to display. The string can be either ASC or Unicode." Name="OutTextLen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OutTextLen
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			textptr 	: pVoid;
			count 	: UINT;
			attirb 	: _ATTRIB;
			color 	: _COLOR;
			chr_size 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to draw an arc between two points (x0, y0) (x1, y1)." Name="Arc"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Arc
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			start 	: INT;			//! <Variable Comment="&apos;Start&apos; specify the starting angle." Name="Arc.start"/>
			bend 	: INT;			//! <Variable Comment="&apos;Bend&apos; specify the the bend angle." Name="Arc.bend"/>
			power 	: UINT;			//! <Variable Comment="&apos;Power&apos; specify the pen size." Name="Arc.power"/>
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw an oval at (x0, y0) (x1, y1) (bounding box)." Name="Oval"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Oval
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			start 	: INT;
			bend 	: INT;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw a 3D &apos;button&apos; at (x0, y0) (x1, y1). Use the T_INVERSE attribute to draw the button in the &apos;pressed&apos; position." Name="Button"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Button
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			attrib 	: _ATTRIB;
			color 	: _COLOR;			//! <Variable Comment="&apos;Color&apos; is interpreted likewise for the outer button color." Name="Button.color"/>
			frame 	: _COLOR;			//! <Variable Comment="&apos;Frame&apos; specifies the inner button color." Name="Button.frame"/>
		END_VAR;
				//! <Function Comment="This method is called to scroll an area (x0, y0) (x1, y1) of the screen. The area is scrolled by the specified distance (dx0, dy0). The direction of the scroll is based on the sign of the distance coordinates. The residual Pixels are filled with &apos;color&apos;." Name="Scroll"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Scroll
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
			dx0 	: _KOORD;
			dy0 	: _KOORD;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to draw a bitmap (image) to the screen at (x0, y0) using the background color (color)." Name="Bitmap"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Bitmap
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			image 	: ^_BMP;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to make a combined foreground/background color from two color codes. The code should be constructed using MakeTrueColor." Name="MakeColor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MakeColor
		VAR_INPUT
			backcolor 	: _COLOR;
			frontcolor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			retcolor (EAX) 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to make a true color value. The method is passed the R-G-B components of the color. The method will scale the values into the closest possible HiColor or 256-color value." Name="MakeTrueColor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MakeTrueColor
		VAR_INPUT
			_r 	: UINT;
			_g 	: UINT;
			_b 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcolor (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to activate the specified font." Name="ActivateFont"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ActivateFont
		VAR_INPUT
			font 	: ^_FONTPTR;
		END_VAR;
				//! <Function Comment="This method is called to obtain the width and height of the specified font. For proportional fonts the return values are the averages of the font." Name="GetFontSize"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetFontSize
		VAR_INPUT
			width 	: ^UINT;
			heigth 	: ^UINT;
			font 	: ^_FONTPTR;
		END_VAR;
				//! <Function Comment="This method is called to set the attribute of the current font." Name="SetFontAttribute"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetFontAttribute
		VAR_INPUT
			attrib 	: _ATTRIB;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL ChrWidth
		VAR_INPUT
			chr 	: UINT;
			chr_size 	: UINT;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to return the width of the specified text. The width of a text is the size of the string in memory. This depends on the passed chr_size parameter. Unicode strings require 2 bytes for each character. Note that this function is different than the length of the string, which always returns the number of characters in the string (regardless of the encoding format in use)." Name="TxtWidth"/>
	FUNCTION __CDECL VIRTUAL GLOBAL TxtWidth
		VAR_INPUT
			textptr 	: pVoid;
			length 	: UINT;
			chr_size 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to return the width of the specified string (textptr). The width of a string is the size of the string in memory. This depends on the passed chr_size parameter. Unicode strings require 2 bytes for each character. Note that this function is different than the length of the string, which always returns the number of characters in the string (regardless of the encoding format in use)." Name="StrWidth"/>
	FUNCTION __CDECL VIRTUAL GLOBAL StrWidth
		VAR_INPUT
			textptr 	: pVoid;
			chr_size 	: UINT;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to free the specified region." Name="FreeRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL FreeRegion
		VAR_INPUT
			region 	: ^_REGION;
		END_VAR;
				//! <Function Comment="This method is called to activate the specified region." Name="ActivateRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ActivateRegion
		VAR_INPUT
			region 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to deactivate the current region." Name="DeActivateRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL DeActivateRegion;
				//! <Function Comment="This method is called to start the creation of a new region." Name="StartRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL StartRegion;
				//! <Function Comment="This method is called to add an area (room) to the current region under creation." Name="AddRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AddRegion
		VAR_INPUT
			room 	: ^_ROOM;
		END_VAR;
				//! <Function Comment="This method is called to end the creation of a region. The region will now be completed." Name="EndRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL EndRegion
		VAR_OUTPUT
			retval (EAX) 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to subtract region2 from region1 and return the result region." Name="SubRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SubRegion
		VAR_INPUT
			region1 	: _REGION;
			region2 	: _REGION;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to and region2 from region1 and return the result region." Name="AndRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AndRegion
		VAR_INPUT
			region1 	: _REGION;
			region2 	: _REGION;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to XOR region1 with region2 and to return the resulting region." Name="XorRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL XorRegion
		VAR_INPUT
			region1 	: _REGION;
			region2 	: _REGION;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to OR region1 with region2 and to return the resulting region." Name="OrRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OrRegion
		VAR_INPUT
			region1 	: _REGION;
			region2 	: _REGION;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to return the active region." Name="GetActiveRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetActiveRegion
		VAR_OUTPUT
			retval (EAX) 	: _REGION;
		END_VAR;
				//! <Function Comment="This method is called to see if any portion of the specified room is within the specified region." Name="RoomInRegion"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RoomInRegion
		VAR_INPUT
			room 	: ^_ROOM;
			region 	: _REGION;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="The function returns 1 if the room lies within the region and 0 if it does not." Name="RoomInRegion.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to return the number of colors currently supported -1." Name="GetNoColors"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetNoColors
		VAR_OUTPUT
			retval (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="This method is called to read an area of the screen and save it in the specified image structure. The function will allocate the memory for the image and then read it into the image buffer." Name="GetImage"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetImage
		VAR_INPUT
			image 	: ^_IMAGE;
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="The function returns 0 if unable to allocate the memory or 1 if successful." Name="GetImage.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to restore an image to the screen at (x0, y0)." Name="PutImage"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PutImage
		VAR_INPUT
			image 	: ^_IMAGE;
			x0 	: _KOORD;
			y0 	: _KOORD;
		END_VAR;
				//! <Function Comment="This method is called to obtain the current retrace position." Name="GetRetrace"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetRetrace
		VAR_OUTPUT
			retval (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to wait for the retrace to reach the first raster." Name="WaitForRetrace"/>
	FUNCTION __CDECL VIRTUAL GLOBAL WaitForRetrace;
				//! <Function Comment="This method is called to display a Pixel Pool (y0) in X direction (x0). For each X position, from the starting coordinate, the Y position is obtained from the data pool array and used as the resulting pixel position. The pixel is set using the specified attribute and color. The function will display all pixels as specified in the count (no) parameter. The direction is given in &apos;dir&apos;." Name="OutXPixelPool"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OutXPixelPool
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: ^_KOORD;
			no 	: UINT;
			dir 	: UINT;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="This method is called to display a Pixel Pool (x0) in Y direction (y0). For each Y position, from the starting coordinate, the X position is obtained from the data pool array and used as the resulting pixel position. The pixel is set using the specified attribute and color. The function will display all pixels as specified in the count (no) parameter. The direction is given in &apos;dir&apos;." Name="OutYPixelPool"/>
	FUNCTION __CDECL VIRTUAL GLOBAL OutYPixelPool
		VAR_INPUT
			x0 	: ^_KOORD;
			y0 	: _KOORD;
			no 	: UINT;
			dir 	: UINT;
			attrib 	: _ATTRIB;
			color 	: _COLOR;
		END_VAR;
				//! <Function Comment="Initializes mouse input processing." Name="InitMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL InitMouse
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="Returns 0 for success, 1 for an already initialized process and -1 for an error." Name="InitMouse.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to set the mouse cursor style. " Name="MouseCursorStyle"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MouseCursorStyle
		VAR_INPUT
			style 	: UINT;			//! <Variable Comment="Four different styles are available: arrow (de-fault:0), hand (1), question mark (2) and the sandglass (3)." Name="MouseCursorStyle.style"/>
		END_VAR;
				//! <Function Comment="This method is called to show the graphics cursor. Note that the mouse cursor should be turned OFF while drawing." Name="ShowCursor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ShowCursor;
				//! <Function Comment="This method is called to move the graphics cursor to the specified coordinate." Name="MoveCursor"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MoveCursor
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
		END_VAR;
				//! <Function Comment="This method is called to limit the movement of the cursor to the specified screen area." Name="LimitMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LimitMouse
		VAR_INPUT
			x0 	: _KOORD;
			y0 	: _KOORD;
			x1 	: _KOORD;
			y1 	: _KOORD;
		END_VAR;
				//! <Function Comment="This method is called to stop mouse movements. Note that the mouse cursor should be turned OFF while drawing." Name="StopMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL StopMouse;
				//! <Function Comment="This method is called to turn off the display of the graphics mouse." Name="HideMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL HideMouse;
				//! <Function Comment="This method is called to turn on the display of the graphics mouse." Name="ShowMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL ShowMouse;
				//! <Function Comment="This method is called to turn off the display of the graphics mouse if the mouse pointer is within the specified room (room)." Name="IfNecHideMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IfNecHideMouse
		VAR_INPUT
			room 	: ^_ROOM;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="The return value is TRUE if the mouse is hidden." Name="IfNecHideMouse.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to turn on the display of the graphics mouse if the passed state (st0) is TRUE." Name="IfNecShowMouse"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IfNecShowMouse
		VAR_INPUT
			st0 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to stop event processing. No further events (keys, mouse, etc.) will be processed." Name="StopEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL StopEvent;
				//! <Function Comment="This method is called to start event processing. The method is passed a mask of the events to process." Name="StartEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL StartEvent
		VAR_INPUT
			eventmask 	: UINT;
		END_VAR;
				//! <Function Comment="Stores a programmed event into the event queue." Name="StoreEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL StoreEvent
		VAR_INPUT
			eventptr 	: pVoid;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="Returns TRUE if successful or FALSE if the event queue is full." Name="StoreEvent.retval"/>
		END_VAR;
				//! <Function Comment="Returns next event from the input event queue. The method waits until an event is in the queue (wait = TRUE) or exits immediately even if no event is in the queue (wait = FALSE)." Name="KeyEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL KeyEvent
		VAR_INPUT
			wait 	: UINT;
			event 	: pVoid;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="This method is called to destroy an OffScreen created by CreateOffScreen." Name="DestroyOffScreen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL DestroyOffScreen
		VAR_INPUT
			screen 	: ^_NEWSCREEN;
		END_VAR;
				//! <Function Comment="This method is called to get a copy of the currently displayed screen." Name="CreateOffScreen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CreateOffScreen
		VAR_INPUT
			screen 	: ^_NEWSCREEN;
			width 	: UINT;
			heigth 	: UINT;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="The return value is 1 upon success." Name="CreateOffScreen.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to obtain the size of the current screen in pixel coordinates (screen)." Name="GetScreenSize"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetScreenSize
		VAR_INPUT
			screen 	: ^_ROOM;
		END_VAR;
				//! <Function Comment="This method is called to get a pointer to the actual screen." Name="GetScreen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetScreen
		VAR_INPUT
			screen 	: ^_NEWSCREEN;
		END_VAR;
				//! <Function Comment="This method is called to set the screen pointer to a new screen." Name="SetScreen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetScreen
		VAR_INPUT
			screen 	: ^_NEWSCREEN;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="Return value is 1 upon success." Name="SetScreen.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to copy a part (psrc) of one screen (source) to another screen (dest)." Name="CopyScreen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL CopyScreen
		VAR_INPUT
			dest 	: ^_NEWSCREEN;
			source 	: ^_NEWSCREEN;
			pdest 	: ^_ROOM;
			psrc 	: ^_ROOM;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;			//! <Variable Comment="It returns 1 upon success." Name="CopyScreen.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to get or set the contrast of a LCD Display." Name="LCD_Contrast"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LCD_Contrast
		VAR_INPUT
			cmd 	: UINT;			//! <Variable Comment="Parameter &apos;cmd&apos; can be set to LCD_STANDARD (standard contrast value), LCD_INCREASE (increase contrast by &apos;setvalue&apos;), LCD_DECREASE or LCD_GETVALUE (get contrast setting in &apos;retval&apos;)." Name="LCD_Contrast.cmd"/>
			setvalue 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: UDINT;			//! <Variable Comment="It returns -1 for an error." Name="LCD_Contrast.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to get or set the brightness of a LCD Display." Name="LCD_Brightness"/>
	FUNCTION __CDECL VIRTUAL GLOBAL LCD_Brightness
		VAR_INPUT
			cmd 	: UINT;			//! <Variable Comment="Parameter &apos;cmd&apos; can be set to LCD_STANDARD (standard contrast value), LCD_INCREASE (increase contrast by &apos;setvalue&apos;), LCD_DECREASE or LCD_GETVALUE (get contrast setting in &apos;retval&apos;)" Name="LCD_Brightness.cmd"/>
			setvalue 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: UDINT;			//! <Variable Comment="It returns -1 for an error." Name="LCD_Brightness.retval"/>
		END_VAR;
				//! <Function Comment="This method is called to set new calibration data for a touch screen. This function is equal to the &apos;Calib&apos; command in the CLI of the operating system. Use this function very carefully because a call of SetNewTouchCalibration with corrupt calibration data will cause a malfunction of the touch screen." Name="SetNewTouchCalibration"/>
	FUNCTION __CDECL VIRTUAL GLOBAL SetNewTouchCalibration
		VAR_INPUT
			newdata 	: pVoid;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: UDINT;			//! <Variable Comment="The return value is 1 upon success." Name="SetNewTouchCalibration.retval"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL SetTouchKoords
		VAR_INPUT
			setraw 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
				//! <Function Comment="This method is called to set a new pen dash style." Name="PenDashSet"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PenDashSet
		VAR_INPUT
			style 	: UDINT;
		END_VAR;
				//! <Function Comment="This method is called to create a new pen dash style for use with PenDashSet." Name="PenDashDefine"/>
	FUNCTION __CDECL VIRTUAL GLOBAL PenDashDefine
		VAR_INPUT
			style 	: UDINT;
			pDash 	: ^_DASH;
		END_VAR;
				//! <Function Comment="This method is called to rotate a screen or a part of it and save to another screen structure." Name="RotateScreen"/>
	FUNCTION __CDECL VIRTUAL GLOBAL RotateScreen
		VAR_INPUT
			dest 	: ^_NEWSCREEN;
			src 	: ^_NEWSCREEN;
			pDest 	: ^_ROOM;
			pSrc 	: ^_ROOM;
			degree 	: INT;
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;			//! <Variable Comment="It returns 1 upon success." Name="RotateScreen.retcode"/>
		END_VAR;
				//! <Function Comment="This method is called to allocate, re-allocate and free memory blocks. The memory pool is protected by the Lasal RTOS (all allocated memory is returned to the heap at reset to prevent memory leaks). To allocate memory, a pointer is set to NULL and then its address is passed to the memory function along with the size of memory to allocate. To reallocate the memory, the pointer address is passed again with a new size. To free the memory the pointer address is passed once again with a size of 0." Name="MemoryV1"/>
	FUNCTION __CDECL VIRTUAL GLOBAL MemoryV1
		VAR_INPUT
			MemPtr0 	: ^pVoid;
			size0 	: UDINT;
			mark0 	: USINT;			//! <Variable Comment="The marker is stored in the block header and is useful to identify the application allocated the memory block." Name="MemoryV1.mark0"/>
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;			//! <Variable Comment="In all cases the function returns non-zero if successful and zero if unsuccessful." Name="MemoryV1.retcode"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL DefineMouseCursorStyle
		VAR_INPUT
			CursorNbr 	: UDINT;
			HotX 	: UDINT;
			HotY 	: UDINT;
			BackMask 	: pVoid;
			ForeMask 	: pVoid;
		END_VAR
		VAR_OUTPUT
			retVal (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL StoreEventEx
		VAR_INPUT
			eventptr 	: pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL KeyEventEx
		VAR_INPUT
			wait 	: UINT;
			event 	: pVoid;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retval (AX) 	: UINT;
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL SetNewTouchCalibrationEx
		VAR_INPUT
			pDimension 	: pVoid;
			pScreenPts 	: pVoid;
			pTouchPts 	: pVoid;
		END_VAR
		VAR_OUTPUT
			retval (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _Grafix::@CT_
0$UINT,
2#0100000000001000$UINT, //TY__GRAFIX
1$UINT, 2$UINT, (SIZEOF(::_Grafix))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(197854207), "_Grafix", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_Grafix.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
END_FUNCTION


#define USER_CNT__Grafix 73

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__Grafix] OF ^Void;
	END_STRUCT;
END_TYPE



//{{LSL_IMPLEMENTATION


//*********************Inserted from <.\OS Interface\code\Grafix_01_00.st>*********************



 



#include <Rtos_interfaces.h> // we need this for the SysCIL functions
#include "..\..\Source\code\OsiBaseNew.h"


FUNCTION  _Grafix::_Grafix
VAR_OUTPUT
	ret_code		: CONFSTATES;
END_VAR
VAR
    pGrafix   : ^OS_LSE;
	aMeths    : ARRAY[0..USER_CNT__Grafix] OF ^void;
	retv      : SYS_ERROR;
END_VAR;

	retv := OS_CILGet("IMAE", #pGrafix$void);

	if retv <> SYS_ERR_NONE then

		TRACE("ERROR: Grafix Interface not available with this version/platform!");
		ret_code	:= C_UNKNOWN_CONSTR;
    else
		
		aMeths [0]	:= pGrafix^.ReadPixel;
		aMeths [1]	:= pGrafix^.WritePixel;
		aMeths [2]	:= pGrafix^.Line;
		aMeths [3]	:= pGrafix^.Polygon;
		aMeths [4]	:= pGrafix^.Rectangle;
		aMeths [5]	:= pGrafix^.Beam;
		aMeths [6]	:= pGrafix^.OutChr;
		aMeths [7]	:= pGrafix^.OutTextXY;
		aMeths [8]	:= pGrafix^.OutTextLen;
		aMeths [9]	:= pGrafix^.Arc;
		aMeths [10]	:= pGrafix^.Oval;
		aMeths [11]	:= pGrafix^.Button;
		aMeths [12]	:= pGrafix^.Scrool;
		aMeths [13]	:= pGrafix^.Bitmap;
		aMeths [14]	:= pGrafix^.MakeColor;
		aMeths [15]	:= pGrafix^.MakeTrueColor;

		aMeths [16]	:= pGrafix^.ActivateFont;
		aMeths [17]	:= pGrafix^.GetFontSize;
		aMeths [18]	:= pGrafix^.SetFontAttribute;
		aMeths [19]	:= pGrafix^.ChrWidth;
		aMeths [20]	:= pGrafix^.TxtWidth;
		aMeths [21]	:= pGrafix^.StrWidth;

		aMeths [22]	:= pGrafix^.FreeRegion;
		aMeths [23]	:= pGrafix^.ActivateRegion;
		aMeths [24]	:= pGrafix^.DeActivateRegion;
		aMeths [25]	:= pGrafix^.StartRegion;
		aMeths [26]	:= pGrafix^.AddRegion;
		aMeths [27]	:= pGrafix^.EndRegion;
		aMeths [28]	:= pGrafix^.SubRegion;
		aMeths [29]	:= pGrafix^.AndRegion;
		aMeths [30]	:= pGrafix^.XorRegion;
		aMeths [31]	:= pGrafix^.OrRegion;
		aMeths [32]	:= pGrafix^.GetActiveRegion;
		aMeths [33]	:= pGrafix^.RoomInRegion;

		aMeths [34]	:= pGrafix^.GetNoColors;
		aMeths [35]	:= pGrafix^.GetImage;
		aMeths [36]	:= pGrafix^.PutImage;
		aMeths [37]	:= pGrafix^.GetRetrace;
		aMeths [38]	:= pGrafix^.WaitForRetrace;
		aMeths [39]	:= pGrafix^.OutXPixelPool;
		aMeths [40]	:= pGrafix^.OutYPixelPool;

		aMeths [41]	:= pGrafix^.InitMouse;
		aMeths [42]	:= pGrafix^.MouseCursorStyle;
		aMeths [43]	:= pGrafix^.ShowCursor;
		aMeths [44]	:= pGrafix^.MoveCursor;
		aMeths [45]	:= pGrafix^.LimitMouse;
		aMeths [46]	:= pGrafix^.StopMouse;
		aMeths [47] := pGrafix^.HideMouse;
		aMeths [48]	:= pGrafix^.ShowMouse;
    	aMeths [49]	:= pGrafix^.IfNecHideMouse;
		aMeths [50]	:= pGrafix^.IfNecShowMouse;

		aMeths [51]	:= pGrafix^.StopEvent;
		aMeths [52]	:= pGrafix^.StartEvent;
		aMeths [53]	:= pGrafix^.StoreEvent;
		aMeths [54]	:= pGrafix^.KeyEvent;

		aMeths [55]	:= pGrafix^.DestroyOffScreen;
		aMeths [56]	:= pGrafix^.CreateOffScreen;
		aMeths [57]	:= pGrafix^.GetScreenSize;
		aMeths [58]	:= pGrafix^.GetScreen;
		aMeths [59]	:= pGrafix^.SetScreen;
		aMeths [60]	:= pGrafix^.CopyScreen;
		aMeths [61]	:= pGrafix^.LCD_Contrast;
		aMeths [62]	:= pGrafix^.LCD_Brightness;

		aMeths [63]	:= pGrafix^.SetNewCalibration;
		aMeths [64]	:= pGrafix^.SetTouchKoords;

		aMeths [65]	:= pGrafix^.PenDashSet;
		aMeths [66]	:= pGrafix^.PenDashDefine;
		aMeths [67]	:= pGrafix^.RotateScreen;

		if pGrafix^.version >= 3 then // ab OS 01.01.025

		  aMeths [68] := pGrafix^.MemoryV1;

		end_if;

		if pGrafix^.version >= 5 then

		  aMeths [69] := pGrafix^.DefineMouseCursorStyle;

		end_if;

		if pGrafix^.version >= 6 then

		  aMeths [70] := pGrafix^.pStoreEventEx;
		  aMeths [71] := pGrafix^.pKeyEventEx;

		end_if;

		if pGrafix^.version >= 9 then

		  aMeths [72] := pGrafix^.SetNewCalibrationEx;

		end_if;

		ret_code	:= InitOsiM_new(#aMeths[0]$void, USER_CNT__Grafix);
	end_if;

END_FUNCTION //  Grafix::Grafix
//		aMeths [0]	:= #pGrafix^.lActive
//		aMeths [0]	:= #pGrafix^.pIniFile
//		aMeths [0]	:= #pGrafix^.lEnableTask
//		aMeths [0]	:= #pGrafix^.LSE_InstallTask
//		aMeths [0]	:= #pGrafix^.LSE_Close
//		aMeths [0]	:= #pGrafix^.LSE_Restart
//		aMeths [0]	:= #pGrafix^.StoreLST
//		aMeths [0]	:= #pGrafix^.LSE_Memmove
//		aMeths [0]	:= #pGrafix^.LSE_Memcpy
//		aMeths [0]	:= #pGrafix^.LSE_Memset
//		aMeths [0]	:= #pGrafix^.LSE_Memcmp
//		aMeths [0]	:= #pGrafix^.LSE_GetAbsTime
//		aMeths [0]	:= #pGrafix^.LSE_Fread
//		aMeths [0]	:= #pGrafix^.LSE_Fwrite
//		aMeths [0]	:= #pGrafix^.LSE_Fopen
//		aMeths [0]	:= #pGrafix^.LSE_fclose
//		aMeths [0]	:= #pGrafix^.LSE_Flseek
//		aMeths [0]	:= #pGrafix^.LSE_Ftell
//		aMeths [0]	:= #pGrafix^.LSE_filelength
//		aMeths [0]	:= #pGrafix^.LSE_CreateDir
//		aMeths [0]	:= #pGrafix^.LSE_FindFirst
//		aMeths [0]	:= #pGrafix^.LSE_FindNext
//		aMeths [0]	:= #pGrafix^.LSE_FindClose
//		aMeths [0]	:= #pGrafix^.GetSRAMInfo
//		aMeths [0]	:= #pGrafix^.GetPointerToSRAM
//		aMeths [0]	:= #pGrafix^.GetPointerToKeyboard
//		aMeths [0]	:= #pGrafix^.OS_SetTime
//		aMeths [0]	:= #pGrafix^.OS_GetTime
//		aMeths [0]	:= #pGrafix^.OS_Wait
//		aMeths [0]	:= #pGrafix^.GetAddressVar
//		aMeths [0]	:= #pGrafix^.GetAddressObj
//		aMeths [0]	:= #pGrafix^.RegisterVar
//		aMeths [0]	:= #pGrafix^.RegisterObj
//		aMeths [0]	:= #pGrafix^.COM_DeleteQueue
//		aMeths [0]	:= #pGrafix^.COM_Login
//		aMeths [0]	:= #pGrafix^.SYS_SetExternFunction
//		aMeths [0]	:= #pGrafix^.COM_SetData
//		aMeths [0]	:= #pGrafix^.COM_GetData
//		aMeths [0]	:= #pGrafix^.OS_MetaEvent
//		aMeths [0]	:= #pGrafix^.LSE_Main_pMain
//		aMeths [0]	:= #pGrafix^.IRQPLC_FUNCTION
//		aMeths [0]	:= #pGrafix^.CLOSE_FUNCTION
//		aMeths [0]	:= #pGrafix^.LSETimer
//		aMeths [0]	:= #pGrafix^.LSE_ScreenSaver

//		aMeths [0]	:= #pGrafix^.InitGraph
//		aMeths [0]	:= #pGrafix^.CloseGraph
//		aMeths [0]	:= #pGrafix^.Getpixel
//		aMeths [0]	:= #pGrafix^.PutPixel

//		aMeths [0]	:= #pGrafix^.DrawTLBR
//		aMeths [0]	:= #pGrafix^.SetGraphicSystem
//		aMeths [0]	:= #pGrafix^.IsGraphInit
//		aMeths [0]	:= #pGrafix^.Memory

