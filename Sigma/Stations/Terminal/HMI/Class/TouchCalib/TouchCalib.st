//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES


// Default-Settings for the Touch-Calibration
//-------------------------------------------------------------------------------------------------

#define   TouchCalib_UDCVersion                                         1
#define   TouchCalib_NoAnything                                         2

#define   TouchCalib_TextTouchScreen                                    "Please touch the screen to start!"
#define   TouchCalib_TextTouchCrosshair                                 "Please touch the crosshair!"
#define   TouchCalib_TextCalibSuccessful                                "Calibration successful! Please touch the screen to continue."
#define   TouchCalib_TextCalibFailed                                    "Calibration failed! Please touch the screen to calibrate again."
#define   TouchCalib_TextNextScreen                                     "Calibration successful! Please touch the NEXT device to continue."

#define   TouchCalib_TextIdxTouchScreen                                 0
#define   TouchCalib_TextIdxTouchCrosshair                              1
#define   TouchCalib_TextIdxCalibSuccessful                             2
#define   TouchCalib_TextIdxCalibFailed                                 3
#define   TouchCalib_TextIdxNextScreen                                  4

#define   TouchCalib_StdTextAttrib                                      T_SOLID OR T_COPY OR T_PROP

#define   TouchCalib_CrosshairSize                                      40                                            // The length and width of the crosshair (if no image is chosen) [pixel]

#define   TouchCalib_MinTimeBewtweenTouchEvent                         100 ms

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "TouchCalib"
	Revision           = "1.3"
	GUID               = "{7EC29653-88B4-4828-8414-BBEB9EB15527}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,240)"
	Comment            = "Class for touch-calibration.">
	<Channels>
		<Server Name="Calibrated" GUID="{99332D45-9687-4697-96CD-64C111C55832}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="SRam" Comment="Shows if all devices have been successfully calibrated."/>
		<Server Name="SelectOrderNo" GUID="{7B24A7B4-5A21-4CA6-BB49-ECCC2B842DC2}" Visualized="true" Initialize="true" DefValue="-1" WriteProtected="false" Retentive="false" Comment="Write on this server a orderID to only calibrate the selected device. The server has to be set before the actual calibration."/>
		<Server Name="State" GUID="{C7AAF6ED-4FEB-4830-8B03-90902288CDB9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the calibration."/>
		<Client Name="coGrafix" Required="false" Internal="false"/>
		<Client Name="Tolerance" Required="true" Internal="false" DefValue="20" Comment="tolerance of the touch events"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\TouchCalib\touchcalib.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="KruAle"/>
		<Dokumentation Revision="1.3" Date="2017-10-31" Author="ZeiPhi" Company="Sigmatek" Description="Changed the routine to a four point calibration to increase the precision."/>
		<Dokumentation Revision="1.2" Date="2017-02-22" Author="KruAle" Company="Sigmatek" Description="Manytouch implemented, which can handle up to 8 devices."/>
		<Dokumentation Revision="1.1" Date="2016-11-17" Author="BurSte" Company="Sigmatek" Description="Monitoring Time between the touch events"/>
		<Dokumentation Revision="1.0" Date="2016-05-10" Author="KruAle" Company="Sigmatek" Description="Use the background-color and the frame of the UDC."/>
		<Dokumentation Revision="1.0 Beta" Date="2016-04-28" Author="KruAle" Company="Sigmatek" Description="Class for touch calibration."/>
	</RevDoku>
	<Network Name="TouchCalib">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{53D20DB3-C83C-4995-BC98-D400A80110BF}"
				Class      = "_MyIO"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Client Name="Graphic"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(690,270),(518,270),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(30,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _MyIO

TouchCalib : CLASS
: _MyIO
	TYPE
	  LSL_TOUCHINFO :  //! <Type Public="true" Name="LSL_TOUCHINFO"/>
	  (
	    LSL_TOUCHINFO_SERIAL,
	    LSL_TOUCHINFO_ORDERID,
	    LSL_TOUCHINFO_BUS,
	    LSL_TOUCHINFO_VENDOR,
	    LSL_TOUCHINFO_PRODUCT,
	    LSL_TOUCHINFO_FIRMWAREVER
	  )$UDINT;
#pragma pack(push, 1)
	  t_e_CalibStruct : STRUCT
	    Dimension : XYKOORDS;
	    Setpoint : ARRAY [0..3] OF XYKOORDS;
	    Actpoint : ARRAY [0..3] OF XYKOORDS;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_UDCInformation : STRUCT
	    Image : _ANYTHING;
	    Textscheme : _ANYTHING;
	    BgCol : _COLOR;
	    TxtCol : _COLOR;
	    FrameCol : _COLOR;
	    Attribute : _ATTRIB;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	State 	: SvrCh_DINT;
	SelectOrderNo 	: SvrCh_DINT;
	Calibrated 	: SvrCh_DINT;
  //Clients:
	Tolerance 	: CltCh_DINT;
	coGrafix 	: CltChCmd__Grafix;
  //Variables:
		bNewCalibration 	: BOOL;			//! <Variable Comment="Variable is set before the actual calibration starts" Name="bNewCalibration"/>
		bTouchEvent 	: BOOL;			//! <Variable Comment="checks if screen should be redrawn because of event." Name="bTouchEvent"/>
		Checkpoint 	: _DOT;
		dOrderID 	: DINT;			//! <Variable Comment="Order id of the actual device." Name="dOrderID"/>
		dUseCalibCil 	: DINT;			//! <Variable Comment="&lt; 0  ... Grafix CIL is being used&#13;&#10;= 0  ... Calib CIL version 0 is being used&#13;&#10;= 1  ... Calib CIL version 1 is being used&#13;&#10; ..." Name="dUseCalibCil"/>
		pCalib 	: ^CALIB_TYPE;			//! <Variable Comment="struct for calib cil" Name="pCalib"/>
		sCalibData 	: t_e_CalibStruct;			//! <Variable Comment="Setpoints and actual points from user input to calibrate the device" Name="sCalibData"/>
		sTouchData 	: t_s_UDCInformation;			//! <Variable Comment="Information from the udc " Name="sTouchData"/>
		TouchKoord 	: _DOT;			//! <Variable Comment="Actual coordinates from user input" Name="TouchKoord"/>
		udActDeviceID 	: UDINT;			//! <Variable Comment="Device id of the actual calibrated monitor." Name="udActDeviceID"/>
		udMonitorNo 	: UDINT;			//! <Variable Comment="Number of connected devices." Name="udMonitorNo"/>
		udTimeMark 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="this method is called everytime when the input is active and a event occured" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called everytime when system wants to redraw the io" Name="Draw"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Draw
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="Draw.pio"/>
			pr 	: ^_RESULT;			//! <Variable Comment="pointer to _RESULT information" Name="Draw.pr"/>
			pv 	: ^_VARIABLE;			//! <Variable Comment="pointer to io _VARIABLE information" Name="Draw.pv"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="Draw.input"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is re" Name="Draw.retcode"/>
		END_VAR;
				//! <Function Comment="this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="Draws a crosshair for the user input if no image is available." Name="DrawDefaultCrosshair"/>
	FUNCTION DrawDefaultCrosshair
		VAR_INPUT
			Room 	: _ROOM;
		END_VAR;
				//! <Function Comment="Shows the user some information about the state of the calibration." Name="OutUserText"/>
	FUNCTION OutUserText
		VAR_INPUT
			pio 	: ^_IO;
			dIndex 	: DINT;
			pDefText 	: ^CHAR;
		END_VAR;
	
	FUNCTION GetScreenKoords
		VAR_INPUT
			coor0 	: ^XYKOORDS;
		END_VAR;
	
	FUNCTION ClearScreen
		VAR_INPUT
			framecol 	: DINT;
		END_VAR;
	
	FUNCTION MetaPixel
		VAR_INPUT
			x0 	: DINT;
			y0 	: DINT;
			color0 	: DINT;
			size0 	: DINT;
		END_VAR;
	
	FUNCTION MetaText
		VAR_INPUT
			txt0 	: ^CHAR;
			x0 	: DINT;
			y0 	: DINT;
			color0 	: DINT;
			capt0 	: DINT;
		END_VAR;
	
	FUNCTION CalibfromDAT
		VAR_INPUT
			path 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION calculate;
	
	FUNCTION CalibTouch
		VAR_INPUT
			path 	: ^CHAR;
		END_VAR;
	
	FUNCTION WriteCalibToDAT
		VAR_INPUT
			path0 	: ^CHAR;
			data0 	: ^void;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION SetNewCalibration
		VAR_INPUT
			newdat0 	: ^void;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION TouchTest;
	
	FUNCTION CalibTouchEx
		VAR_INPUT
			path 	: ^CHAR;
			nbrX 	: DINT;
			nbrY 	: DINT;
		END_VAR;
	
	FUNCTION SetNewCalibrationEx
		VAR_INPUT
			pDimension 	: ^XYKOORDS;
			gridSoll 	: ^XYKOORDS;
			gridAct 	: ^XYKOORDS;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION SetTouchEventCallback
		VAR_INPUT
			pfnTouchEventCb 	: ^void;
		END_VAR;
				//! <Function Comment="Fetches the number of connected devices." Name="TouchGetCount"/>
	FUNCTION TouchGetCount
		VAR_OUTPUT
			udRetval 	: UDINT;
		END_VAR;
	
	FUNCTION GetProperty
		VAR_INPUT
			deviceid 	: UDINT;
			id 	: UDINT;
			buffer 	: ^void;
			size 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
				//! <Function Comment="1 ... set the mode to raw coordinates&#13;&#10;0 ... set the mode to calibrated coordinates" Name="SetRawMode"/>
	FUNCTION SetRawMode
		VAR_INPUT
			raw 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION ClearEvents
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
				//! <Function Comment="Apply the coordinates from the user input and set them as calibrated coordinates." Name="DeviceSetCalibration"/>
	FUNCTION DeviceSetCalibration
		VAR_INPUT
			deviceid 	: UDINT;
			orderid 	: DINT;
			newdat0 	: ^void;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION DeviceSetCalibrationEx
		VAR_INPUT
			deviceid 	: UDINT;
			orderid 	: DINT;
			pDimension 	: ^XYKOORDS;
			gridSoll 	: ^XYKOORDS;
			gridAct 	: ^XYKOORDS;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
				//! <Function Comment="Get device id according to the order id." Name="GetDeviceID"/>
	FUNCTION GetDeviceID
		VAR_INPUT
			order 	: DINT;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
				//! <Function Comment="Save the order of all devices. Call this method after all devices have been successfully calibrated." Name="SaveOrder"/>
	FUNCTION SaveOrder
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
				//! <Function Comment="Set the order id of an device according to the device id." Name="SetOrderID"/>
	FUNCTION SetOrderID
		VAR_INPUT
			deviceid 	: UDINT;
			orderid 	: DINT;
		END_VAR
		VAR_OUTPUT
			dRetval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SelectOrderNo::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Grafix


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TouchCalib::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_TOUCHCALIB
1$UINT, 3$UINT, (SIZEOF(::TouchCalib))$UINT, 
3$UINT, 2$UINT, 0$UINT, 
TO_UDINT(627189056), "TouchCalib", //Class
TO_UDINT(2980745877), "_MyIO", 0$UINT, 3$UINT, //Baseclass
//Servers:
(::TouchCalib.State.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::TouchCalib.SelectOrderNo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2489017937), "SelectOrderNo", 
(::TouchCalib.Calibrated.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1152292008), "Calibrated", 
//Clients:
(::TouchCalib.Tolerance.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(598342311), "Tolerance", 
(::TouchCalib.coGrafix.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(860445224), "coGrafix", TO_UDINT(197854207), "_Grafix", 1$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_TouchCalib 17

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TouchCalib] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TouchCalib::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _MyIO::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_TouchCalib;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #Draw();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SelectOrderNo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SelectOrderNo::Write() );
	IF SelectOrderNo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Calibrated.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Calibrated.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


#include <Rtos_interfaces.h>


FUNCTION VIRTUAL GLOBAL TouchCalib::Init

  VAR
  	retv    : SYS_ERROR;
  END_VAR

  if (_FirstScan) then
  
    // get interface
    retv := OS_CILGET(INTERFACE_CALIB , #pCalib);
    
    if (retv <> SYS_ERR_NONE) then
      TRACE("Calib Interface not available for this version/platform!");
      // use grafix interface
      dUseCalibCil:= -1;
    else
      dUseCalibCil:= 0;
      
      // check OS version (since 09.01.249 and smaller 09.03.001)
      if (pCalib^.calib_version = 1) & 
         (_RTOSVersion >= 16#91F9) & (_RTOSVersion < 16#9301) then
        dUseCalibCil:= 1;
      end_if;
          
    end_if;

  end_if;

END_FUNCTION

FUNCTION __CDECL VIRTUAL GLOBAL TouchCalib::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  VAR
    pHelpAnyThing   : ^_ANYTHING;
    i : udint;
  END_VAR

  // only once necessary
  //-----------------------------------------------------------------------------------------
  if firsttime then
    
    // initialize the data
    sTouchData.Textscheme.list := DEFLST;
    sTouchData.Textscheme.no   := DEFSCOPE;
    sTouchData.Image.list      := DEFLST;
    sTouchData.Image.no        := DEFSCOPE;
    
    // check pointer to io-information
    if (pio = NIL) | (pio^.theurge = NIL) then
      TRACE("TouchCalib::IF_Start(): Pointer pio is invalid");
      return;
    end_if;
    
    // check version of the udc
    if (pio^.theurge^.info = TouchCalib_UDCVersion) then      
      

      // get the textscheme and the image
      //-----------------------------------------------------------------------------------------
      // check the number of all parameters
      if (pio^.theurge^.memanything.no = TouchCalib_NoAnything) then
        
        pHelpAnyThing := pio^.theurge^.memanything.ptr;
        
        // check if schema is a image
        if pHelpAnyThing^.list = ICONLST then
          sTouchData.Image := pHelpAnyThing^;
        end_if;
        
        pHelpAnyThing += sizeof(_ANYTHING);
        
        // check if scheme is a textscheme
        if pHelpAnyThing^.list = TEXTSCHEME then
          sTouchData.Textscheme := pHelpAnyThing^;
        end_if;

      else
        TRACE("TouchCalib::IF_Start(): Wrong number of schemes in the UDC");
      end_if;

    else
      TRACE("TouchCalib::IF_Start(): Wrong version of the UDC");
    end_if;
    
  end_if;
  
  
  // get number of connected devices
  //-----------------------------------------------------------------------------------------
  udMonitorNo := TouchGetCount();
  
  // reset all order IDs for calibration of all devices
  if (udMonitorNo > 0) & (SelectOrderNo < 0) then
    for i:=0 to udMonitorNo-1 do
      if SetOrderID(deviceid := i, 
                    orderid  := to_dint(i)) < 0 then
        TRACE("TouchCalib::IF_Start(): Order ID could not be reset");
      end_if;
    end_for;
  end_if;
  
  // save the background color
  sTouchData.BgCol      := pio^.colback;
  sTouchData.TxtCol     := pio^.coltxt;
  sTouchData.FrameCol   := pio^.colframe;
  sTouchData.Attribute  := pio^.attrib;
  
  // get the valid tolerance
  Tolerance := Tolerance.read();
  
  // set first screen
  //-----------------------------------------------------------------------------------------
  bTouchEvent := true;
  OutTextAlign(p0 := "", 
               x1 := 0, 
               p1 := #pio^.space, 
               x2 := pio^.font, 
               x3 := sTouchData.Attribute, 
               x9 := pio^.frametype, 
               x4 := sTouchData.TxtCol, 
               x5 := sTouchData.BgCol, 
               x6 := sTouchData.FrameCol, 
               x7 := 1);
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL TouchCalib::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
  	tmpDeviceID : UDINT;
  END_VAR
  
  //--------------------------------------------------
  // time monitoring between touch events
  if (ops.tAbsolute - udTimeMark) > TouchCalib_MinTimeBewtweenTouchEvent then
    udTimeMark := ops.tAbsolute;
    
#ifdef UC_MULTIDISPLAY
  #ifdef UC_MULTITOUCH
    // calculate device id according to the number of devices and the amount of fingers in use  
    tmpDeviceID := pe^.multindex / (UC_MULTITOUCH / UC_MULTIDISPLAY);
  #else
    tmpDeviceID := 0;
  #endif
#else 
  tmpDeviceID := 0;
#endif
    
    if (pe^.ftype = _EVENT_HIDPRESS) then
     
      //-------------------------------------------------------------
      // calibrate all devices according to the device id
      //-------------------------------------------------------------
      if (SelectOrderNo < 0) then
        
        // save actual device ID if new device
        if (bNewCalibration) then
          bNewCalibration := false;
          udActDeviceID   := tmpDeviceID;
        
        // touch-event on other device - ignore
        elsif ((udActDeviceID <> tmpDeviceID) & (State >= 2) & (State <= 4)) then
          retcode := _IDIDIT;
          return;
        end_if; 
      
      //-------------------------------------------------------------
      // calibrate a selected device
      //-------------------------------------------------------------
      else
        
        // save device ID of the selected device
        if (bNewCalibration) then
          bNewCalibration := false;
          dOrderID        := to_dint(SelectOrderNo);
          udActDeviceID   := to_udint(GetDeviceID(order := dOrderID));
        
        // touch-event on other device - ignore
        elsif ((udActDeviceID <> tmpDeviceID) & (State >= 2) & (State <= 4)) then
          retcode := _IDIDIT;
          return;
        end_if;
      
      end_if;
      //-------------------------------------------------------------
      
      // draw new screen for event
      bTouchEvent := true;
      TouchKoord  := pe^.dot;
      Refresh     := 1;
    
    else
      retcode := _IDIDIT;
      return;
    end_if; 
  
  else
    retcode := _IDIDIT;
    return;
  end_if;
  
  // method of the base-class
  retcode := _MyIO::GetEvent(ped, pe);
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL TouchCalib::Draw
	VAR_INPUT
		pio 	: ^_IO;
		pr 	: ^_RESULT;
		pv 	: ^_VARIABLE;
		input 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR
  VAR
    myroom    : _ROOM;
    pPicture  : ^void;
  END_VAR
  
  
  // draw because of touch-event
  //-----------------------------------------------------------------------------------------
  if bTouchEvent then
    bTouchEvent := false;
    
    
    //********************************************************************************
    //****                                                                        ****
    //****                        SSM for the touch-events                        ****
    //****                                                                        ****
    //********************************************************************************
    case State of
      
      
      // ********************************************************************************
      // **   Draw user information                                                    **
      // ********************************************************************************
      0:
          // get text in textscheme
          OutUserText(pio       := pio,
                      dIndex    := TouchCalib_TextIdxTouchScreen, 
                      pDefText  := TouchCalib_TextTouchScreen);
          
          // next step
          State := 1;
      
      
      // ********************************************************************************
      // **   Draw the first crosshair                                                 **
      // ********************************************************************************
      1:  
          // get text in textscheme
          OutUserText(pio       := pio,
                      dIndex    := TouchCalib_TextIdxTouchCrosshair, 
                      pDefText  := TouchCalib_TextTouchCrosshair);
          
          // touch-coordinates are raw coordinates
          SetRawMode(raw := 1);
          if SelectOrderNo < 0 then
            bNewCalibration := true;
          end_if;
          
          // touch is being calibrated
          Calibrated.Write(0);
          
          // 1 crosshair
          //-----------------------------------------------------------------------------------------
          myroom.xy1.x              := TouchCalib_CrosshairSize;
          myroom.xy1.y              := TouchCalib_CrosshairSize;
          myroom.xy2.x              := myroom.xy1.x + TouchCalib_CrosshairSize;
          myroom.xy2.y              := myroom.xy1.y + TouchCalib_CrosshairSize;
          sCalibData.Setpoint[0].X  := myroom.xy1.x + (TouchCalib_CrosshairSize / 2);
          sCalibData.Setpoint[0].y  := myroom.xy1.y + (TouchCalib_CrosshairSize / 2);
          
          // get picture
          pPicture := get_anything(#sTouchData.Image, NIL); 
          if pPicture = NIL then
            DrawDefaultCrosshair(Room:=myroom);
          else
            out_part_BMP(#myroom, pPicture$^_BMP, pio^.attrib);
          end_if;
          
          // next step
          State := 2;
      
      
      // ********************************************************************************
      // **   Save the first touch-point                                               **
      // ********************************************************************************
      2:  
          // save touch-koord
          sCalibData.Actpoint[0].x := TouchKoord.x;
          sCalibData.Actpoint[0].y := TouchKoord.y;
          
          // get text in textscheme
          OutUserText(pio       := pio,
                      dIndex    := TouchCalib_TextIdxTouchCrosshair, 
                      pDefText  := TouchCalib_TextTouchCrosshair);
          
          // 2 crosshair
          //-----------------------------------------------------------------------------------------    
          myroom.xy1.x              := (pio^.space.xy2.x - TouchCalib_CrosshairSize) - TouchCalib_CrosshairSize;
          myroom.xy1.y              := TouchCalib_CrosshairSize;
          myroom.xy2.x              := myroom.xy1.x + TouchCalib_CrosshairSize;
          myroom.xy2.y              := myroom.xy1.y + TouchCalib_CrosshairSize;
          sCalibData.Setpoint[1].X  := myroom.xy1.x + (TouchCalib_CrosshairSize / 2);
          sCalibData.Setpoint[1].Y  := myroom.xy1.y + (TouchCalib_CrosshairSize / 2);
          
          // get picture
          pPicture := get_anything(#sTouchData.Image, NIL); 
          if pPicture = NIL then
            DrawDefaultCrosshair(Room:=myroom);
          else
            out_part_BMP(#myroom, pPicture$^_BMP, pio^.attrib);
          end_if;
          
          // next step
          State := 3;
      
      
      // ********************************************************************************
      // **   Save the second touch-point                                              **
      // ********************************************************************************
      3:
          // save touch-koord
          sCalibData.Actpoint[1].x := TouchKoord.x;
          sCalibData.Actpoint[1].y := TouchKoord.y;
          
          // get text in textscheme
          OutUserText(pio       := pio,
                      dIndex    := TouchCalib_TextIdxTouchCrosshair, 
                      pDefText  := TouchCalib_TextTouchCrosshair);
          
          // 3 crosshair
          //-----------------------------------------------------------------------------------------
          myroom.xy1.x              := TouchCalib_CrosshairSize;
          myroom.xy1.y              := (pio^.space.xy2.y - TouchCalib_CrosshairSize) - TouchCalib_CrosshairSize;
          myroom.xy2.x              := myroom.xy1.x + TouchCalib_CrosshairSize;
          myroom.xy2.y              := myroom.xy1.y + TouchCalib_CrosshairSize;
          sCalibData.Setpoint[2].X  := myroom.xy1.x + (TouchCalib_CrosshairSize / 2);
          sCalibData.Setpoint[2].Y  := myroom.xy1.y + (TouchCalib_CrosshairSize / 2);
          
          // get picture
          pPicture := get_anything(#sTouchData.Image, NIL); 
          if pPicture = NIL then
            DrawDefaultCrosshair(Room:=myroom);
          else
            out_part_BMP(#myroom, pPicture$^_BMP, pio^.attrib);
          end_if;
          
          // next step
          State := 7;
      
      
      // ********************************************************************************
      // **   Save the third touch-point  / Draw first check point                     **
      // ********************************************************************************
      4:
          // save touch-koord    
          sCalibData.Actpoint[3].x := TouchKoord.x;
          sCalibData.Actpoint[3].y := TouchKoord.y;
          
            
          // set dimensions   nx * ny = points
          // 2 X points and 2 Y points means 4 calib points
          sCalibData.Dimension.X := 2;
          sCalibData.Dimension.Y := 2;
            
          // set the new calibration
          if DeviceSetCalibrationEx(deviceid   := udActDeviceID, 
                                    orderid    := dOrderID, 
                                    pDimension := #sCalibData.Dimension, 
                                    gridSoll   := #sCalibData.Setpoint[0], 
                                    gridAct    := #sCalibData.Actpoint[0]) < 0 then
                                    
            TRACE("TouchCalib::Draw(): New touch coordinates could not be saved");
        
          end_if;
          
          // touch-coordinates are calibrated coordinates
          SetRawMode(raw := 0);
          
          // get text in textscheme
          OutUserText(pio       := pio,
                      dIndex    := TouchCalib_TextIdxTouchCrosshair, 
                      pDefText  := TouchCalib_TextTouchCrosshair);
          
          // 5 crosshair
          //-----------------------------------------------------------------------------------------
          myroom.xy1.x  := (pio^.space.xy1.x) + (pio^.space.xy2.x / 4);
          myroom.xy1.y  := (pio^.space.xy1.y) + (pio^.space.xy2.y / 4);
          myroom.xy2.x  := myroom.xy1.x + TouchCalib_CrosshairSize;
          myroom.xy2.y  := myroom.xy1.y + TouchCalib_CrosshairSize;
          Checkpoint.x  := myroom.xy1.x + (TouchCalib_CrosshairSize / 2);
          Checkpoint.y  := myroom.xy1.y + (TouchCalib_CrosshairSize / 2);
          
          // get picture
          pPicture := get_anything(#sTouchData.Image, NIL); 
          if pPicture = NIL then
            DrawDefaultCrosshair(Room:=myroom);
          else
            out_part_BMP(#myroom, pPicture$^_BMP, pio^.attrib);
          end_if;
          
          // next step
          State := 6;
      
      
      // ********************************************************************************
      // **   Touch successfully calibrated! -> wait for next touch-event              **
      // ********************************************************************************
      5:
          // done, reset everything
          State := 0;
          
          // save order of devices
          SaveOrder();
          
          // return to the previous screen
          InsertCMD(CMD_RETURN, 0, 0);           
      
      
      // ********************************************************************************
      // **   Check if the calibration is valid -> do it again, if neccessary          **
      // ********************************************************************************
      6:
          // check if touch calibration is valid
          //-----------------------------------------------------------------------------------------
          if TouchKoord.x > (Checkpoint.x - Tolerance) & TouchKoord.x < (Checkpoint.x + Tolerance) &
             TouchKoord.y > (Checkpoint.y - Tolerance) & TouchKoord.y < (Checkpoint.y + Tolerance) then
            
            // go to the next check point
            //-----------------------------------------------------------------------------------------
            // get text in textscheme
            OutUserText(pio       := pio,
                        dIndex    := TouchCalib_TextIdxTouchCrosshair, 
                        pDefText  := TouchCalib_TextTouchCrosshair);
            
            // 6 crosshair
            //-----------------------------------------------------------------------------------------
            myroom.xy1.x  := (pio^.space.xy2.x - TouchCalib_CrosshairSize) - (pio^.space.xy2.x / 4);
            myroom.xy1.y  := (pio^.space.xy2.y - TouchCalib_CrosshairSize) - (pio^.space.xy2.y / 4);
            myroom.xy2.x  := myroom.xy1.x + TouchCalib_CrosshairSize;
            myroom.xy2.y  := myroom.xy1.y + TouchCalib_CrosshairSize;
            Checkpoint.x  := myroom.xy1.x + (TouchCalib_CrosshairSize / 2);
            Checkpoint.y  := myroom.xy1.y + (TouchCalib_CrosshairSize / 2);
            
            // get picture
            pPicture := get_anything(#sTouchData.Image, NIL); 
            if pPicture = NIL then
              DrawDefaultCrosshair(Room:=myroom);
            else
              out_part_BMP(#myroom, pPicture$^_BMP, pio^.attrib);
            end_if;
            
            // next step
            State := 8;
            
          else
            
            // get text in textscheme
            OutUserText(pio       := pio,
                        dIndex    := TouchCalib_TextIdxCalibFailed, 
                        pDefText  := TouchCalib_TextCalibFailed);
                        
            // calibration failed! -> start again
            //--------------------------------------------------
            State := 0;
            
          end_if;
                 
         
      // ********************************************************************************
      // **   Save the third touch-point                                               **
      // ********************************************************************************
      7:  
          // save touch-koord
          sCalibData.Actpoint[2].x := TouchKoord.x;
          sCalibData.Actpoint[2].y := TouchKoord.y;
          
          // get text in textscheme
          OutUserText(pio       := pio,
                      dIndex    := TouchCalib_TextIdxTouchCrosshair, 
                      pDefText  := TouchCalib_TextTouchCrosshair);
          
          // 4 crosshair
          //-----------------------------------------------------------------------------------------    
          myroom.xy1.x              := (pio^.space.xy2.x - TouchCalib_CrosshairSize) - TouchCalib_CrosshairSize;
          myroom.xy1.y              := (pio^.space.xy2.y - TouchCalib_CrosshairSize) - TouchCalib_CrosshairSize;
          myroom.xy2.x              := myroom.xy1.x + TouchCalib_CrosshairSize;
          myroom.xy2.y              := myroom.xy1.y + TouchCalib_CrosshairSize;
          sCalibData.Setpoint[3].X  := myroom.xy1.x + (TouchCalib_CrosshairSize / 2);
          sCalibData.Setpoint[3].Y  := myroom.xy1.y + (TouchCalib_CrosshairSize / 2);
          
          // get picture
          pPicture := get_anything(#sTouchData.Image, NIL); 
          if pPicture = NIL then
            DrawDefaultCrosshair(Room:=myroom);
          else
            out_part_BMP(#myroom, pPicture$^_BMP, pio^.attrib);
          end_if;
          
          // next step
          State := 4;
         
         
      // ********************************************************************************
      // **   Check if the calibration is valid -> do it again, if neccessary          **
      // ********************************************************************************
      8:
          // check if touch calibration is valid
          //-----------------------------------------------------------------------------------------
          if TouchKoord.x > (Checkpoint.x - Tolerance) & TouchKoord.x < (Checkpoint.x + Tolerance) &
             TouchKoord.y > (Checkpoint.y - Tolerance) & TouchKoord.y < (Checkpoint.y + Tolerance) then
            
            // set order ID according to the device ID
            SetOrderID(deviceid := udActDeviceID, 
                       orderid  := dOrderID);
            
            dOrderID += 1;
            if (dOrderID >= to_dint(udMonitorNo)) |     // all devices are calibrated
               (SelectOrderNo >= 0) then                // selected device is calibrated
              
              // get text in textscheme
              OutUserText(pio       := pio,
                          dIndex    := TouchCalib_TextIdxCalibSuccessful, 
                          pDefText  := TouchCalib_TextCalibSuccessful);
              
              // reset order ID
              dOrderID      := 0;
              SelectOrderNo := -1;
              // last device -> calibration successful
              State := 5;
              Calibrated.Write(1);
              
            else
              // get text in textscheme
              OutUserText(pio       := pio,
                          dIndex    := TouchCalib_TextIdxNextScreen, 
                          pDefText  := TouchCalib_TextNextScreen);
              // calibrate next device
              State := 0;
            end_if;
            
          else
            
            // get text in textscheme
            OutUserText(pio       := pio,
                        dIndex    := TouchCalib_TextIdxCalibFailed, 
                        pDefText  := TouchCalib_TextCalibFailed);
                        
            // calibration failed! -> start again
            //--------------------------------------------------
            State := 0;
            
          end_if;
          
          
    end_case;
    
  end_if;
  
  retcode := _IDIDIT;
  
END_FUNCTION


FUNCTION TouchCalib::DrawDefaultCrosshair
	VAR_INPUT
		Room 	: _ROOM;
	END_VAR
  
  // draw a crosshair according to the room
  //----------------------------------------------------------------
  // horizontal line
  coGrafix.Line(x0      := Room.xy1.x, 
                y0      := Room.xy1.y + (TouchCalib_CrosshairSize / 2), 
                x1      := Room.xy2.x, 
                y1      := Room.xy1.y + (TouchCalib_CrosshairSize / 2), 
                attrib  := TouchCalib_StdTextAttrib, 
                color   := BLACK);
  // vertical line
  coGrafix.Line(x0      := Room.xy1.x + (TouchCalib_CrosshairSize / 2), 
                y0      := Room.xy1.y, 
                x1      := Room.xy1.x + (TouchCalib_CrosshairSize / 2), 
                y1      := Room.xy2.y, 
                attrib  := TouchCalib_StdTextAttrib, 
                color   := BLACK);
  
END_FUNCTION


FUNCTION TouchCalib::OutUserText
	VAR_INPUT
		pio 	: ^_IO;
		dIndex 	: DINT;
		pDefText 	: ^CHAR;
	END_VAR
  VAR
  	pString   : ^_CHAR;
    tmpString : ARRAY[0..255] of _CHAR;
  END_VAR

  // check strings
  if pDefText = NIL | pio = NIL then
    TRACE("TouchCalib::OutUserText(): Invalid data");
    return;
  end_if;

  // get text in textscheme
  //--------------------------------------------------
  pString$^void := NewDoScheme( x0 := sTouchData.Textscheme.list, 
                                x1 := dIndex, 
                                x2 := sTouchData.Textscheme.no);
  
  // check if text is valid
  //--------------------------------------------------
  if pString = NIL then
  
    // default-text
    StrNCpy(p0 := #tmpString[0], 
            x1 := sizeof(tmpString[0]), 
            p2 := pDefText, 
            x3 := sizeof(pDefText^), 
            ml := sizeof(tmpString) / sizeof(tmpString[0]));
            
  else
  
    // text from scheme
    StrNCpy(p0 := #tmpString[0], 
            x1 := sizeof(tmpString[0]), 
            p2 := pString, 
            x3 := sizeof(pString^), 
            ml := sizeof(tmpString) / sizeof(tmpString[0]));
            
  end_if;
    
  // show text
  //--------------------------------------------------
  OutTextAlign(p0 := #tmpString[0], 
               x1 := 0, 
               p1 := #pio^.space, 
               x2 := pio^.font, 
               x3 := sTouchData.Attribute, 
               x9 := pio^.frametype, 
               x4 := sTouchData.TxtCol, 
               x5 := sTouchData.BgCol, 
               x6 := sTouchData.FrameCol, 
               x7 := sizeof(tmpString[0]));
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL TouchCalib::SelectOrderNo::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  // specific order id can only be set if calibrated and idle
  //--------------------------------------------------
  if Calibrated & (State = 0) & 
     (dUseCalibCil >= 1) then         // function only available at version greater 1
	  SelectOrderNo   := input;
    bNewCalibration := true;
  end_if;

	result := SelectOrderNo;

END_FUNCTION


FUNCTION TouchCalib::GetScreenKoords
	VAR_INPUT
		coor0 	: ^XYKOORDS;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_GETSCREENKOORDS(coor0);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::ClearScreen
	VAR_INPUT
		framecol 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_CLEARSCREEN(framecol);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::MetaPixel
	VAR_INPUT
		x0 	: DINT;
		y0 	: DINT;
		color0 	: DINT;
		size0 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_METAPIXEL(x0, y0, color0, size0);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::MetaText
	VAR_INPUT
		txt0 	: ^CHAR;
		x0 	: DINT;
		y0 	: DINT;
		color0 	: DINT;
		capt0 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_METATEXT(txt0, x0, y0, color0, capt0);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::CalibfromDAT
	VAR_INPUT
		path 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    dRetval := OS_TOUCHINFO_CALIBFROMDAT(path);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::calculate
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_CALCULATE();
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::CalibTouch
	VAR_INPUT
		path 	: ^CHAR;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_CALIBTOUCH(path);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::WriteCalibToDAT
	VAR_INPUT
		path0 	: ^CHAR;
		data0 	: ^void;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    dRetval := OS_TOUCHINFO_WRITECALIBTODAT(path0, data0);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::SetNewCalibration
	VAR_INPUT
		newdat0 	: ^void;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    dRetval := OS_TOUCHINFO_SETNEWCALIBRATION(newdat0);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::TouchTest
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_TOUCHTEST();
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::CalibTouchEx
	VAR_INPUT
		path 	: ^CHAR;
		nbrX 	: DINT;
		nbrY 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_CALIBTOUCHEX(path, nbrX, nbrY);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::SetNewCalibrationEx
	VAR_INPUT
		pDimension 	: ^XYKOORDS;
		gridSoll 	: ^XYKOORDS;
		gridAct 	: ^XYKOORDS;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 0 then
    dRetval := OS_TOUCHINFO_SETNEWCALIBRATIONEX(pDimension, gridSoll, gridAct);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::SetTouchEventCallback
	VAR_INPUT
		pfnTouchEventCb 	: ^void;
	END_VAR
  
  if dUseCalibCil >= 0 then
    OS_TOUCHINFO_SETTOUCHEVENTCALLBACK(pfnTouchEventCb);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::TouchGetCount
	VAR_OUTPUT
		udRetval 	: UDINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    udRetval := OS_TOUCHINFO_TOUCHGETCOUNT();
  else
    // Method not supported
    udRetval := 0;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::GetProperty
	VAR_INPUT
		deviceid 	: UDINT;
		id 	: UDINT;
		buffer 	: ^void;
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_GETPROPERTY(deviceid, id, buffer, size);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::SetRawMode
	VAR_INPUT
		raw 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    // rawmode: 0=off, 1=on
    dRetval := OS_TOUCHINFO_SETRAWMODE(raw);
  else
    // Method not supported - use Grafix interface
    dRetval := coGrafix.SetTouchKoords(setraw := raw);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::ClearEvents
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_CLEAREVENTS();
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::DeviceSetCalibration
	VAR_INPUT
		deviceid 	: UDINT;
		orderid 	: DINT;
		newdat0 	: ^void;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_DEVICESETCALIBRATION(deviceid, orderid, newdat0);
  else
    // Method not supported - use Grafix interface
    dRetval := to_dint(coGrafix.SetNewTouchCalibration(newdata := newdat0));
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::DeviceSetCalibrationEx
	VAR_INPUT
		deviceid 	: UDINT;
		orderid 	: DINT;
		pDimension 	: ^XYKOORDS;
		gridSoll 	: ^XYKOORDS;
		gridAct 	: ^XYKOORDS;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_DEVICESETCALIBRATIONEX(deviceid, orderid, pDimension, gridSoll, gridAct);
  else
    // Method not supported - use Grafix interface
    dRetval := coGrafix.SetNewTouchCalibrationEx(pDimension := pDimension, pScreenPts := gridSoll, pTouchPts := gridAct);
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::GetDeviceID
	VAR_INPUT
		order 	: DINT;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_GETDEVICEID(order);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::SaveOrder
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_SAVEORDER();
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION


FUNCTION TouchCalib::SetOrderID
	VAR_INPUT
		deviceid 	: UDINT;
		orderid 	: DINT;
	END_VAR
	VAR_OUTPUT
		dRetval 	: DINT;
	END_VAR
  
  if dUseCalibCil >= 1 then
    dRetval := OS_TOUCHINFO_SETORDERID(deviceid, orderid);
  else
    // Method not supported
    dRetval := -1;
  end_if;
  
END_FUNCTION



