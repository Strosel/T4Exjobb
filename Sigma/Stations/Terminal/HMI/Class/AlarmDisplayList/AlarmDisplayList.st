//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\AlarmDisplayList\AlarmTemp.h"

(*!
<Class
	Name               = "AlarmDisplayList"
	Revision           = "1.7"
	GUID               = "{B681CDD4-0999-41FE-8CE0-8F1C06B0C4AB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,420)">
	<Channels>
		<Server Name="Acknowledge" WriteProtected="false">
		</Server>
		<Server Name="AlaTxtLong" GUID="{25E41461-5DFD-4185-8170-7ABA528154D8}" Class="VirtualBaseInit" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="AlaTxtShort" GUID="{A808CD88-615A-4578-ADD8-AC25A24224BF}" Class="VirtualBaseInit" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="Delete" WriteProtected="false">
		</Server>
		<Server Name="HelpTxt" GUID="{156C30AF-766C-4659-986D-16746F8A50A9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="command read the alarm textes for alarm details"/>
		<Client Name="AlarmTxtLong" Required="true" Internal="true"/>
		<Client Name="AlarmTxtShort" Required="true" Internal="true"/>
		<Client Name="ccAlarmChanged" Required="false" Internal="false" Comment="command channel to share alarm changes (optional)"/>
		<Client Name="coAlarmTitle" Required="false" Internal="false" Comment="objekt channel to AlarmTitleLine (optional)"/>
		<Client Name="ColumnChoice" Required="true" Internal="false" Comment="Bitmuster zum Enablen der Darstellung von Display-Items&#13;&#10;2#1000 = Alarmnummer&#13;&#10;2#0100 = Zeit gekommen/gegangen&#13;&#10;2#0010 = Zyklusnummer (KaiAnd: real &quot;Para1&quot;)&#13;&#10;2#0001 = Alarmtext &#13;&#10;"/>
		<Client Name="coSystemLogging" Required="false" Internal="false" Comment="object channel to SystemLogging (optional)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\AlarmDisplayList\AlarmTemp.h" Include="true"/>
			<File Path=".\Class\AlarmDisplayList\AlarmDisplayList.UDC"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.7" Date="2018-05-28" Author="FurLuk" Company="Sigmatek" Description="correct Filter-Comment in the complex network"/>
		<Dokumentation Revision="1.6" Date="2018-03-29" Author="KaiAnd" Company="Sigmatek" Description="connected Server &quot;SortAlgorithm&quot; from base class "/>
		<Dokumentation Revision="1.5" Date="2017-08-11" Author="WesAnd, HubChr" Company="Sigmatek" Description="- Output of multiline Alarmtext is now possible&#13;&#10;- Class now acts accordingly if client &quot;Filter&quot; of embedded Class _AlarmDisplay is changed."/>
		<Dokumentation Revision="1.4" Date="2017-01-02" Author="KaiAnd" Company="Sigmatek" Description="horizontal scroll per column-width by using new method CalcHscrollPerColumn()"/>
		<Dokumentation Revision="1.3" Date="2016-10-31" Author="KaiAnd" Company="Sigmatek" Description="1: &quot;reset mark if it&apos;s to high&quot; will work now in ::IF_Run() to be more reliable (previously in ::Line())&#13;&#10;2: optical code improvements"/>
		<Dokumentation Revision="1.2" Date="2016-08-24" Author="HubChr" Company="Sigmatek" Description="Textpositions were calculated wrong in case Column AlarmNr was deactivated."/>
		<Dokumentation Revision="1.1" Date="2016-07-11" Author="KaiAnd" Company="Sigmatek" Description="--&gt; command channel &quot;ccAlarmChanged&quot; implemented to share changed alarms for external use&#13;&#10;--&gt; ::CreateAlarmTxt(): casts to ^_UNI for building AlarmTxtShort and AlarmTxtLong"/>
		<Dokumentation Revision="1.0" Date="2016-05-13" Author="KaiAnd" Company="Sigmatek" Description="new class &quot;AlarmDisplayList&quot; (old: &quot;AlarmTemporary&quot; from KruAle; upgraded by KaiAnd)"/>
	</RevDoku>
	<Network Name="AlarmDisplayList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{1330FF43-46DA-41B9-B8EA-BAE527386023}"
				Class      = "_AlarmDisplay"
				Position   = "(810,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Acknowledge"/>
					<Server Name="ActPos"/>
					<Server Name="Delete"/>
					<Server Name="NoActive"/>
					<Server Name="Refresh"/>
					<Server Name="Server0"/>
					<Server Name="SortAlgorithm"/>
					<Client Name="Filter" Value="2#01010"/>
					<Client Name="HistoryTemporary" Value="1"/>
					<Client Name="Lse"/>
					<Client Name="MaxNo"/>
				</Channels>
			</Object>
			<Object
				Name       = "AlarmTxtLong"
				GUID       = "{208F6BFE-2253-4340-BA13-3086C0D6CDF0}"
				Class      = "String"
				Position   = "(480,810)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "AlarmTxtShort"
				GUID       = "{EF10F060-8F73-4E50-8D5A-6F46839DCA5D}"
				Class      = "String"
				Position   = "(480,660)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
			<Comment Position="(210,360)" Size="(570,150)" Text="For a description of the Filter-Client, &#13;&#10;look at the Class-Dokumentation of _AlarmDisplay (F1)"/>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(1282,210),(1110,210),"/>
			<Connection Source="this.Refresh" Destination="_base.Refresh" Vertices="(1282,270),(1110,270),"/>
			<Connection Source="this.Acknowledge" Destination="_base.Acknowledge" Vertices="(1282,390),(1110,450),"/>
			<Connection Source="this.Delete" Destination="_base.Delete" Vertices="(1282,450),(1110,510),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(810,210),(38,210),"/>
			<Connection Source="_base.MaxNo" Destination="this.MaxNo" Vertices="(810,330),(38,270),"/>
			<Connection Source="this.AlarmTxtShort" Destination="AlarmTxtShort.Data"/>
			<Connection Source="this.AlarmTxtLong" Destination="AlarmTxtLong.Data"/>
			<Connection Source="this.AlaTxtShort" Destination="AlarmTxtShort.Data" Vertices="(1282,630),(796,750),"/>
			<Connection Source="this.AlaTxtLong" Destination="AlarmTxtLong.Data" Vertices="(1282,690),(796,900),"/>
			<Connection Source="this.NoActive" Destination="_base.NoActive" Vertices="(1282,510),(1110,570),"/>
			<Connection Source="this.SortAlgorithm" Destination="_base.SortAlgorithm" Vertices="(1282,330),(1110,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _AlarmDisplay

AlarmDisplayList : CLASS
: _AlarmDisplay
  //Servers:
	HelpTxt 	: SvrCh_DINT;
	AlaTxtShort 	: SvrChCmd_UDINT;
	AlaTxtLong 	: SvrChCmd_UDINT;
  //Clients:
	ColumnChoice 	: CltChCmd__Bit32;
	coAlarmTitle 	: CltChCmd_AlarmTitleLine;
	coSystemLogging 	: CltChCmd_SystemLogging;
	AlarmTxtShort 	: CltChCmd_String;
	AlarmTxtLong 	: CltChCmd_String;
	ccAlarmChanged 	: CltChCmd_DINT;
  //Variables:
		bSetScrollOffset 	: BOOL;
		aColumnWidths : ARRAY [0..AlarmTemp_VariableNo-1] OF DINT;

		IsCon_coAlarmTitle 	: BOOL;
		IsCon_coSystemLogging 	: BOOL;
		pSingleAlarm 	: ^_SINGLEALARM;
		tmpText : ARRAY [0..599] OF _CHAR;

		txtLong : ARRAY [0..599] OF _CHAR;

		txtShort : ARRAY [0..599] OF _CHAR;

		oldHscrollPos 	: DINT;
		TimeStampHscroll 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called everytime when the input is active and a event occured&#13;&#10;&#13;&#10;ped ....... pointer to _EDITOR information&#13;&#10;pe ........ pointer to _EVENT information&#13;&#10;&#13;&#10;for the returnstatement there are 3 different possibilities&#13;&#10;_IDLE ..... the system should goon like it is (system goes on)&#13;&#10;_IDIDIT ... i did it (system is ready)&#13;&#10;_IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent"/>
	FUNCTION __CDECL VIRTUAL GLOBAL GetEvent
		VAR_INPUT
			ped 	: ^_EDITOR;			//! <Variable Comment="pointer to _EDITOR information" Name="GetEvent.ped"/>
			pe 	: ^_EVENT;			//! <Variable Comment="pointer to _EVENT information" Name="GetEvent.pe"/>
		END_VAR
		VAR_OUTPUT
			retcode (EAX) 	: _DOIT;			//! <Variable Comment="for the returnstatement there are 3 different possibilities&#13;&#10;  _IDLE ..... the system should goon like it is (system goes on)&#13;&#10;  _IDIDIT ... i did it (system is ready)&#13;&#10;  _IFAILED .. i tried to do my best, but i failed (system is ready)&#13;&#10;" Name="GetEvent.retcode"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;this method is called once right in front of drawing the object.&#13;&#10;for example open screen&#13;&#10;" Name="IF_Start"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Start
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information" Name="IF_Start.pio"/>
			firsttime 	: BOOL;			//! <Variable Comment="true: when system wants to view drawing after open screen&#13;&#10;false: when system wants to redraw background" Name="IF_Start.firsttime"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called cyclic during object is on screen&#13;&#10;&#13;&#10;pio ....... pointer to io information&#13;&#10;input .... TRUE it&apos;s an input / FALSE it&apos;s an output&#13;&#10;" Name="IF_Run"/>
	FUNCTION __CDECL VIRTUAL GLOBAL IF_Run
		VAR_INPUT
			pio 	: ^_IO;			//! <Variable Comment="pointer to _IO information given by LSE" Name="IF_Run.pio"/>
			input 	: BOOL;			//! <Variable Comment="TRUE it&apos;s an input&#13;&#10;FALSE it&apos;s an output" Name="IF_Run.input"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when redraw of a single line is necessary.&#13;&#10;ps ..... --&gt; to structure _SCROLL&#13;&#10;pr ..... --&gt; to place where line should be drawn&#13;&#10;line ... number of line which should be drawn&#13;&#10;state .. line ia selected (TRUE) or passive (FALSE)&#13;&#10;" Name="Line"/>
	FUNCTION __CDECL VIRTUAL GLOBAL Line
		VAR_INPUT
			ps 	: ^_SCROLL;			//! <Variable Comment="pointer to structure _SCROLL" Name="Line.ps"/>
			pr 	: ^_ROOM;			//! <Variable Comment="pointer to place where line should be drawn" Name="Line.pr"/>
			line 	: UINT;			//! <Variable Comment="16 bit linenumber " Name="Line.line"/>
			state 	: BOOL;			//! <Variable Comment="line is selected (true) or passive (false)" Name="Line.state"/>
		END_VAR;
	
	FUNCTION __CDECL VIRTUAL GLOBAL LineHeight
		VAR_INPUT
			preselect 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode (AX) 	: UINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;method is called every time when system wants to insert an entry into ringbuffer&#13;&#10;call this methode if you want to add an entry&#13;&#10;if you decide that entry shouldn&apos;t be added, dont call function add_SINGLEALARM() inside&#13;&#10;ptr .... --&gt; to new entry&#13;&#10;at success method returns TRUE, on the other hand FALSE&#13;&#10;" Name="AddEntry"/>
	FUNCTION __CDECL VIRTUAL GLOBAL AddEntry
		VAR_INPUT
			ptr 	: ^_SINGLEALARM;
		END_VAR
		VAR_OUTPUT
			retcode (AL) 	: BOOL;
		END_VAR;
	
	FUNCTION WriteAlarmNo
		VAR_INPUT
			uiAlarmNo 	: UINT;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteAlarmText
		VAR_INPUT
			pText 	: ^_CHAR;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteAlarmTime
		VAR_INPUT
			pAlarm 	: ^_SINGLEALARM;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteCycleNo
		VAR_INPUT
			pAlarm 	: ^_SINGLEALARM;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION WriteLine
		VAR_INPUT
			pAlarm 	: ^_SINGLEALARM;
			pRoom 	: ^_ROOM;
			sFont 	: _FONT;
			sTextColor 	: _COLOR;
			sBackColor 	: _COLOR;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL TableLines
		VAR_INPUT
			sColor 	: _COLOR;
			pRoom 	: ^_ROOM;
		END_VAR
		VAR_OUTPUT
			bSuccessful 	: BOOL;
		END_VAR;
	
	FUNCTION CalcWidth;
				//! <Function Comment="reads two alarm-texts and writes them to objects &quot;AlarmTxtShort&quot; and &quot;AlarmTxtLong&quot;" Name="SetAlarmInfo"/>
	FUNCTION GLOBAL SetAlarmInfo
		VAR_INPUT
			psa 	: ^_SINGLEALARM;			//! <Variable Comment="pointer to a SingleAlarm-object" Name="SetAlarmInfo.psa"/>
		END_VAR;
	
	FUNCTION CreateAlarmTxt
		VAR_INPUT
			psa 	: ^_SINGLEALARM;
		END_VAR;
				//! <Function Comment="calculate horizontal scroll position per column width (set position to start of next column)" Name="CalcHscrollPerColumn"/>
	FUNCTION CalcHscrollPerColumn
		VAR_OUTPUT
			retVal 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HelpTxt::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtShort::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtShort::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtLong::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AlaTxtLong::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd _Bit32
#pragma usingLtd AlarmTitleLine
#pragma usingLtd SystemLogging


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AlarmDisplayList::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ALARMDISPLAYLIST
1$UINT, 7$UINT, (SIZEOF(::AlarmDisplayList))$UINT, 
3$UINT, 6$UINT, 0$UINT, 
TO_UDINT(3279795640), "AlarmDisplayList", //Class
TO_UDINT(1738954212), "_AlarmDisplay", 0$UINT, 10$UINT, //Baseclass
//Servers:
(::AlarmDisplayList.HelpTxt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2529296776), "HelpTxt", 
(::AlarmDisplayList.AlaTxtShort.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3644404395), "AlaTxtShort", 
(::AlarmDisplayList.AlaTxtLong.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2582741885), "AlaTxtLong", 
//Clients:
(::AlarmDisplayList.ColumnChoice.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3823519998), "ColumnChoice", TO_UDINT(3745297859), "_Bit32", 0$UINT, 1$UINT, 
(::AlarmDisplayList.coAlarmTitle.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3367877714), "coAlarmTitle", TO_UDINT(718326546), "AlarmTitleLine", 1$UINT, 1$UINT, 
(::AlarmDisplayList.coSystemLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(292037947), "coSystemLogging", TO_UDINT(90452573), "SystemLogging", 1$UINT, 5$UINT, 
(::AlarmDisplayList.AlarmTxtShort.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(938161621), "AlarmTxtShort", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AlarmDisplayList.AlarmTxtLong.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1167577471), "AlarmTxtLong", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
(::AlarmDisplayList.ccAlarmChanged.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(86960371), "ccAlarmChanged", 
END_FUNCTION


#define USER_CNT_AlarmDisplayList 29

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AlarmDisplayList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AlarmDisplayList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _AlarmDisplay::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _MyIO::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _MyIO::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AlarmDisplayList;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #GetEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #IF_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #IF_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Line();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #LineHeight();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #AddEntry();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #TableLines();

#pragma warning (default : 74)
	_MyIO::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _MyIO::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HelpTxt.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HelpTxt::Write() );
	IF HelpTxt.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, AlaTxtShort.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #AlaTxtShort::Read();
	vmt.CmdTable.Write		:= #AlaTxtShort::Write();
	AlaTxtShort.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF AlaTxtShort.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, AlaTxtLong.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #AlaTxtLong::Read();
	vmt.CmdTable.Write		:= #AlaTxtLong::Write();
	AlaTxtLong.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF AlaTxtLong.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL AlarmDisplayList::Init
  
  // Methode der Basis-Klasse
  _AlarmDisplay::Init();
  
  // Horizontale Breite berechnen
  //CalcWidth();
  
  if (_FirstScan) then

    //-------------------------------------------------------------------------
    //  check client-connnections and set flags                   KaiAnd 
    //-------------------------------------------------------------------------
    if (IsClientConnected(#coSystemLogging)) then
      IsCon_coSystemLogging := TRUE;
    else
      IsCon_coSystemLogging := FALSE;
    end_if;
    if (IsClientConnected(#coAlarmTitle)) then
      IsCon_coAlarmTitle := TRUE;
    else
      IsCon_coAlarmTitle := FALSE;
    end_if;
    //-------------------------------------------------------------------------
  end_if;

  
END_FUNCTION


#pragma warning(disable:75); // disable warning in Line 939
FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::IF_Start
	VAR_INPUT
		pio 	: ^_IO;
		firsttime 	: BOOL;
	END_VAR
  
  VAR
  	pVarLabel       : ^_VARLABEL;
    tmpCounter      : USINT;
    aVarSingle      : ARRAY[0..AlarmTemp_VariableNo-1] of _VARSINGLE;
  END_VAR

  
  // Gültiger Übergabeparameter?
  if ((pio <> NIL) & (pio^.theurge <> NIL)) then
        
    //-------------------------------------------------------------------------
    // variable informations
    //-------------------------------------------------------------------------
    // check number of variables
    if (pio^.theurge^.memvarlabel.no = AlarmTemp_VariableNo) then
      
      // pointer to variable informations
      pVarLabel := pio^.theurge^.memvarlabel.ptr;
      
      // loop to store all parameter
      for tmpCounter := 0 to sizeof(aVarSingle) / sizeof(aVarSingle[0]) - 1 do
      
        // save variable informations
        aVarSingle[tmpCounter] := pVarLabel^.info[0];
        
        // check for constant
        if (aVarSingle[tmpCounter].state = CONST_VAL) then
          aColumnWidths[tmpCounter] := aVarSingle[tmpCounter].value;
        end_if;

        // step to next variable
        pVarLabel += sizeof(_VARLABEL);
        
      end_for;

    end_if;
    
  end_if;
  
  
  // Basisklasse aufrufen
  _AlarmDisplay::IF_Start(pio, firsttime);

END_FUNCTION
#pragma warning(default:75); 


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::IF_Run
	VAR_INPUT
		pio 	: ^_IO;
		input 	: BOOL;
	END_VAR

  //-----------------------------------------------------------------------------------------
  // reset mark if it's to high     KaiAnd, V.1.3
  //-----------------------------------------------------------------------------------------
  if (Scroll.position.pos+1 > Scroll.position.no) then
    Scroll.position.pos := -1;
    Out(pio);     // draw!
  end_if;

  //-----------------------------------------------------------------------------------------
  // Prüfen ob sich die Auswahl der Spalten geändert hat
  //-----------------------------------------------------------------------------------------
  if ColumnChoice <> ColumnChoice.Read() then
    
    ColumnChoice := ColumnChoice.Read();  // Konfiguration speichern
    CalcWidth();                          // neue horizontale Breite berechnen
    Scroll.hposition.pos := 0;            // horizontale Position wieder rücksetzen
    Out(pio);                             // neu zeichnen
    
  end_if;

  //-----------------------------------------------------------------------------------------
  // Basisklasse aufrufen
  //-----------------------------------------------------------------------------------------
  _AlarmDisplay::IF_Run(pio:=pio, input:=input);

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::Line
	VAR_INPUT
		ps 	: ^_SCROLL;
		pr 	: ^_ROOM;
		line 	: UINT;
		state 	: BOOL;
	END_VAR
  VAR
    tmpTextColor  : _COLOR;
    tmpBgColor    : _COLOR;
    tmpAlarm      : ^_SINGLEALARM;
    tmpLSEAlarm   : ^_SINGLE_ALARM;
    tmpNumber     : UINT; 
  END_VAR
  
  // Übergabeparameter prüfen
  if ((ps = NIL) | (pr = NIL)) then
    return;
  end_if;

  //-----------------------------------------------------------------------------------------
  // check if Scroll-Horizontal has changed                               KaiAnd, V.1.4
  //-----------------------------------------------------------------------------------------
  if (Scroll.hposition.pos <> oldHscrollPos) then
    Scroll.hposition.pos := calcHscrollPerColumn();    // scroll per column-width
    oldHscrollPos        := Scroll.hposition.pos;
  end_if;
  //-----------------------------------------------------------------------------------------


  // Anzahl der Einträge in Ringbuffer lesen
  tmpNumber := TO_UINT(no_RINGBUFFER(#Pms^.ringbuffer)); 

  // KaiAnd V.1.0: reset scroll if no Alarm in list
  if(tmpNumber <= 0) then
    ps^.hposition.begin := 0;
    ps^.hposition.pos   := 0;
    if (IsCon_coAlarmTitle = True) then    // KaiAnd
      coAlarmTitle.setActLineBegin(NewScrollOffset := pr^.xy1.x);
    end_if;
  end_if;

  //-----------------------------------------------------------------------------------------
  // write the line ...
  //-----------------------------------------------------------------------------------------
  if(line < tmpNumber) then

    // an oberster Stelle der aktuellste Alarm
    line := tmpNumber - line - 1; 
    
    // Pointer zu Alarm bilden
    tmpAlarm := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, line) * sizeof(_SINGLEALARM)); 
    
    // Pointer zu LSE-Informationen von Alarm bilden
    tmpLSEAlarm := get_ANYTHING(x0  := #tmpAlarm^.anything, 
                                x1  := NIL)$^_SINGLE_ALARM;
    
    //-------------------------------------------------------------------------
    // Prüfen ob Informationen verfügbar
    if (tmpAlarm <> NIL) then
    
      //-----------------------------------------------------------------------
      // Prüfen ob Alarm in LSE verfügbar
      if (tmpLSEAlarm <> NIL) then
          
        if (state) then
          
          tmpTextColor := GetPenColor(x0 := ps^.color_activ);
          tmpBgColor   := GetBackColor(x0 := ps^.color_activ);

        else
          // Alarm ist aktiv
          if (tmpAlarm^.state = true) then
            
            // Alarm wurde quittiert
            if (tmpAlarm^.acknowledge = true) then
              tmpTextColor := GetPenColor(x0 := tmpLSEAlarm^.quit_active); 
              tmpBgColor   := GetBackColor(x0 := tmpLSEAlarm^.quit_active);
            // Alarm wurde nicht quittiert
            else
              tmpTextColor := GetPenColor(x0 := tmpLSEAlarm^.active); 
              tmpBgColor   := GetBackColor(x0 := tmpLSEAlarm^.active);
            end_if;

            
          // Alarm ist nicht aktiv
          else
            
            // Alarm wurde quittiert
            if (tmpAlarm^.acknowledge = true) then
              tmpTextColor  := GetPenColor(x0 := tmpLSEAlarm^.quit_passive);
              tmpBgColor  := GetBackColor(x0 := tmpLSEAlarm^.quit_passive);
            // Alarm wurde nicht quittiert
            else
              tmpTextColor  := GetPenColor(x0 := tmpLSEAlarm^.passive);
              tmpBgColor  := GetBackColor(x0 := tmpLSEAlarm^.passive); 
            end_if;
            
          end_if;
        end_if;

      //-----------------------------------------------------------------------
      // Alarm im LSE nicht definiert
      else
      
        if (state) then
          tmpTextColor := GetPenColor(x0 := ps^.color_activ);
          tmpBgColor   := GetBackColor(x0 := ps^.color_activ);
        else
          tmpTextColor := ALARMTEMP_SELECTEDCOLOR;
          tmpBgColor   := GetBackColor(x0 := ps^.color_inactiv);
        end_if;
      
      end_if;

      
      //-----------------------------------------------------------------------
      // Zeile schreiben
      if WriteLine(pAlarm     := tmpAlarm, 
                   pRoom      := pr, 
                   sFont      := ps^.font, 
                   sTextColor := tmpTextColor, 
                   sBackColor := tmpBgColor) = false then 
        
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("AlarmDisplayList::Line(): Schreiben der Alarmzeile fehlgeschlagen");
        end_if;
      
      end_if;
      
      //-----------------------------------------------------------------------
      // Farbe für Unterteilung bestimmen
      
      //tmpTextColor := Graphic.MakeColor(fgcol := ps^.frame_out, 
      //                                  bgcol := tmpBgColor); 
      
      tmpTextColor := ps^.color_activ;  // KaiAnd V.1.0: change line-color (old version will not work)

      //-----------------------------------------------------------------------
      // Zeilenunterteilung zeichnen
      if (TableLines(sColor:=tmpTextColor, pRoom:=pr) = false) then
        if (IsCon_coSystemLogging = True) then    // KaiAnd
          coSystemLogging.LogEventText("AlarmDisplayList::Line(): Zeichnen der Zeilenunterteilung fehlgeschlagen");
        end_if;
      else
        if (bSetScrollOffset = false) then
          bSetScrollOffset := true;
          // Aktuellen Zeilenbeginn für TitleLine speichern
          if (IsCon_coAlarmTitle = True) then    // KaiAnd
            coAlarmTitle.setActLineBegin(NewScrollOffset := pr^.xy1.x);
          end_if;
        end_if;
      end_if;

    //-------------------------------------------------------------------------
    // Alarm ist nicht definiert
    else
      if (IsCon_coSystemLogging = True) then    // KaiAnd
        coSystemLogging.LogEventText("AlarmDisplayList::Line(): keine Informationen zum Alarm verfügbar");
      end_if;

    end_if;
    
    //-------------------------------------------------------------------------
    // Rahmen erneut zeichnen
    DrawButton(#ps^.out_room, T_FILL or T_COPY or T_SOLID, ps^.frametype, INVISIBLE, ps^.frame_out);
    
    //-------------------------------------------------------------------------

  end_if; 

END_FUNCTION


FUNCTION AlarmDisplayList::WriteAlarmNo
	VAR_INPUT
		uiAlarmNo 	: UINT;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpText : ARRAY[0..10] OF _CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if (pRoom = NIL) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  // Alarmnummer zu Zahl wandeln
  DToA(p0:=#tmpText[0], x1:=uiAlarmNo, x2:=ALARMTEMP_CONFIGALARMNO, x3:=sizeof(tmpText[0]));
        
  // Text ausgeben
  OutTextAlign(p0 := #tmpText[0], 
               x1 := 0, 
               p1 := pRoom, 
               x2 := sFont, 
               x3 := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRALARMNO, 
               x9 := _DEFFRAME, 
               x4 := sTextColor, 
               x5 := sBackColor, 
               x6 := sBackColor, 
               x7 := sizeof(tmpText[0]));
  
END_FUNCTION


FUNCTION AlarmDisplayList::WriteAlarmTime
	VAR_INPUT
		pAlarm 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpRoom : _ROOM;
  	tmpDate : _DATE;
    tmpTime : _TIME;
    tmpText : ARRAY [0..100] OF _CHAR;
    tmpHelp : ARRAY [0..50] OF _CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pAlarm = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
  
  
  //-------------------------------------------------------------------------
  // Datum + Zeit gekommen
  //-------------------------------------------------------------------------
  
  // Platz berechnen
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy2.x;
  
  // WesAnd v1.5 --------------------------------------------------  
  if (Filter AND BIT_ONOFF) then
    // Datum + Zeit gegangen anzeigen
    tmpRoom.xy2.y := pRoom^.xy1.y + to_int(Scroll.line_height) / 2;
  else
    // Datum + Zeit gegangen nicht anzeigen
    tmpRoom.xy2.y := pRoom^.xy2.y;
  end_if;
  // WesAnd v1.5 -------------------------------------------------- 
  
  // Datum wandeln
  lasal_to_DATE(p0:=#tmpDate, x1:=pAlarm^.date_on);
                
  // String erzeugen
  format_date(p0:=#tmpHelp[0], p1:=#tmpDate, x2:=SIZE_DDMMYY);
              
  // String anfügen
  StrNCpy(p0:=#tmpText[0], x1:=sizeof(tmpText[0]), p2:=#tmpHelp[0], x3:=sizeof(tmpHelp[0]), ml:=sizeof(tmpText)/sizeof(_CHAR));
  
  // Seperator einfügen
  StrCat(p0:=#tmpText[0], x1:=sizeof(_CHAR), p2:="  ", x3:=sizeof(CHAR));
          
  // Zeit wandeln
  lasal_to_TIME(p0:=#tmpTime, x1:=pAlarm^.time_on);
  
  // String erzeugen
  format_time(p0:=#tmpHelp[0], p1:=#tmpTime, x2:=SIZE_HHMMSS);
              
  // String anfügen
  StrCat(p0:=#tmpText[0], x1:=sizeof(tmpText[0]), p2:=#tmpHelp[0], x3:=sizeof(tmpHelp[0]));
          
  // Datum + Zeit gekommen ausgeben
  OutTextAlign(p0 := #tmpText[0], 
               x1 := 0, 
               p1 := #tmpRoom, 
               x2 := sFont,
               x3 := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRTIME,
               x9 := _DEFFRAME,
               x4 := sTextColor,
               x5 := sBackColor,
               x6 := sBackColor,
               x7 := sizeof(tmpText[0]));
                
  
  //-------------------------------------------------------------------------
  // Datum + Zeit gegangen
  //-------------------------------------------------------------------------
  
  if (Filter AND BIT_ONOFF) then  // WesAnd v1.5
    // Datum + Zeit gegangen anzeigen
    // Platz berechnen
    tmpRoom.xy1.x := pRoom^.xy1.x;
    tmpRoom.xy1.y := pRoom^.xy1.y + to_int(Scroll.line_height) / 2;
    tmpRoom.xy2.x := pRoom^.xy2.x;
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Alarm noch aktiv
    //---------------------------------------------
    if (pAlarm^.state) then
    
      StrCpy(p0:= #tmpText[0], x1:= sizeof(_CHAR), p2:= "  --.--.--     --:--:-- ", x3:= sizeof(CHAR));
              
    // Alarm bereits weg
    //---------------------------------------------
    else
      
      // Datum wandeln
      lasal_to_DATE(p0:=#tmpDate, x1:=pAlarm^.date_off);
                    
      // String erzeugen
      format_date(p0:=#tmpHelp[0], p1:=#tmpDate, x2:=SIZE_DDMMYY);
                  
      // String anfügen
      StrNCpy(p0:=#tmpText[0], x1:=sizeof(tmpText[0]), p2:=#tmpHelp[0], x3:=sizeof(tmpHelp[0]), ml:=sizeof(tmpText)/sizeof(_CHAR));
    
      // Seperator einfügen
      StrCat(p0:=#tmpText[0], x1:=sizeof(_CHAR), p2:="  ", x3:=sizeof(CHAR));
                  
      // Zeit wandeln
      lasal_to_TIME(p0:=#tmpTime, x1:=pAlarm^.time_off);
      
      // String erzeugen
      format_time(p0:=#tmpHelp[0], p1:=#tmpTime, x2:=SIZE_HHMMSS);
                  
      // String anfügen
      StrCat(p0:=#tmpText[0], x1:=sizeof(tmpText[0]), p2:=#tmpHelp[0], x3:=sizeof(tmpHelp[0]));
      
    end_if;
            
    // Datum + Zeit gekommen ausgeben
    OutTextAlign(p0 := #tmpText[0], 
                 x1 := 0, 
                 p1 := #tmpRoom, 
                 x2 := sFont,
                 x3 := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRTIME,
                 x9 := _DEFFRAME,
                 x4 := sTextColor,
                 x5 := sBackColor,
                 x6 := sBackColor,
                 x7 := sizeof(tmpText[0]));
                 
  end_if; // WesAnd v1.5

  //-------------------------------------------------------------------------

END_FUNCTION


FUNCTION AlarmDisplayList::WriteCycleNo
	VAR_INPUT
		pAlarm 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpText : ARRAY[0..11] OF _CHAR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pAlarm = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;


  //-------------------------------------------------------------------------
  // Wert ausgeben
  //-------------------------------------------------------------------------

  // Wert zu Zahl wandeln
  if (pAlarm^.no_para > 0) then  // KaiAnd V.1.0: nur wenn Para vorhanden
  
    DToA(p0:=#tmpText[0], x1:=pAlarm^.para[pAlarm^.no_para - 1], x2:=ALARMTEMP_CONFIGCYCLENO, x3:=sizeof(tmpText[0]));
        
  else        // KaiAnd V.1.0: wenn KEIN Para vorhanden, dann LZ ausgeben
    tmpText[0] := ' ';
    tmpText[1] := 0;
  end_if;

  // Text ausgeben
  OutTextAlign(p0 := #tmpText[0], 
               x1 := 0, 
               p1 := pRoom, 
               x2 := sFont, 
               x3 := ALARMTEMP_ATTRSTANDARD OR ALARMTEMP_ATTRCYCLENO, 
               x9 := _DEFFRAME, 
               x4 := sTextColor, 
               x5 := sBackColor, 
               x6 := sBackColor, 
               x7 := sizeof(tmpText[0]));

  //-------------------------------------------------------------------------
  
END_FUNCTION


FUNCTION AlarmDisplayList::WriteAlarmText
	VAR_INPUT
		pText 	: ^_CHAR;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR

  // Übergabeparameter prüfen
  if (pRoom = NIL) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;
 
  // Prüfen ob Text verfügbar
  if (pText = NIL) then
     
    // Infotext bauen, dass kein Text verfügbar ist - HubChr hardcoded source string is always ascii size=1
    StrNCpy(p0:=#tmpText[0], x1:=sizeof(_CHAR), p2:=" ALARM IS NOT DEFINED IN LSE", x3:=1, ml:=sizeof(tmpText)/sizeof(_CHAR));
  
    pText := #tmpText[0];

  else
    // shift text in order to put a BLANK in front of the text  HubChr V.1.0
    StrNCpy(p0:=#tmpText[1], x1:= sizeof(_CHAR), p2:= pText, x3:= sizeof(_CHAR), ml:= sizeof(tmpText)/sizeof(_CHAR));

    tmpText[0] := ' '; // put BLANK in first character

    pText := #tmpText[0];

  end_if;

  // Text output - HubChr v1.5 changed to OutMultiTextAlign to support output of multiple lines (use "|")
  OutMultiTextAlign(p0 := pText, 
                    x1 := 0, 
                    p2 := pRoom, 
                    x3 := sFont, 
                    x4 := ALARMTEMP_ATTRTEXT, 
                    x5 := _DEFFRAME, 
                    x6 := sTextColor, 
                    x7 := sBackColor, 
                    x8 := sBackColor, 
                    x9 := sizeof(pText^));
    
END_FUNCTION


FUNCTION AlarmDisplayList::WriteLine
	VAR_INPUT
		pAlarm 	: ^_SINGLEALARM;
		pRoom 	: ^_ROOM;
		sFont 	: _FONT;
		sTextColor 	: _COLOR;
		sBackColor 	: _COLOR;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
  	tmpRoom   : _ROOM;
    tmpText   : ^_CHAR;
    tmpColor  : _COLOR;
  END_VAR

  // Übergabeparameter prüfen
  if ((pAlarm = NIL) | (pRoom = NIL)) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;

  // Platz definieren
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy2.x;
  tmpRoom.xy2.y := pRoom^.xy2.y;

  //---------------------------------------------------------------------------
  // vorerst komplette Zeile färben   KaiAnd
  //---------------------------------------------------------------------------
  Graphic.Beam(x1:=tmpRoom.xy1.x, y1:=tmpRoom.xy1.y, 
               x2:=tmpRoom.xy2.x, y2:=tmpRoom.xy2.y, 
               attrib:=T_SOLID, color:=sBackColor);

  //---------------------------------------------------------------------------
  // einzelne Spalten füllen
  //---------------------------------------------------------------------------

  //-----------------------------------------------------------------------
  // Alarmnummer schreiben
  //-----------------------------------------------------------------------
  if (ColumnChoice AND 2#1000) then
    // Platz für Alarmnummer bestimmen
    tmpRoom.xy1.x := pRoom^.xy1.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[0]);
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Alarmcode ausgeben
    if (WriteAlarmNo(uiAlarmNo  := pAlarm^.no, 
                     pRoom      := #tmpRoom, 
                     sFont      := sFont, 
                     sTextColor := sTextColor, 
                     sBackColor := sBackColor) = false) then
      bSuccessful := false;
    end_if;
  else
    tmpRoom.xy2.x := tmpRoom.xy1.x; // HubChr v1.2 First column as 0-width - this step is necessary so following columns have a valid start coordinate.
  end_if;
  
  
  //-----------------------------------------------------------------------
  // Zeit gekommen / gegangen
  //-----------------------------------------------------------------------
  if (ColumnChoice AND 2#0100) then
    // Platz für Zeit gekommen /  gegangen bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[1]);
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Zeit gekommen / gegangen ausgeben
    if (WriteAlarmTime(pAlarm     := pAlarm, 
                       pRoom      := #tmpRoom,
                       sFont      := sFont,
                       sTextColor := sTextColor, 
                       sBackColor := sBackColor) = false) then
      bSuccessful := false; 
    end_if;
  end_if;
  

  //-----------------------------------------------------------------------
  // Zyklusnummer (KaiAnd: real "Para1")
  //-----------------------------------------------------------------------
  if (ColumnChoice AND 2#0010) then
    // Platz für Zyklusnummer bestimmen
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[2]);
    tmpRoom.xy2.y := pRoom^.xy2.y;

//  if (pAlarm^.no_para > 0) then   // leiChr Abfrage -> sonst BoundExceed
    if (pAlarm^.no_para >= 0) then  // KaiAnd V.1.0: Abfrage/Auswertung erfolgt in WriteCycleNo()
      if (WriteCycleNo(pAlarm     := pAlarm, 
                       pRoom      := #tmpRoom,
                       sFont      := sFont,
                       sTextColor := sTextColor, 
                       sBackColor := sBackColor) = false) then
        bSuccessful := false; 
      end_if;
    end_if;
  end_if;
  
  
  //-----------------------------------------------------------------------
  // Alarmtext
  //-----------------------------------------------------------------------
  if (ColumnChoice AND 2#0001) then
    // Platz für Alarmtext
    tmpRoom.xy1.x := tmpRoom.xy2.x;
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := tmpRoom.xy1.x + to_int(aColumnWidths[3]);
    tmpRoom.xy2.y := pRoom^.xy2.y;
    
    // Alarmtext bestimmen
    tmpText := create_alarmtext(p0:=pAlarm, x1:=false, p2:=#tmpColor);
    
    // Alarmtext ausgeben
    if (WriteAlarmText(pText      := tmpText, 
                       pRoom      := #tmpRoom, 
                       sFont      := sFont, 
                       sTextColor := sTextColor, 
                       sBackColor := sBackColor) = false) then
      bSuccessful := false; 
    end_if;
  end_if;

  //-----------------------------------------------------------------------

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::LineHeight
	VAR_INPUT
		preselect 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode (AX) 	: UINT;
	END_VAR

  // doppelte Höhe der Zeile
  retcode := 2 * preselect;
  
END_FUNCTION


FUNCTION VIRTUAL AlarmDisplayList::TableLines
	VAR_INPUT
		sColor 	: _COLOR;
		pRoom 	: ^_ROOM;
	END_VAR
	VAR_OUTPUT
		bSuccessful 	: BOOL;
	END_VAR
  VAR
    tmpRoom   : _ROOM;
  END_VAR
  
  
  // Übergabeparameter prüfen
  if (pRoom = NIL) then
    bSuccessful := false;
    return;
  else
    bSuccessful := true;
  end_if;  
  
  // Platz definieren
  tmpRoom.xy1.x := pRoom^.xy1.x;
  tmpRoom.xy1.y := pRoom^.xy1.y;
  tmpRoom.xy2.x := pRoom^.xy1.x;
  tmpRoom.xy2.y := pRoom^.xy2.y;
  
  //-----------------------------------------------------------------------
  // Trennline zwischen Alarmnummer und Zeit
  //-----------------------------------------------------------------------
  // Prüfen ob Trennline dargestellt werden soll
  if (ColumnChoice AND 2#1000) then
    // Koordinaten bestimmen
    tmpRoom.xy1.x := pRoom^.xy1.x + to_int(aColumnWidths[0]);
    tmpRoom.xy1.y := pRoom^.xy1.y;
    tmpRoom.xy2.x := pRoom^.xy1.x + to_int(aColumnWidths[0]);
    tmpRoom.xy2.y := pRoom^.xy2.y;

    Graphic.Line(x1     := tmpRoom.xy1.x, 
                 y1     := tmpRoom.xy1.y, 
                 x2     := tmpRoom.xy2.x, 
                 y2     := tmpRoom.xy2.y, 
                 attrib := T_SOLID, 
                 color  := sColor);
  end_if;
  
  //-----------------------------------------------------------------------
  // Trennline zwischen Zeit und Zyklusnummer
  //-----------------------------------------------------------------------
  // Prüfen ob Trennline dargestellt werden soll
  if (ColumnChoice AND 2#0100) then
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(aColumnWidths[1]);
    tmpRoom.xy2.x += to_int(aColumnWidths[1]);

    Graphic.Line(x1     := tmpRoom.xy1.x, 
                 y1     := tmpRoom.xy1.y, 
                 x2     := tmpRoom.xy2.x, 
                 y2     := tmpRoom.xy2.y, 
                 attrib := T_SOLID, 
                 color  := sColor);
  end_if;
  
  //-----------------------------------------------------------------------
  // Trennline zwischen Zyklusnummer und Beschreibung
  //-----------------------------------------------------------------------
  // Prüfen ob Trennline dargestellt werden soll
  if (ColumnChoice AND 2#0010) then
    // Koordinaten bestimmen
    tmpRoom.xy1.x += to_int(aColumnWidths[2]);
    tmpRoom.xy2.x += to_int(aColumnWidths[2]);

    Graphic.Line(x1     := tmpRoom.xy1.x, 
                 y1     := tmpRoom.xy1.y, 
                 x2     := tmpRoom.xy2.x, 
                 y2     := tmpRoom.xy2.y, 
                 attrib := T_SOLID, 
                 color  := sColor);
  end_if;
  
  //-----------------------------------------------------------------------
  // Trennline zwischen den Zeilen
  //-----------------------------------------------------------------------
  Graphic.Line(x1     := pRoom^.xy1.x, 
               y1     := pRoom^.xy2.y, 
               x2     := pRoom^.xy2.x, 
               y2     := pRoom^.xy2.y, 
               attrib := T_SOLID, 
               color  := sColor);
  
  //-----------------------------------------------------------------------

END_FUNCTION


FUNCTION AlarmDisplayList::CalcWidth
  
  // Breite der Zeile berechnen
  //--------------------------------------------------------------------------------------------
  // Konfiguration der Spalten lesen
  ColumnChoice := ColumnChoice.Read();
  
  LineWidth := 0;
  
  // Nummer
  if (ColumnChoice AND 2#1000) then
    LineWidth += aColumnWidths[0];
  end_if;

  // Zeit
  if (ColumnChoice AND 2#0100) then
    LineWidth += aColumnWidths[1];
  end_if;
  
  // Zyklusnummer
  if (ColumnChoice AND 2#0010) then
    LineWidth += aColumnWidths[2];
  end_if;
  
  // Beschreibung
  if (ColumnChoice AND 2#0001) then
    LineWidth += aColumnWidths[3];
  end_if;
  
END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::GetEvent
	VAR_INPUT
		ped 	: ^_EDITOR;
		pe 	: ^_EVENT;
	END_VAR
	VAR_OUTPUT
		retcode (EAX) 	: _DOIT;
	END_VAR

  // Methode der Basis-Klasse
  retcode := _AlarmDisplay::GetEvent(ped, pe);
  
  // ScrollOffset wieder zum setzen freigeben
  bSetScrollOffset := false;
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::HelpTxt::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
    psa   : ^_SINGLEALARM; 
    line : dint;
    no    : DINT; 
  END_VAR
  
  no := TO_DINT(no_RINGBUFFER(#Pms^.ringbuffer)); 

  if(Scroll.position.pos < no) then
    
    line := no - Scroll.position.pos - 1; 

    psa := Pms^.ptr + (rpos_RINGBUFFER(#Pms^.ringbuffer, to_udint(line)) * sizeof(_SINGLEALARM)); 
    
    SetAlarmInfo(psa:=psa);   //  KaiAnd V.1.0 ... Methode nun integriert 

  else
    SetAlarmInfo(psa:=NIL);   //  KaiAnd V.1.0 ... Methode nun integriert 
    
  end_if;
    
	result := input := HelpTxt;

END_FUNCTION


FUNCTION GLOBAL AlarmDisplayList::SetAlarmInfo
//  KaiAnd V.1.0 ... Methode integriert (vormals via Objekt-Kanal auf AlarmHelpTxt)
	VAR_INPUT
		psa 	: ^_SINGLEALARM;
	END_VAR
  
  pSingleAlarm := psa;
  
  CreateAlarmTxt(pSingleAlarm);

END_FUNCTION

FUNCTION AlarmDisplayList::CreateAlarmTxt
//  KaiAnd V.1.0 ... Methode integriert (vormals via Objekt-Kanal auf AlarmHelpTxt)
	VAR_INPUT
		psa 	: ^_SINGLEALARM;
	END_VAR
  VAR
  	pTxtShort : ^_char;
    pTxtLong  : ^_char;
    tmpColor  : _COLOR;
    tmplength : udint;
  END_VAR
  
  if (psa = NIL) then
  
    StrCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));  
    StrCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
  
  else
  
    // Alarmtext short bestimmen
    pTxtShort := create_alarmtext(p0:=psa, x1:=FALSE, p2:=#tmpColor);
                                  
    if (pTxtShort <> NIL) then
      StrNCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=pTxtShort, x3:=sizeof(_char), ml := sizeof(txtShort)/sizeof(_CHAR));
    else
      StrCpy(p0:=#txtShort[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
    end_if;
    
    
    // Alarmtext long bestimmen
    pTxtLong := create_alarmtext(p0:=psa, x1:=TRUE, p2:=#tmpColor);
    
    if (pTxtLong <> NIL) then                              
      StrNCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=pTxtLong, x3:=sizeof(_char), ml := sizeof(txtLong)/sizeof(_CHAR));
    else
      StrCpy(p0:=#txtLong[0], x1:=sizeof(_char), p2:=" ", x3:=sizeof(char));
    end_if;
    
  end_if;
  
  tmplength := StrLen(txt:=#txtShort[0], size:=sizeof(_CHAR));
  AlarmTxtShort.WriteDataOffUni(udlen:=(tmplength+1)*2, udOff:=0, pData:=(#txtShort[0])$^_UNI, usSize:=sizeof(_CHAR)); // V.1.1: cast to ^_UNI
  
  tmplength := StrLen(txt:=#txtLong[0], size:=sizeof(_CHAR));
  AlarmTxtLong.WriteDataOffUni(udlen:=(tmplength+1)*2, udOff:=0, pData:=(#txtLong[0])$^_UNI, usSize:=sizeof(_CHAR));  // V.1.1: cast to ^_UNI
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtShort::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	AlaTxtShort := AlarmTxtShort.Data.Read();
	output := AlaTxtShort;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtShort::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	AlaTxtShort := input;
	result := (AlarmTxtShort.Data.Write(AlaTxtShort))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtLong::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	AlaTxtLong := AlarmTxtLong.Data.Read();
	output := AlaTxtLong;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AlarmDisplayList::AlaTxtLong::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	AlaTxtLong := input;
	result := (AlarmTxtLong.Data.Write(AlaTxtLong))$UDINT;

END_FUNCTION


FUNCTION __CDECL VIRTUAL GLOBAL AlarmDisplayList::AddEntry
	VAR_INPUT
		ptr 	: ^_SINGLEALARM;
	END_VAR
	VAR_OUTPUT
		retcode (AL) 	: BOOL;
	END_VAR
  VAR
	  NiGive	:	CmdStruct;
  	NiGet		:	Results;
  END_VAR
 
  // share the changed alarm
  if (IsClientConnected(#ccAlarmChanged)) then

    NiGive.uiCmd := 1;
    NiGive.aPara[0] := (ptr)$DINT;
    ccAlarmChanged.NewInst(#NiGive, #NiGet);

  end_if;

  // call the base function
  retcode := _AlarmDisplay::AddEntry(ptr:=ptr);

END_FUNCTION


FUNCTION AlarmDisplayList::CalcHscrollPerColumn
	VAR_OUTPUT
		retVal 	: DINT;
	END_VAR
  VAR
    myHscrollWaitTime : UDINT;
    myMaxNoColumn     : DINT;
  	myBitMask         : BDINT;
    myNewHpos         : DINT;
    myPxOffset        : DINT;
    i                 : DINT;
  END_VAR

  myHscrollWaitTime := 200; // Waittime between 2 Hscroll-Events [ms] for debounce
  myMaxNoColumn     := 4;   // max.No of Columns
  myPxOffset        := 1;   // 1 px offset for nicer optics

  // debouncing (DE: Entprellen) of the scroll events
  if ((ops.tAbsolute - TimeStampHscroll) < myHscrollWaitTime) then

    myNewHpos := oldHscrollPos;

  else
  
    TimeStampHscroll := ops.tAbsolute;

    CalcWidth();
  
    // set position to the start of next column forward
    if (Scroll.hposition.pos > oldHscrollPos) then

      myNewHpos := 0;             // start with min.
      myBitMask := 2#1 SHL (myMaxNoColumn -1); // set Bit x
   
      // forward loop for all columns (but not the last one)
      for i:=0 to (myMaxNoColumn-1 -1) do
    
        if (ColumnChoice AND myBitMask) then
          myNewHpos += aColumnWidths[i];
          if (myNewHpos > oldHscrollPos) then
            exit;
          end_if;
        end_if;
        myBitMask /= 2;           // next bit

      end_for;

    // set position to the start of next column backward
    elsif (Scroll.hposition.pos < oldHscrollPos) then

      myNewHpos := LineWidth;     // start with max. (got from CalcWidth()-function)
      myBitMask := 2#00000001;    // set Bit 0
   
      // backward loop for all columns
      for i:=(myMaxNoColumn -1) to 0 by -1 do
    
        if (ColumnChoice AND myBitMask) then
          myNewHpos -= aColumnWidths[i];
          if ((myNewHpos + myPxOffset) < oldHscrollPos) then   
            exit;
          end_if;
        end_if;
        myBitMask *= 2;           // next bit

      end_for;

    else
    
      myNewHpos := oldHscrollPos - myPxOffset;

    end_if;

    if (myNewHpos <= 0) then
      myNewHpos := 0;
    else
      myNewHpos += myPxOffset;
    end_if;

  end_if;   // (check TimeStamp)

  retVal := myNewHpos;

END_FUNCTION
