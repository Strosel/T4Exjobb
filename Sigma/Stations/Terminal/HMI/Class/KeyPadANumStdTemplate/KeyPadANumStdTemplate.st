//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define KEY_LAYOUT_LINE_1   2#11111111110
#define KEY_LAYOUT_LINE_2   2#11111111110
#define KEY_LAYOUT_LINE_3   2#01111111110
#define KEY_LAYOUT_LINE_4   2#00000000111

#define KEYPAD_ANUM_BUTTON_WIDTH      60
#define KEYPAD_ANUM_BUTTON_HEIGHT     60

#define KEYPAD_ANUM_BUTTON_XOFF       5
#define KEYPAD_ANUM_BUTTON_YOFF       85


#define KEYPAD_ANUM_WIDTH             680
#define KEYPAD_ANUM_HEIGHT            350


#define KEYPAD_ANUM_INPUT_XOFF        5
#define KEYPAD_ANUM_INPUT_YOFF        45
#define KEYPAD_ANUM_INPUT_HEIGHT      30

#define KEYPAD_ANUM_TITLE_XOFF        5
#define KEYPAD_ANUM_TITLE_YOFF        5
#define KEYPAD_ANUM_TITLE_HEIGHT      30

#define KEYPAD_ANUM_ESC_WIDTH         30
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "KeyPadANumStdTemplate"
	Revision           = "2.0"
	GUID               = "{8254FBAE-5118-47E0-85A3-4165B6A13265}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\KeyPadANumStdTemplate\KeyPad.ico"
	SharedCommandTable = "true"
	Objectsize         = "(540,360)">
	<Channels>
		<Client Name="Graphic" Required="false" Internal="false"/>
		<Client Name="KeyPadImg" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="Matthias Schuiki"/>
		<Dokumentation Revision="2.0" Date="2017-07-12" Author="BalKar&#13;&#10;KaiAnd" Company="Sigmatek" Description="implemented &quot;arrow left&quot; and &quot;arrow right&quot; buttons for positioning the cursor within the input string&#13;&#10;implemented Insert-Button"/>
		<Dokumentation Revision="1.0" Date="2016-05-09" Author="Matthias Schuiki" Company="Sigmatek" Description="release"/>
	</RevDoku>
	<Network Name="KeyPadANumStdTemplate">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{F4505D9D-D9D1-4970-B163-1197B6B0BAD7}"
				Class      = "_Screen"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Screen"/>
					<Client Name="ImA" Value="IMA_WINDOW"/>
					<Client Name="Lse"/>
					<Client Name="No" Value="_WIN_EDITOR_ANUMERIC"/>
				</Channels>
			</Object>
			<Object
				Name       = "KeyPadImg"
				GUID       = "{283DB3C2-CDD9-458F-9ECE-42191854ECB0}"
				Class      = "KeyPadImagesStdTemplate"
				Position   = "(240,420)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Screen" Destination="_base.Screen" Vertices="(712,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.No" Destination="this.No" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.ImA" Destination="this.ImA" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.KeyPadImg" Destination="KeyPadImg.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Screen

KeyPadANumStdTemplate : CLASS
: _Screen
	TYPE
	  _LayoutType :
	  (
	    _LayoutLetter,
	    _LayoutSymbol
	  )$UDINT;
	  _ShiftMode :
	  (
	    _Shift_0,
	    _Shift_1,
	    _Shift_2
	  )$UDINT;
	  _SymbolMode :
	  (
	    _Symbol_1,
	    _Symbol_2
	  )$UDINT;
	END_TYPE
  //Servers:
  //Clients:
	Graphic 	: CltChCmd_Graphic;
	KeyPadImg 	: CltChCmd_KeyPadImagesStdTemplate;
  //Variables:
		DoneByProgram 	: BOOL;
		KeyButton_XOff 	: INT;
		KeyButton_YOff 	: INT;
		KeyButton_Width 	: INT;
		KeyButton_Height 	: INT;
		SymbolMode 	: _SymbolMode;
		ShiftMode 	: _ShiftMode;
		pDefkeypad 	: ^_DEFKEYPAD;
		KeyPad_Width 	: INT;
		KeyPad_Height 	: INT;
		LayoutType 	: _LayoutType;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL S_Run
		VAR_INPUT
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL S_Start
		VAR_INPUT
			pic 	: ^void;
			firsttime 	: BOOL;
		END_VAR;
				//! <Function Comment="method is used to create screen/window by program (without lse)&#13;&#10;kernel will call method only if screen/window is not present in lse-project" Name="S_CreateNew"/>
	FUNCTION VIRTUAL GLOBAL S_CreateNew
		VAR_INPUT
			psetup 	: ^_NEWSCREENPROP;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION SelectKeyboard
		VAR_OUTPUT
			out_pKeyTab 	: ^USINT;
		END_VAR;
	
	FUNCTION IsUnicodeKeyboard
		VAR_INPUT
			in_pKeyTab 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			out_bUnicode 	: BOOL;
		END_VAR;
	
	FUNCTION TAB KeyTab_QWERTZ;
	
	FUNCTION FillButtons_LetterSmall
		VAR_INPUT
			pic 	: ^void;
		END_VAR;
	
	FUNCTION FillButtons_Symbol1
		VAR_INPUT
			pic 	: ^void;
		END_VAR;
	
	FUNCTION FillButtons_LetterBig
		VAR_INPUT
			pic 	: ^void;
		END_VAR;
	
	FUNCTION FillButtons_Symbol2
		VAR_INPUT
			pic 	: ^void;
		END_VAR;
	
	FUNCTION TAB KeyTab_QWERTY;
	
	FUNCTION TAB KeyTab_RUSSIAN;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using KeyPadImagesStdTemplate
#pragma usingLtd Graphic


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB KeyPadANumStdTemplate::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_KEYPADANUMSTDTEMPLATE
2$UINT, 0$UINT, (SIZEOF(::KeyPadANumStdTemplate))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1679073929), "KeyPadANumStdTemplate", //Class
TO_UDINT(3599188277), "_Screen", 0$UINT, 3$UINT, //Baseclass
//Servers:
//Clients:
(::KeyPadANumStdTemplate.Graphic.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1140816688), "Graphic", TO_UDINT(1140816688), "Graphic", 0$UINT, 1$UINT, 
(::KeyPadANumStdTemplate.KeyPadImg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3266383049), "KeyPadImg", TO_UDINT(980817768), "KeyPadImagesStdTemplate", 2$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_KeyPadANumStdTemplate 6

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_KeyPadANumStdTemplate] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION KeyPadANumStdTemplate::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Screen::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Screen::Screen.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Screen::Screen.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_KeyPadANumStdTemplate;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #S_Run();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #S_Start();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #S_CreateNew();

#pragma warning (default : 74)
	_Screen::Screen.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Screen::Screen.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL KeyPadANumStdTemplate::Init

  _Screen::Init();
  if (_FirstScan) then
    KeyButton_XOff   := KEYPAD_ANUM_BUTTON_XOFF;
    KeyButton_YOff   := KEYPAD_ANUM_BUTTON_YOFF;
    KeyButton_Width  := KEYPAD_ANUM_BUTTON_WIDTH;
    KeyButton_Height := KEYPAD_ANUM_BUTTON_HEIGHT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL KeyPadANumStdTemplate::S_CreateNew
VAR_INPUT
  psetup 	  : ^_NEWSCREENPROP;
END_VAR
VAR_OUTPUT
  retcode 	: BOOL;
END_VAR
VAR
  tmpRoom       : _ROOM;
END_VAR

  retcode       := true;
  DoneByProgram := true;

  LayoutType := _LayoutLetter;
  SymbolMode := _Symbol_1;
  ShiftMode  := _Shift_0;

  MyGetScreenSize(#tmpRoom);

  KeyButton_Width := ((tmpRoom.xy2.x - tmpRoom.xy1.x + 1) - (2 * KEYPAD_ANUM_BUTTON_XOFF)) / 11;

  if (KeyButton_Width > KEYPAD_ANUM_BUTTON_WIDTH) then
    KeyButton_Width  := KEYPAD_ANUM_BUTTON_WIDTH;
  end_if;
  KeyButton_Height := KeyButton_Width;

  KeyPad_Width  := (11 * KeyButton_Width) + (2 * KEYPAD_ANUM_BUTTON_XOFF);
  KeyPad_Height := (4 * KeyButton_Height) + KEYPAD_ANUM_BUTTON_YOFF + KEYPAD_ANUM_BUTTON_XOFF;


  pDefkeypad   := Get_DEFKEYPAD();

  psetup^.Position.xy1.x     := (tmpRoom.xy2.x - tmpRoom.xy1.x + 1 - KeyPad_Width) / 2;
  psetup^.Position.xy1.y     := (tmpRoom.xy2.y - tmpRoom.xy1.y + 1 - KeyPad_Height) / 2;
  psetup^.Position.xy2.x     := psetup^.Position.xy1.x + KeyPad_Width - 1;
  psetup^.Position.xy2.y     := psetup^.Position.xy1.y + KeyPad_Height - 1;
  psetup^.FrameId            := pDefkeypad^.WindowFrame;
  psetup^.TouchEditorAscii   := false;
  psetup^.TouchEditorNumeric := false;
  psetup^.ColorBack          := pDefkeypad^.WindowColorBack;
  psetup^.ColorHatch         := pDefkeypad^.TitleBarColor;
  psetup^.DrawShadow         := false;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL KeyPadANumStdTemplate::S_Start
VAR_INPUT
  pic 	      : ^void;
  firsttime 	: BOOL;
END_VAR
VAR
  tmpRoom         : _ROOM;
  tmpStyleSheet   : _STYLESHEET;
  any             : _ANYPARA;
  ino, jno        : udint;
  tmpLine         : _KOORD;
  tmpColumn       : _KOORD;
  tmpLayout       : UINT;
  pButton         : ^_BUTTON;
  bRet            : BOOL;
END_VAR

  if (DoneByProgram = true) & (firsttime = true) then

    init_STYLESHEET(#tmpStyleSheet);

    setup_STYLESHEET(p                  := #tmpStyleSheet,
                     fontschemename     := #pDefkeypad^.StandardFontSchemeName[0],
                     frameid            := pDefkeypad^.ButtonFrame,
                     contextalign       := T_CENTERBOUND or T_MIDBOUND,
                     colback            := pDefkeypad^.ButtonColorReleased,
                     colfront           := pDefkeypad^.ButtonColorText,
                     colhatch           := pDefkeypad^.ButtonColorPressed,
                     coltopleft         := WHITE,
                     colbottomright     := DARKGRAY,
                     pdyncolback        := NIL,
                     pdyncolfront       := NIL,
                     pdyncolhatch       := NIL,
                     pdyncoltopleft     := NIL,
                     pdyncolbottomright := NIL);

    for tmpLine := 0 to 3 do

      case tmpLine of
        0:  tmpLayout := KEY_LAYOUT_LINE_1;
        1:  tmpLayout := KEY_LAYOUT_LINE_2;
        2:  tmpLayout := KEY_LAYOUT_LINE_3;
        3:  tmpLayout := KEY_LAYOUT_LINE_4;
      end_case;

      for tmpColumn := 0 to 10 do

        tmpRoom.xy1.x := Keybutton_XOff + tmpColumn * KeyButton_Width;
        tmpRoom.xy1.y := KeyButton_YOff + tmpLine * KeyButton_Height;
        tmpRoom.xy2.x := tmpRoom.xy1.x + (KeyButton_Width - 1);
        tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

        if ((tmpLayout SHR (10-tmpColumn)) AND 0x0001) then
          add_key(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, DEFSCOPE, NIL, sizeof(_ASCII), T_CENTERBOUND or T_MIDBOUND, _NOKEY, _NOKEY, _NOKEY);
        end_if;

      end_for;
    end_for;

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY SHIFT
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    ino := KeyPadImg.GetImage(0);
    jno := KeyPadImg.GetImage(1);

    tmpRoom.xy1.x := Keybutton_XOff;
    tmpRoom.xy1.y := KeyButton_YOff + 2 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);
    add_button(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, DEFSCOPE, DEFSCOPE, DEFSCOPE, DEFSCOPE, ino, jno, NIL, NIL, sizeof(_ASCII), false, 0, 0, DEFSCOPE, 1, 0, T_CENTERBOUND or T_MIDBOUND);

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY "123/Sym"
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff;
    tmpRoom.xy1.y := KeyButton_YOff + 3 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (2 * KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);
    add_button(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, DEFSCOPE, DEFSCOPE, DEFSCOPE, DEFSCOPE, DEFSCOPE, DEFSCOPE, "123/Sym", "123/Sym", sizeof(_ASCII), false, 0, 0, DEFSCOPE, 1, 0, T_CENTERBOUND or T_MIDBOUND);

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY SPACE
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff + 2 * KeyButton_Width;
    tmpRoom.xy1.y := KeyButton_YOff + 3 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (3 * KeyButton_Width - 1);   // v2.0, Space key is smaller now
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    ino := KeyPadImg.GetImage(9);
    bRet := add_key(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, ino, NIL, sizeof(_ASCII), T_CENTERBOUND or T_MIDBOUND, ' ', ' ');
    if (bRet = true) then
      pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr + (pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.no-1) * sizeof(_BUTTON);

      jno := KeyPadImg.GetImage(10);
      pButton^.buttonimages.image_press     := jno$UINT;
      pButton^.buttonimages.image_in_press  := jno$UINT;
      pButton^.buttonimages.image_sel_press := jno$UINT;
    end_if;

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY Arrow Left       v.2.0
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff + 5 * KeyButton_Width;
    tmpRoom.xy1.y := KeyButton_YOff + 3 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (1 * KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    ino := KeyPadImg.GetImage(11);
    bRet := add_key(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, ino, NIL, sizeof(_ASCII), T_CENTERBOUND or T_MIDBOUND, _LEFT, _LEFT);
    if (bRet = true) then
      pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr + (pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.no-1) * sizeof(_BUTTON);

      jno := KeyPadImg.GetImage(12);
      pButton^.buttonimages.image_press     := jno$UINT;
      pButton^.buttonimages.image_in_press  := jno$UINT;
      pButton^.buttonimages.image_sel_press := jno$UINT;
    end_if;

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY Arrow Right      v.2.0
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff + 6 * KeyButton_Width;
    tmpRoom.xy1.y := KeyButton_YOff + 3 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (1 * KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    ino := KeyPadImg.GetImage(13);
    bRet := add_key(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, ino, NIL, sizeof(_ASCII), T_CENTERBOUND or T_MIDBOUND, _RIGHT, _RIGHT);
    if (bRet = true) then
      pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr + (pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.no-1) * sizeof(_BUTTON);

      jno := KeyPadImg.GetImage(14);
      pButton^.buttonimages.image_press     := jno$UINT;
      pButton^.buttonimages.image_in_press  := jno$UINT;
      pButton^.buttonimages.image_sel_press := jno$UINT;
    end_if;

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY Ins      v2.0
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff + 7 * KeyButton_Width;
    tmpRoom.xy1.y := KeyButton_YOff + 3 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (1 * KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    add_button(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, DEFSCOPE, DEFSCOPE, DEFSCOPE, VARNO_INSERTFLAG, DEFSCOPE, DEFSCOPE, "Ins", "Ins", sizeof(_ASCII), false, 0, 0, DEFSCOPE, 1, 0, T_CENTERBOUND or T_MIDBOUND);

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY BACKSPACE
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff + 10 * KeyButton_Width;
    tmpRoom.xy1.y := KeyButton_YOff;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    ino := KeyPadImg.GetImage(7);

    bRet := add_key(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, ino, NIL, sizeof(_ASCII), T_CENTERBOUND or T_MIDBOUND, _BCKSPC, _BCKSPC);
    if (bRet = true) then
      pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr + (pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.no-1) * sizeof(_BUTTON);

      jno := KeyPadImg.GetImage(8);
      pButton^.buttonimages.image_press     := jno$UINT;
      pButton^.buttonimages.image_in_press  := jno$UINT;
      pButton^.buttonimages.image_sel_press := jno$UINT;

    end_if;

    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - KEY ENTER
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := Keybutton_XOff + 10 * KeyButton_Width;
    tmpRoom.xy1.y := KeyButton_YOff + 1 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (2 * KeyButton_Height - 1);

    ino := KeyPadImg.GetImage(5);

    bRet := add_key(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, ino, NIL, sizeof(_ASCII), T_CENTERBOUND or T_MIDBOUND, _ENTER, _ENTER);
    if (bRet = true) then
      pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr + (pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.no-1) * sizeof(_BUTTON);

      jno := KeyPadImg.GetImage(6);
      pButton^.buttonimages.image_press     := jno$UINT;
      pButton^.buttonimages.image_in_press  := jno$UINT;
      pButton^.buttonimages.image_sel_press := jno$UINT;

    end_if;


    FillButtons_LetterSmall(pic);


    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - INPUT
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    setup_STYLESHEET(#tmpStyleSheet, #pDefkeypad^.StandardFontSchemeName[0], FRAME_NONE, T_CENTERBOUND or T_MIDBOUND or T_INVERTTHEME, LIGHTGRAY, WHITE, LIGHTGRAY, WHITE, DARKGRAY, NIL, NIL, NIL, NIL, NIL);
    tmpRoom.xy1.x := KEYPAD_ANUM_INPUT_XOFF;
    tmpRoom.xy1.y := KEYPAD_ANUM_INPUT_YOFF;
    tmpRoom.xy2.x := (KeyPad_Width-1) - KEYPAD_ANUM_INPUT_XOFF;
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KEYPAD_ANUM_INPUT_HEIGHT-1);
    add_input(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, DEFSCOPE, VARNO_EDITORDUMMY, AS_ASCII, DEFSCOPE);
   
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    // - TITLE TEXT
    // ---------------------------------------------------------------------------------------------------------------------------------------------
    if(pDefkeypad^.TitleColorText$UINT <> INVISIBLE) then
      setup_STYLESHEET(#tmpStyleSheet, #pDefkeypad^.SmallFontSchemeName[0], FRAME_NONE, T_LEFTBOUND or T_MIDBOUND, INVISIBLE, pDefkeypad^.TitleColorText, INVISIBLE, INVISIBLE, INVISIBLE, NIL, NIL, NIL, NIL, NIL);
      tmpRoom.xy1.x := KEYPAD_ANUM_TITLE_XOFF;
      tmpRoom.xy1.y := KEYPAD_ANUM_TITLE_YOFF;
      tmpRoom.xy2.x := tmpRoom.xy1.x + (KeyPad_Width - (2 * KEYPAD_ANUM_INPUT_XOFF) - KEYPAD_ANUM_ESC_WIDTH - 1);
      tmpRoom.xy2.y := tmpRoom.xy1.y + (KEYPAD_ANUM_TITLE_HEIGHT-1);
      init_ANYPARA(#any);
      any.anything.list := VARTXT1;
      any.anything.no   := VARNO_EDITORDUMMY;
      add_text(pic$^_MY_PICTURE, #tmpStyleSheet, #tmpRoom, DEFSCOPE, #any, NIL, sizeof(_ASCII), DEFSCOPE);
      free_ANYPARA(#any);
    end_if;

    free_STYLESHEET(#tmpStyleSheet);
  end_if;

END_FUNCTION

FUNCTION KeyPadANumStdTemplate::SelectKeyboard
VAR_OUTPUT
  out_pKeyTab 	: ^USINT;
END_VAR

  out_pKeyTab := #KeyTab_QWERTY()$^usint;
  case Language_GetActualLocal() of 
    LOCAL_GERMAN    : out_pKeyTab := #KeyTab_QWERTZ()$^usint;
//    LOCAL_DUTCH     : out_pKeyTab := #KeyTab_DUTCH()$^usint;
//    LOCAL_FRENCH    : out_pKeyTab := #KeyTab_FRENCH()$^usint;
//    LOCAL_ITALIAN   : out_pKeyTab := #KeyTab_ITALIAN()$^usint;
//    LOCAL_SPANISH   : out_pKeyTab := #KeyTab_SPAIN()$^usint;
//    LOCAL_PORTUGESE : out_pKeyTab := #KeyTab_PORTUGUESE()$^usint;
//    LOCAL_NORWEGIAN : out_pKeyTab := #KeyTab_NORWEGIAN()$^usint;
//    LOCAL_FINNISH,
//    LOCAL_SWEDISH   : out_pKeyTab := #KeyTab_SWEDISH()$^usint;
//    LOCAL_DANISH    : out_pKeyTab := #KeyTab_DANISH()$^usint;
//    LOCAL_UKRAINIAN : out_pKeyTab := #KeyTab_UKRAINIAN()$^usint;
//    LOCAL_RUSSIAN   : out_pKeyTab := #KeyTab_RUSSIAN()$^usint;
//    LOCAL_GREEK     : out_pKeyTab := #KeyTab_GREEK()$^usint;
  end_case;

  out_pKeyTab += 4;

END_FUNCTION

FUNCTION KeyPadANumStdTemplate::IsUnicodeKeyboard
VAR_INPUT
#pragma warning(disable: 0073)
  in_pKeyTab 	: ^USINT;
#pragma warning(default: 0073)
END_VAR
VAR_OUTPUT
  out_bUnicode 	: BOOL;
END_VAR

  out_bUnicode := false;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL KeyPadANumStdTemplate::S_Run
VAR_INPUT
  pic 	: ^void;
  event 	: ^_EVENT;
END_VAR
VAR
	tmpRoom   : _ROOM;
  Redraw    : BOOL;
END_VAR

  Redraw := false;

  if (event^.ftype = _EVENT_HIDPRESS) then

    // -----------------------------------------------------------------------------------------------------
    // - BUTTON 123/Sym -
    // -----------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := pic^$_MY_PICTURE.Room.xy1.x + Keybutton_XOff;
    tmpRoom.xy1.y := pic^$_MY_PICTURE.Room.xy1.y + KeyButton_YOff + 3 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (2 * KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    if (event^.dot.x > tmpRoom.xy1.x) & (event^.dot.x < tmpRoom.xy2.x)
     & (event^.dot.y > tmpRoom.xy1.y) & (event^.dot.y < tmpRoom.xy2.y)then

      case LayoutType of

        //*********************************************************************
        _LayoutLetter:
        //*********************************************************************
          LayoutType := _LayoutSymbol;
          SymbolMode := _Symbol_1;

        //*********************************************************************
        _LayoutSymbol:
        //*********************************************************************
          LayoutType := _LayoutLetter;
          if (ShiftMode <> _Shift_2) then
            ShiftMode := _Shift_0;
          end_if;

      end_case;

      Redraw := true;

    end_if;

    // -----------------------------------------------------------------------------------------------------
    // - BUTTON SHIFT -
    // -----------------------------------------------------------------------------------------------------
    tmpRoom.xy1.x := pic^$_MY_PICTURE.Room.xy1.x + Keybutton_XOff;
    tmpRoom.xy1.y := pic^$_MY_PICTURE.Room.xy1.y + KeyButton_YOff + 2 * KeyButton_Height;
    tmpRoom.xy2.x := tmpRoom.xy1.x + (KeyButton_Width - 1);
    tmpRoom.xy2.y := tmpRoom.xy1.y + (KeyButton_Height - 1);

    if (event^.dot.x > tmpRoom.xy1.x) & (event^.dot.x < tmpRoom.xy2.x)
     & (event^.dot.y > tmpRoom.xy1.y) & (event^.dot.y < tmpRoom.xy2.y)then

      case LayoutType of
        //*********************************************************************
        _LayoutLetter:
        //*********************************************************************
          case ShiftMode of
            _Shift_0: ShiftMode := _Shift_1;
            _Shift_1: ShiftMode := _Shift_2;
            _Shift_2: ShiftMode := _Shift_0;
          end_case;


        //*********************************************************************
        _LayoutSymbol:
        //*********************************************************************
          case SymbolMode of
            _Symbol_1: SymbolMode := _Symbol_2;
            _Symbol_2: SymbolMode := _Symbol_1;
          end_case;

      end_case;
      Redraw := true;
    end_if;

  end_if;

  if (ShiftMode = _Shift_1) then
    case event^.scancode of

      //*****************************************************************************
      'A'..'Z',
      'Ä',
      'Ö',
      'Ü':
      //*****************************************************************************
        ShiftMode := _Shift_0;
        Redraw    := true;
    end_case;
  end_if;


  if (Redraw = true) then

    case LayoutType of

      //***************************************************************************
      _LayoutLetter:
      //***************************************************************************
        case ShiftMode of
          _Shift_0: FillButtons_LetterSmall(pic);
          _Shift_1: FillButtons_LetterBig(pic);
          _Shift_2: FillButtons_LetterBig(pic);
        end_case;

      //***************************************************************************
      _LayoutSymbol:
      //***************************************************************************
        case SymbolMode of
          _Symbol_1: FillButtons_Symbol1(pic);
          _Symbol_2: FillButtons_Symbol2(pic);
        end_case;

    end_case;

    InsertCmd(x0 := CMD_REDRAW,
              x1 := 0,
              x2 := 0);

  end_if;

END_FUNCTION

FUNCTION KeyPadANumStdTemplate::FillButtons_LetterSmall
VAR_INPUT
  pic 	: ^void;
END_VAR
VAR
  pKeyTab             : ^USINT;
  tmpLine             : UINT;
  tmpColumn           : UINT;
  tmpLayout           : UINT;
  str                 : ARRAY [0..3] OF CHAR;
  pButton             : ^_BUTTON;
  ino                 : UDINT;
  jno                 : UDINT;
END_VAR

  pKeyTab := SelectKeyboard();
  if (pKeyTab <> NIL) then

    pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr;

    for tmpLine := 0 to 3 do

      case tmpLine of
        0:  tmpLayout := KEY_LAYOUT_LINE_1;
        1:  tmpLayout := KEY_LAYOUT_LINE_2;
        2:  tmpLayout := KEY_LAYOUT_LINE_3;
        3:  tmpLayout := KEY_LAYOUT_LINE_4;
      end_case;

      for tmpColumn := 0 to 10 do

        if ((tmpLayout SHR (10-tmpColumn)) AND 0x0001) then

          str[0] := (pKeyTab+0)^;
          str[1] := 0;

          setup_USERTEXT(p0      := #pButton^.usertext,
                         txt     := #str[0],
                         chrsize := sizeof(CHAR));

          setup_USERTEXT(p0      := #pButton^.usertext1,
                         txt     := #str[0],
                         chrsize := sizeof(CHAR));

          pButton^.keycode[0] := (pKeyTab+0)^;

          pButton += sizeof(_BUTTON);
        end_if;
        pKeyTab += 4 * sizeof(USINT);
      end_for;
    end_for;
  end_if;

  pButton^.col := Graphic.MakeColor(pDefkeypad^.ButtonColorPressed, pDefkeypad^.ButtonColorReleased);

  ino := KeyPadImg.GetImage(0);
  jno := KeyPadImg.GetImage(1);

  pButton^.buttonimages.image_release     := ino$UINT;
  pButton^.buttonimages.image_in_release  := ino$UINT;
  pButton^.buttonimages.image_sel_release := ino$UINT;

  pButton^.buttonimages.image_press     := jno$UINT;
  pButton^.buttonimages.image_in_press  := jno$UINT;
  pButton^.buttonimages.image_sel_press := jno$UINT;

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := NIL,
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := NIL,
                 chrsize := sizeof(CHAR));



  pButton += sizeof(_BUTTON);

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := "123/Sym",
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := "123/Sym",
                 chrsize := sizeof(CHAR));


END_FUNCTION

FUNCTION KeyPadANumStdTemplate::FillButtons_LetterBig
VAR_INPUT
  pic 	: ^void;
END_VAR
VAR
  pKeyTab             : ^USINT;
  tmpLine             : UINT;
  tmpColumn           : UINT;
  tmpLayout           : UINT;
  str                 : ARRAY [0..3] OF CHAR;
  pButton             : ^_BUTTON;
  ino                 : UDINT;
  jno                 : UDINT;
END_VAR

  pKeyTab := SelectKeyboard();
  if (pKeyTab <> NIL) then

    pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr;

    for tmpLine := 0 to 3 do

      case tmpLine of
        0:  tmpLayout := KEY_LAYOUT_LINE_1;
        1:  tmpLayout := KEY_LAYOUT_LINE_2;
        2:  tmpLayout := KEY_LAYOUT_LINE_3;
        3:  tmpLayout := KEY_LAYOUT_LINE_4;
      end_case;

      for tmpColumn := 0 to 10 do

        if ((tmpLayout SHR (10-tmpColumn)) AND 0x0001) then

          str[0] := (pKeyTab+1)^;
          str[1] := 0;

          setup_USERTEXT(p0      := #pButton^.usertext,
                         txt     := #str[0],
                         chrsize := sizeof(CHAR));

          setup_USERTEXT(p0      := #pButton^.usertext1,
                         txt     := #str[0],
                         chrsize := sizeof(CHAR));

            pButton^.keycode[0] := (pKeyTab+1)^;

            pButton += sizeof(_BUTTON);
        end_if;
        pKeyTab += 4 * sizeof(USINT);
      end_for;
    end_for;
  end_if;


  case ShiftMode of

    1:
      ino := KeyPadImg.GetImage(4);
      jno := KeyPadImg.GetImage(1);;
      pButton^.col := Graphic.MakeColor(pDefkeypad^.ButtonColorPressed, pDefkeypad^.ButtonColorReleased);


    2:
      ino := KeyPadImg.GetImage(1);
      jno := KeyPadImg.GetImage(1);
      pButton^.col := Graphic.MakeColor(pDefkeypad^.ButtonColorPressed, pDefkeypad^.ButtonColorPressed);

  end_case;

  pButton^.buttonimages.image_release     := ino$UINT;
  pButton^.buttonimages.image_in_release  := ino$UINT;
  pButton^.buttonimages.image_sel_release := ino$UINT;

  pButton^.buttonimages.image_press     := jno$UINT;
  pButton^.buttonimages.image_in_press  := jno$UINT;
  pButton^.buttonimages.image_sel_press := jno$UINT;


  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := NIL,
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := NIL,
                 chrsize := sizeof(CHAR));



  pButton += sizeof(_BUTTON);

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := "123/Sym",
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := "123/Sym",
                 chrsize := sizeof(CHAR));

END_FUNCTION

FUNCTION KeyPadANumStdTemplate::FillButtons_Symbol1
VAR_INPUT
  pic 	: ^void;
END_VAR
VAR
  pKeyTab             : ^USINT;
  tmpLine             : UINT;
  tmpColumn           : UINT;
  tmpLayout           : UINT;
  str                 : ARRAY [0..3] OF CHAR;
  pButton             : ^_BUTTON;
END_VAR

  pKeyTab := SelectKeyboard();
  if (pKeyTab <> NIL) then

    pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr;

    for tmpLine := 0 to 3 do

      case tmpLine of
        0:  tmpLayout := KEY_LAYOUT_LINE_1;
        1:  tmpLayout := KEY_LAYOUT_LINE_2;
        2:  tmpLayout := KEY_LAYOUT_LINE_3;
        3:  tmpLayout := KEY_LAYOUT_LINE_4;
      end_case;

      for tmpColumn := 0 to 10 do

        if ((tmpLayout SHR (10-tmpColumn)) AND 0x0001) then

            str[0] := (pKeyTab+2)^;
            str[1] := 0;

            setup_USERTEXT(p0      := #pButton^.usertext,
                           txt     := #str[0],
                           chrsize := sizeof(CHAR));

            setup_USERTEXT(p0      := #pButton^.usertext1,
                           txt     := #str[0],
                           chrsize := sizeof(CHAR));

            pButton^.keycode[0] := (pKeyTab+2)^;

            pButton += sizeof(_BUTTON);
        end_if;
        pKeyTab += 4 * sizeof(USINT);
      end_for;
    end_for;
  end_if;

  pButton^.col := Graphic.MakeColor(pDefkeypad^.ButtonColorPressed, pDefkeypad^.ButtonColorReleased);

  pButton^.buttonimages.image_release     := DEFSCOPE$UINT;
  pButton^.buttonimages.image_in_release  := DEFSCOPE$UINT;
  pButton^.buttonimages.image_sel_release := DEFSCOPE$UINT;

  pButton^.buttonimages.image_press     := DEFSCOPE$UINT;
  pButton^.buttonimages.image_in_press  := DEFSCOPE$UINT;
  pButton^.buttonimages.image_sel_press := DEFSCOPE$UINT;

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := "1/2",
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := "1/2",
                 chrsize := sizeof(CHAR));

  pButton^.state := false;



  pButton += sizeof(_BUTTON);

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := "ABC",
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := "ABC",
                 chrsize := sizeof(CHAR));

END_FUNCTION

FUNCTION KeyPadANumStdTemplate::FillButtons_Symbol2
VAR_INPUT
  pic 	: ^void;
END_VAR
VAR
  pKeyTab             : ^USINT;
  tmpLine             : UINT;
  tmpColumn           : UINT;
  tmpLayout           : UINT;
  str                 : ARRAY [0..3] OF CHAR;
  pButton             : ^_BUTTON;
END_VAR

  pKeyTab := SelectKeyboard();
  if (pKeyTab <> NIL) then

    pButton := pic^$_MY_PICTURE.Ptr^$_PICTURE.mask.membutton.ptr;

    for tmpLine := 0 to 3 do

      case tmpLine of
        0:  tmpLayout := KEY_LAYOUT_LINE_1;
        1:  tmpLayout := KEY_LAYOUT_LINE_2;
        2:  tmpLayout := KEY_LAYOUT_LINE_3;
        3:  tmpLayout := KEY_LAYOUT_LINE_4;
      end_case;

      for tmpColumn := 0 to 10 do

        if ((tmpLayout SHR (10-tmpColumn)) AND 0x0001) then

            str[0] := (pKeyTab+3)^;
            str[1] := 0;

            setup_USERTEXT(p0      := #pButton^.usertext,
                           txt     := #str[0],
                           chrsize := sizeof(CHAR));

            setup_USERTEXT(p0      := #pButton^.usertext1,
                           txt     := #str[0],
                           chrsize := sizeof(CHAR));

            pButton^.keycode[0] := (pKeyTab+3)^;

            pButton += sizeof(_BUTTON);
        end_if;
        pKeyTab += 4 * sizeof(USINT);
      end_for;
    end_for;
  end_if;

  pButton^.col := Graphic.MakeColor(pDefkeypad^.ButtonColorPressed, pDefkeypad^.ButtonColorReleased);

  pButton^.buttonimages.image_press     := DEFSCOPE$UINT;
  pButton^.buttonimages.image_in_press  := DEFSCOPE$UINT;
  pButton^.buttonimages.image_sel_press := DEFSCOPE$UINT;

  pButton^.buttonimages.image_release     := DEFSCOPE$UINT;
  pButton^.buttonimages.image_in_release  := DEFSCOPE$UINT;
  pButton^.buttonimages.image_sel_release := DEFSCOPE$UINT;

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := "2/2",
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := "2/2",
                 chrsize := sizeof(CHAR));

  pButton^.state := false;



  pButton += sizeof(_BUTTON);

  setup_USERTEXT(p0      := #pButton^.usertext,
                 txt     := "ABC",
                 chrsize := sizeof(CHAR));

  setup_USERTEXT(p0      := #pButton^.usertext1,
                 txt     := "ABC",
                 chrsize := sizeof(CHAR));

END_FUNCTION

FUNCTION TAB KeyPadANumStdTemplate::KeyTab_QWERTZ

  'q','Q','1','1', 'w','W','2','2', 'e','E','3','3', 'r','R','4','4', 't','T','5','5', 'z','Z','6','6', 'u','U','7','7', 'i','I','8','8', 'o','O','9','9', 'p','P','0','0',  0 , 0 , 0 , 0 ,
  'a','A','+','`', 's','S','-','~', 'd','D','*','\', 'f','F','/', 0 , 'g','G','=','<', 'h','H','%','>', 'j','J','_','{', 'k','K','!','}', 'l','L','@','[', 'ü','Ü', 0 ,']',  0 , 0 , 0 , 0 ,
   0 , 0 , 0 , 0 , 'y','Y','#', 0 , 'x','X','$', 0 , 'c','C','&', 0 , 'v','V','?', 0 , 'b','B',':', 0 , 'n','N',';', 0 , 'm','M',',', 0 , 'ö','Ö', 0 , 0 , 'ä','Ä', 0 , 0 ,  0 , 0 , 0 , 0 ,
   0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 , '.','.','.','.', '-','-','-','-', '+','+','+','+',

END_FUNCTION

FUNCTION TAB KeyPadANumStdTemplate::KeyTab_QWERTY

  'q','Q','1','1', 'w','W','2','2', 'e','E','3','3', 'r','R','4','4', 't','T','5','5', 'y','Y','6','6', 'u','U','7','7', 'i','I','8','8', 'o','O','9','9', 'p','P','0','0',  0 , 0 , 0 , 0 ,
  'a','A','+','`', 's','S','-','~', 'd','D','*','\', 'f','F','/', 0 , 'g','G','=','<', 'h','H','%','>', 'j','J','_','{', 'k','K','!','}', 'l','L','@','[',  0 , 0 , 0 ,']',  0 , 0 , 0 , 0 ,
   0 , 0 , 0 , 0 , 'z','Z','#', 0 , 'x','X','$', 0 , 'c','C','&', 0 , 'v','V','?', 0 , 'b','B',':', 0 , 'n','N',';', 0 , 'm','M',',', 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,
   0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 ,  0 , 0 , 0 , 0 , '.','.','.','.', '-','-','-','-', '+','+','+','+',

END_FUNCTION

FUNCTION TAB KeyPadANumStdTemplate::KeyTab_RUSSIAN

  
(*
  1081$UINT,1049$UINT,49$UINT,49$UINT, 1094$UINT,1062$UINT,50$UINT,50$UINT, 1091$UINT,1059$UINT,51$UINT,51$UINT, 1082$UINT,1050$UINT,52$UINT,52$UINT, 1077$UINT,1045$UINT,52$UINT,52$UINT,




    49$uint,  33$uint,  0$uint,    50$uint,  34$uint,  0$uint,    51$uint,  21$uint,  0$uint,    52$uint,  59$uint,  0$uint,    53$uint,  37$uint,  0$uint,   
    54$uint,  58$uint,  0$uint,    55$uint,  63$uint,  0$uint,    56$uint,  42$uint,  0$uint,    57$uint,  40$uint,  0$uint,    48$uint,  41$uint,  0$uint,    45$uint,  95$uint,0$uint,
  1081$uint,1049$uint,'Q'$uint,  1094$uint,1062$uint,'W'$uint,  1091$uint,1059$uint,'E'$uint,  1082$uint,1050$uint,'R'$uint,  1077$uint,1045$uint,'T'$uint,   
  1085$uint,1053$uint,'Y'$uint,  1075$uint,1043$uint,'U'$uint,  1096$uint,1064$uint,'I'$uint,  1097$uint,1065$uint,'O'$uint,  1079$uint,1047$uint,'P'$uint,  1093$uint,1061$uint,0$uint,
  1092$uint,1060$uint,'A'$uint,  1099$uint,1067$uint,'S'$uint,  1074$uint,1042$uint,'D'$uint,  1072$uint,1040$uint,'F'$uint,  1087$uint,1055$uint,'G'$uint,   
  1088$uint,1056$uint,'H'$uint,  1086$uint,1054$uint,'J'$uint,  1083$uint,1051$uint,'K'$uint,  1076$uint,1044$uint,'L'$uint,  1078$uint,1046$uint,  0$uint,  1101$uint,1069$uint,0$uint,
  1103$uint,1071$uint,'Z'$uint,  1095$uint,1063$uint,'X'$uint,  1089$uint,1057$uint,'C'$uint,  1084$uint,1052$uint,'V'$uint,  1080$uint,1048$uint,'B'$uint,   
  1090$uint,1058$uint,'N'$uint,  1100$uint,1068$uint,'M'$uint,  1073$uint,1041$uint,  0$uint,  1102$uint,1070$uint,  0$uint,  1098$uint,1066$uint,  0$uint,    46$uint,  44$uint,0$uint
*)
END_FUNCTION
