//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\TCPCommunication\TCPCommunication.h"
#include "..\..\Class\TCPCommunication\SalamanderDelay.h"

(*!
<Class
	Name               = "TCPCommunication"
	Revision           = "1.14"
	GUID               = "{4FE2D887-3B7B-4994-9B08-ECF7221737EE}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "100 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(632,120)"
	Comment            = "Communication class: Can be used to transmit and receive data between 2 CPUs.&#13;&#10;&#13;&#10;Depending on which clients are connected the class works as:&#13;&#10;+ TCPIP Client&#13;&#10;+ TCPIP Server&#13;&#10;+ internal connection">
	<Channels>
		<Server Name="ClassSvr" GUID="{B088614F-943E-4D11-B793-28CCEB93F028}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Objekt-Server der Klasse. Der Client cCommunication des&#13;&#10;DataManager muß hierher verbunden werden. Die Klasse TCPCommunicationLogViewer&#13;&#10;kann ebenfalls hierher verbunden werden , um die Loggeinträge&#13;&#10;auszulesen und zu exportieren.&#13;&#10;&#13;&#10;&#13;&#10;Object server of the class. The client cCommunication of the DataManager has to be connected to this server. The class TCPCommunicationLogViewer can also be connected to this server in order to read and export the log entries."/>
		<Server Name="ComPort" GUID="{D6C00E2D-9A93-4125-85D8-93F8FBFEBA13}" Visualized="true" Initialize="true" DefValue="500" WriteProtected="false" Retentive="false" Comment="Hier muß der TCP Port über welchen &#13;&#10;kommuniziert werden soll eingetragen werden.&#13;&#10;&#13;&#10;Beim Senden und Empfänger muß der gleiche&#13;&#10;Port angegeben werden.&#13;&#10;&#13;&#10;Sind mehrerer Sende und Empfänger in einem&#13;&#10;Projekt , müssen unterschiedliche Ports&#13;&#10;eingetragen werden.&#13;&#10;&#13;&#10;z.B.: Sender1 - Empfänger1 -&gt; 500&#13;&#10;      Sender2 - Empfänger2 -&gt; 600&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;The TCP Port which is used for communication has to be configured here. Sender and Receiver have to use the same port.&#13;&#10;&#13;&#10;If there are multiple senders or receivers in the same project, different ports must be used.&#13;&#10;&#13;&#10;e.g.: Sender1 - Receiver1 -&gt; 500&#13;&#10;      Sender2 - Receiver2 -&gt; 600"/>
		<Server Name="ConnectionType" GUID="{3C543B20-73FA-42E5-ADC0-F178BB860809}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zeigt die Art der konfigurierten Verbindung an.&#13;&#10;&#13;&#10;Shows the type of the configured connection."/>
		<Server Name="DeactivateCom" GUID="{EDBA8C0D-7BAE-4C22-8F68-54CFF6F6C520}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="Set to 1 to deactivate communication.&#13;&#10;Set to 0 to reactivate communication."/>
		<Server Name="ErrorRecive" GUID="{F21FA644-1F4E-44B4-BB71-E22412181C22}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Wird inkrementiert , sollte beim Empfangen&#13;&#10;ein Fehler auftreten.&#13;&#10;&#13;&#10;Is incremented if an error occurs while receiving."/>
		<Server Name="ErrorSend" GUID="{0F17FC59-DB18-424A-A489-A7CD7B68DC03}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Wird inkrementiert , sollte beim Senden&#13;&#10;ein Fehler auftreten.&#13;&#10;&#13;&#10;Is incremented if an error occurs while sending."/>
		<Server Name="InitError" GUID="{17BD32A6-CE72-4885-834D-3525C2B866BB}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="If Server is &lt;&gt; 0, a severe Error occured during initialisation, it is not possible to start a communication.&#13;&#10;&#13;&#10;-1 ... Creation of the Communication Thread failed&#13;&#10;-2 ... Error while trying to get a CIL-Interface&#13;&#10;-3 ... Error during allocation of memory"/>
		<Server Name="LogEnable" GUID="{DC625EC3-BFE9-431A-A9EF-C54C884BB82D}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false" Comment="0..Logging ist deaktiviert.&#13;&#10;1..Logging ist aktiv&#13;&#10;&#13;&#10;0..Logging is deactivated.&#13;&#10;1..Logging is active."/>
		<Server Name="Online" GUID="{63E390B7-AB2F-4808-9A6E-85483E3A1BE7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Status der Online Verbindung .&#13;&#10;0..Offline&#13;&#10;1..Online&#13;&#10;&#13;&#10;State of the connection.&#13;&#10;0..Offline&#13;&#10;1..Online"/>
		<Server Name="ResetLogBuffer" GUID="{B07D12DF-0D09-4EC8-A93C-E2C1BAF2A329}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="durch ein write auf diesen Server , wird&#13;&#10;der interne LogBuffer gelöscht. Kann nur&#13;&#10;ausgeführt werden , wenn der Server&#13;&#10;sLogEnable auf 0 steht.&#13;&#10;&#13;&#10;&#13;&#10;Write() on this Server deletes the internal log buffer. Buffer can only be executed if the Server LogEnable is set to 0."/>
		<Server Name="TaskName" GUID="{A859575C-79ED-4458-AA0A-64F32C64B117}" Visualized="true" Initialize="true" WriteProtected="true" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="TimeLastReceive" GUID="{2D3B98D7-8AC2-4362-859F-113A1081CB69}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zeit welche das zuletzt empfangene TCP&#13;&#10;Paket benötigt hat bis es vollständig &#13;&#10;empfangen wurde. [us]&#13;&#10;&#13;&#10;Es werden folgende Pakete berücksichtig:&#13;&#10;+ Alive Pakete&#13;&#10;+ Acknowledge Pakete&#13;&#10;+ User Message Pakete"/>
		<Server Name="TimeLastSend" GUID="{B9222988-9E9F-4364-9911-B6BE31AD889A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Zeit welche das zuletzt gesendete TCP&#13;&#10;Paket benötigt hat. [us]&#13;&#10;&#13;&#10;Es werden folgende Pakete berücksichtigt:&#13;&#10;+ Alive Pakete&#13;&#10;+ Acknowledge Pakete&#13;&#10;+ User Message Pakete&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;Time the latest TCP packet took to send. [us]&#13;&#10;&#13;&#10;The measurement includes the following packets:&#13;&#10;+ Alive Packets&#13;&#10;+ Acknowledge Packets&#13;&#10;+ User Message Packets"/>
		<Server Name="TransferRateReceive" GUID="{42D366EA-769C-40EA-882F-122D9E689C7D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Geschwindigkeit der Kommunikation&#13;&#10;in [Bit/s] &#13;&#10;&#13;&#10;( Download )&#13;&#10;&#13;&#10;Es werden folgende Pakete berücksichtigt:&#13;&#10;+ Alive Pakete&#13;&#10;+ Acknowledge Pakete&#13;&#10;+ User Message Pakete&#13;&#10;&#13;&#10;&#13;&#10;Transfer rate in [Bit/s] &#13;&#10;&#13;&#10;( Upload )&#13;&#10;&#13;&#10;The measurement includes the following packets:&#13;&#10;+ Alive Packets&#13;&#10;+ Acknowledge Packets&#13;&#10;+ User Message Packets"/>
		<Server Name="TransferRateSend" GUID="{09F1E4EF-844A-4917-93BA-76B3DC563D59}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Geschwindigkeit der Kommunikation&#13;&#10;in [Bit/s] &#13;&#10;&#13;&#10;( Upload )&#13;&#10;&#13;&#10;Es werden folgende Pakete berücksichtigt:&#13;&#10;+ Alive Pakete&#13;&#10;+ Acknowledge Pakete&#13;&#10;+ User Message Pakete&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;Transfer rate in [Bit/s] &#13;&#10;&#13;&#10;( Upload )&#13;&#10;&#13;&#10;The measurement includes the following packets:&#13;&#10;+ Alive Packets&#13;&#10;+ Acknowledge Packets&#13;&#10;+ User Message Packets"/>
		<Client Name="CheckSum" Required="true" Internal="true"/>
		<Client Name="coDataMng" Required="true" Internal="false" Comment="Verbindung zum Daten Manager.&#13;&#10;Objekt Kanal : DataMng&#13;&#10;&#13;&#10;( über diesen Client werden die zu&#13;&#10;sendenden Daten vom Manager ausgelesen)&#13;&#10;&#13;&#10;&#13;&#10;Connection to the DataManager (via this object channel, the senddata is collected).&#13;&#10;"/>
		<Client Name="coIntern" Required="false" Internal="false" Comment="Soll eine externe Verbindung ( über TCPIP ) &#13;&#10;aufgebaut werden , darf dieser Client nicht&#13;&#10;verbunden werden.&#13;&#10;&#13;&#10;Befinden sich jedoch der Sender und der Empfänger&#13;&#10;auf der gleichen CPU , so muß dieser Client mit&#13;&#10;dem ClassSvr der Gegenstelle verbunden werden.&#13;&#10;&#13;&#10;Objekt Kanal : TCPCommunication&#13;&#10;&#13;&#10;&#13;&#10;If an external connection (via TCPIP) shall be established, this client may not be connected!&#13;&#10;&#13;&#10;If the connection is internal (sender and receiver are on the same cpu), this client has to be connected to the ClassSvr of the corresponding TCPCommunication class.&#13;&#10;&#13;&#10;"/>
		<Client Name="coIpToConnect" Required="false" Internal="false" Comment="Wenn Verbunden , dann arbeitet die Classe als TCPIP-Client und&#13;&#10;baut eine Verbindung zu dem TCPIP-Server mit dieser IP-Addrese auf.&#13;&#10;&#13;&#10;Sonst arbeitet Sie als TCPIP-Server und wartet auf eine eingehende&#13;&#10;Verbindung eines TCPIP-Clients.&#13;&#10;&#13;&#10;Objekt Kanal : StringInternal&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;If this client is connected, the class works as a TCPIP-Client and establishes a connection to the Server with the IP address contained in the connected String object.&#13;&#10;&#13;&#10;Otherwise, the class works as a Server and waits for an incoming Client connection."/>
		<Client Name="coLogFilter" Required="false" Internal="false" Comment="If the TCPCommunicationLogFilter is used, it has to be connected here."/>
		<Client Name="coMultiTask" Required="false" Internal="false" Comment="Muss nicht verbunden werden. ( OS Interface Classe )&#13;&#10;&#13;&#10;Wird benötigt um den parallelen Task anzulegen.&#13;&#10;&#13;&#10;Objekt Kanal : _MultiTask&#13;&#10;&#13;&#10;&#13;&#10;Object channel to OS-Interface for creating a parallel task. Does not have to be connected."/>
		<Client Name="coSigCLib" Required="false" Internal="false" Comment="Muß nicht verbunden werden. ( OS Interface Klasse )&#13;&#10;&#13;&#10;Wird für Stringfunktionen benötigt.&#13;&#10;&#13;&#10;Objekt Kanal : _StdLib&#13;&#10;&#13;&#10;&#13;&#10;Object channel to OS-Interface for string functions. Does not have to be connected."/>
		<Client Name="coStationToConnect" Required="false" Internal="false" Comment="connect to class &quot;GetIPOverStation&quot; ClassSvr to get the ip adress over set station number"/>
		<Client Name="coStdLib" Required="false" Internal="false" Comment="Muss nicht verbunden werden. ( OS Interface Klasse )&#13;&#10;&#13;&#10;Wird benötigt um Empfangs- und&#13;&#10;Sendepuffer anzulegen.&#13;&#10;&#13;&#10;Objekt Kanal : _StdLib&#13;&#10;&#13;&#10;&#13;&#10;Object channel to OS-Interface for memory functions. Does not have to be connected."/>
		<Client Name="ErrRuntime" Required="false" Internal="false" Comment="If the parallel communication task was not called for longer than TCPCom_Runtime (tcpcommunication.h), this Client will turn to 1 and if a Server is connected, it&apos;s write-Method will be called with input:=1.&#13;&#10;If it is called again after that, the Client will turn to 0 again and the write method will be called again with input:=0.&#13;&#10;Also, a TRACE-Error will be caused when the error is detected, and a TRACE-Warning will be caused as soon as the parallel task is running again."/>
		<Client Name="RamRingBuffer" Required="true" Internal="true"/>
		<Client Name="RamRingMerkerEx" Required="true" Internal="true"/>
		<Client Name="SizeOfComBuffers" Required="false" Internal="false" DefValue="2MB" Comment="Size of both the send aswell as the receive buffer. Has to be set as Init-Value!"/>
		<Client Name="ThreadName" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_tcp_user.h" Include="true"/>
			<File Path=".\Class\TCPCommunication\TCPCommunication.h" Include="true"/>
			<File Path=".\Class\TCPCommunication\TCPCommunication.pdf"/>
			<File Path=".\Class\TCPCommunication\SalamanderDelay.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HötAnt"/>
		<Dokumentation Revision="1.14" Date="2018-03-29" Author="HopAle" Company="Sigmatek" Description="Resolved errors occurred when using class on x86-salamander systems."/>
		<Dokumentation Revision="1.13" Date="2017-11-07" Author="SprDie" Company="Sigmatek" Description="When used on LARS systems, rebuilding a lost connection was sometimes not possible"/>
		<Dokumentation Revision="1.12" Date="2017-11-07" Author="SprDie" Company="Sigmatek" Description="(revoked) let user decide if a parallel task shall be used for internal connections"/>
		<Dokumentation Revision="1.11" Date="2017-08-30" Author="DacPat" Company="Sigmatek" Description="- The task priority of the tcp task can now be set via the SetParameter() method. (Set the task priority between the 1st and last Init() run)"/>
		<Dokumentation Revision="1.10" Date="2017-08-17" Author="HubChr" Company="Sigmatek" Description="Correction of possible &quot;multiple declaration&quot; error in case objects of _TCPIP_CLIENT or _TCPIP_SERVER were also in project."/>
		<Dokumentation Revision="1.9" Date="2017-04-10" Author="DacPat" Company="Sigmatek" Description="- In some cases the transferrate was calulated before the alive signal was received which resulted in a transferrate of 0 although the communication was ok.&#13;&#10;- The interval for sending the alive signal is now adjustable via SetParameter() &#13;&#10;- The error threshold for missing alive signals is now adjustable via SetParameter()&#13;&#10;- The size of the Rx and Tx Buffers is now adjustable via the Client SizeOfComBuffers"/>
		<Dokumentation Revision="1.8" Date="2016-11-23" Author="HubChr" Company="Sigmatek" Description="SA33258: In some cases the parallel task of the class TCPCommunication suddenly got deactivated during the runtime of the application."/>
		<Dokumentation Revision="1.7" Date="2016-08-24" Author="HubChr" Company="Sigmatek" Description="-) Workaround for Rtos: Maintimer is minimal value for TaskDelay ( if Maintimer &gt; TaskDelay lower tasks are blocked)&#13;&#10;-) If system bootup took longer than 1s, TCPCommunication reported a misleading runtime error message to the Debugger Trace."/>
		<Dokumentation Revision="1.6" Date="2015-11-13" Author="HubChr" Company="Sigmatek" Description="Added comments to the new components to achieve library conformity"/>
		<Dokumentation Revision="1.5" Date="2015-11-11" Author="HötAnt" Company="Sigmatek" Description="changed methode TransmitDataToStack and SendAlive ( communication did not work on LARS)"/>
		<Dokumentation Revision="1.4" Date="2015-11-11" Author="Matthias Schuiki" Company="Sigmatek" Description="-) CRC32 of the objectname is now used as taskname for the parallel task (a maximum of 32 signs can be used as a&#13;&#10;    Taskname, using the objectname led to problems exceeding 32 signs, especially when using embedded objects).&#13;&#10;-) Write protection of the Server ComPort has been removed &#13;&#10;-) New methods SetParameter() and ReadParameter() to set the ComPort have been added&#13;&#10;-) New server DeactivateCom has been added to fully activate an deactivate communication during runtime.&#13;&#10;-) TCPCom_SendAcknowledge&#13;&#10;-) TCPCom_TimeOutCheckBeforeSending"/>
		<Dokumentation Revision="1.3" Date="2015-08-10" Author="LeiChr" Company="Sigmatek" Description="- the function to get the IP over station number is done in a extra class"/>
		<Dokumentation Revision="1.2" Date="2015-07-09" Author="LeiChr" Company="Sigmatek" Description="- new client StationToConnect to get IP over LSE station"/>
		<Dokumentation Revision="1.0" Date="2015-01-08" Author="ObeChr" Company="Sigmatek" Description="Prepared class for library"/>
		<Dokumentation Revision="0.1" Date="2014-04-17" Author="HötAnt" Company="Sigmatek" Description="Created class"/>
	</RevDoku>
	<Network Name="TCPCommunication">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "CheckSum"
				GUID       = "{65B879CD-70B3-42EF-9FC2-6B8ED605F75C}"
				Class      = "_CheckSum"
				Position   = "(240,600)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "RamRingBuffer"
				GUID       = "{934BB221-E441-4435-9182-6931ACC68BAE}"
				Class      = "RamRingBuffer"
				Position   = "(780,330)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="Data"/>
				</Channels>
			</Object>
			<Object
				Name       = "RamRingMerkerEx"
				GUID       = "{640F1BCA-1105-4F9F-9E84-21CF2149312E}"
				Class      = "MerkerEx"
				Position   = "(240,330)"
				Visualized = "true">
				<Channels>
					<Server Name="m_udLength"/>
					<Client Name="ThreadSafe" Value="0"/>
				</Channels>
			</Object>
			<Object
				Name       = "ThreadName"
				GUID       = "{1FDFC61E-D18A-4637-A64F-E7649BD741FD}"
				Class      = "String"
				Position   = "(240,750)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.RamRingBuffer" Destination="RamRingBuffer.ClassSvr"/>
			<Connection Source="this.RamRingMerkerEx" Destination="RamRingMerkerEx.m_udLength"/>
			<Connection Source="RamRingBuffer.Data" Destination="RamRingMerkerEx.m_udLength" Vertices="(780,420),(540,420),"/>
			<Connection Source="this.CheckSum" Destination="CheckSum.ClassSvr"/>
			<Connection Source="this.ThreadName" Destination="ThreadName.Data"/>
			<Connection Source="this.TaskName" Destination="ThreadName.Data" Vertices="(1294,990),(556,840),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
TCPCommunication : CLASS
	TYPE
	  t_e_ConnectionType :  //! <Type Public="true" Comment="Gibt die Art der konfigurierten Verbindung an.&#13;&#10;&#13;&#10;To show what kind of Connection is configurated." Name="t_e_ConnectionType"/>
	  (
	    NotValid,  //! <Type Comment="keine gültige Konfiguration.&#13;&#10;( es ist eine interne Verbindunng und eine&#13;&#10;IP Addresse eines Servers verbunden )&#13;&#10;&#13;&#10;No valid configuration.&#13;&#10;(both internal aswell as a connection to an IP address are present)." Name="t_e_ConnectionType.NotValid"/>
	    TCPClient,  //! <Type Comment="Es wird eine Verbindung zu einem&#13;&#10;Server aufgebaut. Client cIPToConnect&#13;&#10;ist verbunden.&#13;&#10;&#13;&#10;Class works as TCPIP Client, a connection to a Server will be established." Name="t_e_ConnectionType.TCPClient"/>
	    TCPServer,  //! <Type Comment="Es wird auf eine Verbindung von einem Client&#13;&#10;gewartet. Wir arbeiten als Server.&#13;&#10;Es ist weder der Client cIPToConnect noch&#13;&#10;der Client cIntern verbunden.&#13;&#10;&#13;&#10;Class works as a Server, waiting for an incoming client connection. Neither cIPToConnect nor cIntern are connected." Name="t_e_ConnectionType.TCPServer"/>
	    InternConnection  //! <Type Comment="Es ist eine Interne Verbindung konfiguriert.&#13;&#10;Der Client coIntern ist Verbunden.&#13;&#10;&#13;&#10;Internal connection. Client coIntern is connected." Name="t_e_ConnectionType.InternConnection"/>
	  )$UDINT;
	  t_e_PackageCmd :  //! <Type Public="true" Name="t_e_PackageCmd"/>
	  (
	    PCMD_Alive,  //! <Type Comment="Alive Paket" Name="t_e_PackageCmd.PCMD_Alive"/>
	    PCMD_Data,  //! <Type Comment="User Message" Name="t_e_PackageCmd.PCMD_Data"/>
	    PCMD_Acknowledge,  //! <Type Comment="Acknowledge Paket" Name="t_e_PackageCmd.PCMD_Acknowledge"/>
	    PCMD_ConnectionOK,  //! <Type Comment="Connection established." Name="t_e_PackageCmd.PCMD_ConnectionOK"/>
	    PCMD_ConnectionClosed,  //! <Type Comment="Verbindung wird geschlossen.&#13;&#10;&#13;&#10;Connection is being closed." Name="t_e_PackageCmd.PCMD_ConnectionClosed"/>
	    PCMD_ConnectionTimeOut,  //! <Type Comment="Es ist ein Timeout aufgetreten. (Alive )&#13;&#10;&#13;&#10;A timeout occurred (Alive)." Name="t_e_PackageCmd.PCMD_ConnectionTimeOut"/>
	    PCMD_TryToConnect,  //! <Type Comment="es wird versucht eine neue Verbindung aufzubauen.&#13;&#10;&#13;&#10;Connection is being established." Name="t_e_PackageCmd.PCMD_TryToConnect"/>
	    PCMD_ComDeactivated,
	    PCMD_ComActivated
	  )$UDINT;
	  t_e_TCPComSteps :
	  (
	    TCPCom_DoNothing,  //! <Type Comment="keine Aktion&#13;&#10;&#13;&#10;No Action." Name="t_e_TCPComSteps.TCPCom_DoNothing"/>
	    TCPCom_StartConnecting,  //! <Type Comment="Entscheidet ob Client Server oder Interne&#13;&#10;Verbindung und öffnet den Socket.&#13;&#10;&#13;&#10;Decides, if server, client or internal connection and opens the socket." Name="t_e_TCPComSteps.TCPCom_StartConnecting"/>
	    TCPCom_ConnectClientToServer,  //! <Type Comment="Baut die Verbindung zu dem Server auf.&#13;&#10;&#13;&#10;Establishes the connection to the server." Name="t_e_TCPComSteps.TCPCom_ConnectClientToServer"/>
	    TCPCom_WaitForClient,  //! <Type Comment="Wartet bis sich eine Client verbinden&#13;&#10;will.&#13;&#10;&#13;&#10;Waiting for an incoming client." Name="t_e_TCPComSteps.TCPCom_WaitForClient"/>
	    TCPCom_AcceptClient,  //! <Type Comment="Akzeptiert die Verbindung und speichert&#13;&#10;sich den neuen Socket ab.&#13;&#10;&#13;&#10;Accepting client connection and saving socket." Name="t_e_TCPComSteps.TCPCom_AcceptClient"/>
	    TCPCom_CloseConnection,  //! <Type Comment="Schließt alle Sockets .&#13;&#10;&#13;&#10;Closing all sockets." Name="t_e_TCPComSteps.TCPCom_CloseConnection"/>
	    TCPCom_WaitNewConnection,  //! <Type Comment="Wartet bis eine neuer Verbindungsaufbau&#13;&#10;gestartet wird.&#13;&#10;&#13;&#10;Waiting for a new connection." Name="t_e_TCPComSteps.TCPCom_WaitNewConnection"/>
	    TCPCom_ConnectionOKSendAlive,  //! <Type Comment="Steht die Verbindung , wird hier das&#13;&#10;Alive Signal geschickt und kontrolliert&#13;&#10;ob die Gegenstelle noch was schickt.&#13;&#10;&#13;&#10;If a connection is established, in this step the Alive Package is sent do see if the connection is still ok." Name="t_e_TCPComSteps.TCPCom_ConnectionOKSendAlive"/>
	    TCPCom_WaitPrjReady,
	    TCPCom_Deactivated
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_Header : STRUCT
	    Commando : t_e_PackageCmd;  //! <Type Comment="Art der Nachricht.&#13;&#10;&#13;&#10;Connection type?" Name="t_s_Header.Commando"/>
	    DestinationID : DINT;  //! <Type Comment="ID des Empfängers" Name="t_s_Header.DestinationID"/>
	    SourceID : DINT;  //! <Type Comment="ID des Senders" Name="t_s_Header.SourceID"/>
	    JobID : DINT;  //! <Type Comment="Eindeutige Nummer für jeden Job.&#13;&#10;&#13;&#10;Unique number for every job." Name="t_s_Header.JobID"/>
	    pThisSource : pVoid;  //! <Type Comment="This - Pointer des Senders.&#13;&#10;&#13;&#10;This - Pointer of the sender." Name="t_s_Header.pThisSource"/>
	    pCallBackSource : pVoid;  //! <Type Comment="Callback Funktionspointer des Senders.&#13;&#10;&#13;&#10;Callback functionpointer of the sender." Name="t_s_Header.pCallBackSource"/>
	    PackageSize : UDINT;  //! <Type Comment="Größe der gesamten Nachricht.&#13;&#10;&#13;&#10;Size of the complete message." Name="t_s_Header.PackageSize"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s__Acknowledge : STRUCT  //! <Type Comment="Definition eines Acknowledge Pakets&#13;&#10;&#13;&#10;Definition of an Acknowledge packet" Name="t_s__Acknowledge"/>
	    Header : t_s_Header;  //! <Type Comment="Header der Nachricht&#13;&#10;&#13;&#10;Header of the Message" Name="t_s__Acknowledge.Header"/>
	    dState : DINT;  //! <Type Comment="1..von Reciver empfangen.&#13;&#10;-1..Destination ID am Reciver nicht angemeldet.&#13;&#10;&#13;&#10;1..received&#13;&#10;-1..destination ID not registered at receiver." Name="t_s__Acknowledge.dState"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Alive : STRUCT  //! <Type Comment="Definition eines Alive Pakets&#13;&#10;&#13;&#10;Definition of an Alive Packet" Name="t_s_Alive"/>
	    Header : t_s_Header;  //! <Type Comment="Header der Nachricht&#13;&#10;&#13;&#10;Header of the Message" Name="t_s_Alive.Header"/>
	    udAliveCount : UDINT;  //! <Type Comment="Alive Counter" Name="t_s_Alive.udAliveCount"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Configuration : STRUCT
	    bTaskOK : BOOL;  //! <Type Comment="der Parallele Taskt konnte angelegt werden.&#13;&#10;&#13;&#10;Parallel task was successfully created.&#13;&#10;" Name="t_s_Configuration.bTaskOK"/>
	    bIsClient : BOOL;  //! <Type Comment="Die Klasse arbeitet als TCPIP-Client.&#13;&#10;&#13;&#10;Class is working as a TCPIP-Client." Name="t_s_Configuration.bIsClient"/>
	    bIsInternConnection : BOOL;  //! <Type Comment="Es ist keine TCPIP-Kommunikation vorhanden.&#13;&#10;Die klasse ist intern verbunden.&#13;&#10;&#13;&#10;No TCPIP communication is running, class is working as an internal connection." Name="t_s_Configuration.bIsInternConnection"/>
	    bMemoryOK : BOOL;  //! <Type Comment="Sende- und Empfangsbuffer konnten &#13;&#10;angelegt werden.&#13;&#10;&#13;&#10;RX- and TX-Buffer have been successfully allocated.&#13;&#10;" Name="t_s_Configuration.bMemoryOK"/>
	    TaskErrorNr : DINT;  //! <Type Comment="Fehlernummer , falls bTaskOK nicht&#13;&#10;TRUE ist. Fehlercodes siehe Dokumentation der Klasse _MultiTask.&#13;&#10;&#13;&#10;Errorcode, in case bTaskOK is not TRUE. Definition of errorcodes see documentation of class _MultiTask." Name="t_s_Configuration.TaskErrorNr"/>
	    bSendAlive : BOOL;  //! <Type Comment="Soll das Alive Signal gesendet werden.&#13;&#10;&#13;&#10;If an alive signal should be sent." Name="t_s_Configuration.bSendAlive"/>
	    bCheckAlive : BOOL;  //! <Type Comment="Soll das Alive Signal überprüft werden ?&#13;&#10;Ist die 3 fache Zeit überschritten , wird&#13;&#10;die Verbindung geschlossen und neu&#13;&#10;aufgebaut.&#13;&#10;&#13;&#10;Should the alive signal be checked?&#13;&#10;If no alive packet recognised, after thrice the normal time the connection is closed and newly established." Name="t_s_Configuration.bCheckAlive"/>
	    bLogBufferOK : BOOL;  //! <Type Comment="Der Buffer für das Logging wurde erfolgreich&#13;&#10;initialisiert.&#13;&#10;&#13;&#10;Buffer for logging was initialised successfully." Name="t_s_Configuration.bLogBufferOK"/>
	    bLogAlive : BOOL;  //! <Type Comment="Sollen die Alive Pakete mitgelogged werden?&#13;&#10;&#13;&#10;Should Alive Packets be logged?" Name="t_s_Configuration.bLogAlive"/>
	    bLogAcknowledge : BOOL;  //! <Type Comment="Sollen die Acknowledge Pakete mitgelogged werden?&#13;&#10;&#13;&#10;Should Acknowledge Packets be logged?&#13;&#10;" Name="t_s_Configuration.bLogAcknowledge"/>
	    bLogData : BOOL;  //! <Type Comment="Sollen die User Pakete mitgelogged werden?&#13;&#10;&#13;&#10;Should User Packets be logged?" Name="t_s_Configuration.bLogData"/>
	    bInitialized : BOOL;
	    bComDeactivated : BOOL;
	    bComStopped : BOOL;
	    bCILOK : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_LogEntry : STRUCT  //! <Type Public="true" Name="t_s_LogEntry"/>
	    Header : t_s_Header;
	    Prio : DINT;
	    TimeStamp : UDINT;
	    TimeOut : UDINT;
	    TCPType : DINT;  //! <Type Comment="0..Send&#13;&#10;1..Recive&#13;&#10;" Name="t_s_LogEntry.TCPType"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Runtime : STRUCT
	    udCountAct : UDINT;
	    udCountLast : UDINT;
	    udTimeStamp : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Stack : STRUCT
	    udSizeInit : UDINT;
	    udMinFree : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_TCPVariables : STRUCT
	    dMainSocket : DINT;  //! <Type Comment="Haupt Socket der TCP - Verbindung.&#13;&#10;( open socket )" Name="t_s_TCPVariables.dMainSocket"/>
	    dConnectionNr : DINT;  //! <Type Comment="Neben Socket des Clients. &#13;&#10;( accept )" Name="t_s_TCPVariables.dConnectionNr"/>
	    udTimeOutAccept : UDINT;  //! <Type Comment="[ms]" Name="t_s_TCPVariables.udTimeOutAccept"/>
	    udTimeOutRecv : UDINT;  //! <Type Comment="[ms]" Name="t_s_TCPVariables.udTimeOutRecv"/>
	    udTimeOutAlive : UDINT;  //! <Type Comment="[ms]" Name="t_s_TCPVariables.udTimeOutAlive"/>
	    udTimeAliveSignal : UDINT;  //! <Type Comment="[ms]" Name="t_s_TCPVariables.udTimeAliveSignal"/>
	    udTimeNewConnection : UDINT;  //! <Type Comment="Wie oft das Alive Signal&#13;&#10;verschickt wird. [ms]&#13;&#10;&#13;&#10;How often an alive signal is sent." Name="t_s_TCPVariables.udTimeNewConnection"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_TimeStamps : STRUCT
	    udLastSendPackAlive : UDINT;  //! <Type Comment="Zeitmerker des zuletzt gesendeten&#13;&#10;Alive Signals&#13;&#10;&#13;&#10;Timestamp of the latest sent Alive Packet" Name="t_s_TimeStamps.udLastSendPackAlive"/>
	    udTransferrateSend : UDINT;  //! <Type Comment="Zeitmerker der letzten Berechung der&#13;&#10;Transferrate ( Send )&#13;&#10;&#13;&#10;Timestamp of the latest calculation of the Transfer rate (Send)." Name="t_s_TimeStamps.udTransferrateSend"/>
	    udTransferrateRecive : UDINT;  //! <Type Comment="Zeitmerker der letzten Berechung der&#13;&#10;Transferrate ( Recive )&#13;&#10;&#13;&#10;Timestamp of the latest calculation of the Transfer rate (receive)" Name="t_s_TimeStamps.udTransferrateRecive"/>
	    udAliveCounterExt : UDINT;  //! <Type Comment="Zeitmerker des zuletzt empfangenen &#13;&#10;TCPIp Pakets.&#13;&#10;&#13;&#10;Ist bCheckAlive aktiv, wird nach der&#13;&#10;3 fach eingestellten Zeit zum schicken&#13;&#10;des Alive Signals , ein Neuaufbau der&#13;&#10;Verbindung angestoßen.&#13;&#10;&#13;&#10;&#13;&#10;Timestamp of the latest received TCPIP Packet.&#13;&#10;&#13;&#10;If bCheckAlive is active, after thrice the send interval, the connection is closed and established again." Name="t_s_TimeStamps.udAliveCounterExt"/>
	    udNewConnection : UDINT;  //! <Type Comment="Zeitmerker für den Aufbau einer neuen&#13;&#10;Verbindung.&#13;&#10;&#13;&#10;Timestamp for the connection process." Name="t_s_TimeStamps.udNewConnection"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Transfer : STRUCT
	    dSendAmount : DINT;  //! <Type Comment="Anzahl der gesendeten Daten [Byte]&#13;&#10;&#13;&#10;Count of the sent data [Byte]" Name="t_s_Transfer.dSendAmount"/>
	    dReciveAmount : DINT;  //! <Type Comment="Anzahl der empfangenen Daten [Byte]&#13;&#10;&#13;&#10;Count of received Data [Byte]" Name="t_s_Transfer.dReciveAmount"/>
	    dSendAmountOld : DINT;  //! <Type Comment="Merker für Berechung ( Send )&#13;&#10;&#13;&#10;Marker for calculation (send)" Name="t_s_Transfer.dSendAmountOld"/>
	    dReciveAmountOld : DINT;  //! <Type Comment="Merker für Berechung ( Recive )&#13;&#10;&#13;&#10;Marker for calculation (receive)" Name="t_s_Transfer.dReciveAmountOld"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	InitError 	: SvrCh_DINT;
	ConnectionType 	: SvrCh_t_e_ConnectionType_PTofCls_TCPCommunication;
	ComPort 	: SvrCh_UDINT;
	Online 	: SvrCh_DINT;
	ErrorSend 	: SvrCh_DINT;
	ErrorRecive 	: SvrCh_DINT;
	TransferRateSend 	: SvrCh_DINT;
	TransferRateReceive 	: SvrCh_DINT;
	TimeLastSend 	: SvrCh_UDINT;
	TimeLastReceive 	: SvrCh_UDINT;
	LogEnable 	: SvrCh_DINT;
	ResetLogBuffer 	: SvrCh_DINT;
	TaskName 	: SvrCh_UDINT;
	DeactivateCom 	: SvrCh_DINT;
  //Clients:
	coDataMng 	: CltChCmd_DataManager;
	coIntern 	: CltChCmd_TCPCommunication;
	coIpToConnect 	: CltChCmd_StringInternal;
	coStationToConnect 	: CltChCmd_DINT;
	coLogFilter 	: CltChCmd_TCPCommunicationLogFilter;
	coStdLib 	: CltChCmd__StdLib;
	coMultiTask 	: CltChCmd__MultiTask;
	RamRingBuffer 	: CltChCmd_RamRingBuffer;
	RamRingMerkerEx 	: CltChCmd_MerkerEx;
	coSigCLib 	: CltChCmd_SigCLib;
	ErrRuntime 	: CltCh_DINT;
	SizeOfComBuffers 	: CltCh_UDINT;
	CheckSum 	: CltChCmd__CheckSum;
	ThreadName 	: CltChCmd_String;
  //Variables:
		eComSteps 	: t_e_TCPComSteps;			//! <Variable Comment="Variable welche für das Initialisieren und die&#13;&#10;Kontrolle der Verbindung zuständig ist.&#13;&#10;&#13;&#10;Needed for Initialisation and management of the communication." Name="eComSteps"/>
		lsl_tcp_user 	: ^LSL_TCP_USER;			//! <Variable Comment="Pointer für die TCPIP Funktionen des &#13;&#10;Betriebssystems. ( CIL )&#13;&#10;&#13;&#10;Needed to access the TCPIP OS-Functions. (CIL)" Name="lsl_tcp_user"/>
		pDataRecive 	: pVoid;			//! <Variable Comment="Empfangs Buffer&#13;&#10;&#13;&#10;RX Buffer&#13;&#10;" Name="pDataRecive"/>
		pDataSend 	: pVoid;			//! <Variable Comment="Sende Buffer&#13;&#10;&#13;&#10;TX Buffer" Name="pDataSend"/>
		pTaskComCls 	: pVoid;			//! <Variable Comment="Taskhandle des Parallelen Tasks&#13;&#10;&#13;&#10;Taskhandle of the parallel task" Name="pTaskComCls"/>
		sConfig 	: t_s_Configuration;			//! <Variable Comment="Konfiguration der Klasse.&#13;&#10;&#13;&#10;Configuration of the Class." Name="sConfig"/>
		sParameter 	: t_s_TCPVariables;			//! <Variable Comment="Parameter der TCP Verbindung&#13;&#10;&#13;&#10;Parameters of the TCP connection" Name="sParameter"/>
		sStack 	: t_s_Stack;
		sTimeStamp 	: t_s_TimeStamps;			//! <Variable Comment="diverse Zeitstempel.&#13;&#10;&#13;&#10;used for miscellaneous Timestamps." Name="sTimeStamp"/>
		sTransfer 	: t_s_Transfer;			//! <Variable Comment="für die Berechnung der Upload und&#13;&#10;Download Geschwindigkeit.&#13;&#10;&#13;&#10;Needed for the calculation of the transferrate." Name="sTransfer"/>
		tmpRecvData : ARRAY [0..50000] OF USINT;
			//! <Variable Comment="Temporärer Empfangsbuffer. Muß nicht größer&#13;&#10;sein da das Betriebssystem nie mehr Daten&#13;&#10;in einem Paket zur Verfügung stellt.&#13;&#10;&#13;&#10;Temporary RX Buffer. Size is constant because OS never provides more data in one packet." Name="tmpRecvData"/>
		udAliveCounterExtern 	: UDINT;
		udAliveCounterIntern 	: UDINT;
		NewInstData 	: CmdStruct;
		NewInstResult 	: results;
		Runtime 	: t_s_Runtime;
		szTaskName : ARRAY [0..15] OF CHAR;

		udTaskDelay 	: UDINT;
		IsSalamanderOS 	: BOOL;
		pCIL_DEBUG 	: ^OS_SALAMANDERDEBUG;
		udAliveError 	: UDINT;
		uiTaskPriority 	: UINT;
		usInitCounter 	: USINT;
		udTimeoutConnect 	: UDINT;
  //Functions:
				//! <Function Comment="Initialisierung aller benötigten Variablen.&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Runtime of the parallel communication task is monitored here.&#13;&#10;If parallel function is called to  rarely, an Error will be reported at Client ErrRuntime. Also, a TRACE-Error will be caused." Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION RecivedData
		VAR_INPUT
			DestinationID 	: DINT;
			SourceID 	: DINT;
			udSize 	: UDINT;
			pData 	: pVoid;
			pLogEntrie 	: ^t_s_LogEntry := NIL;			//! <Variable Comment="Wird nur für Logging verwendet.&#13;&#10;" Name="RecivedData.pLogEntrie"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="1.. Package was delivered&#13;&#10;-1 .. no Reciver with the Destination ID&#13;&#10;-2 .. Package was delivered , other fault." Name="RecivedData.retcode"/>
		END_VAR;
				//! <Function Comment="Diese Methode wird vom Betriebssystem&#13;&#10;aufgerufen. ( Paralleler Task )" Name="CommunicationTask"/>
	FUNCTION __CDECL CommunicationTask
		VAR_INPUT
			Param0 	: pVoid;
		END_VAR;
				//! <Function Comment="Enthält den Ablauf der Klasse." Name="CyclicMethode"/>
	FUNCTION CyclicMethode;
				//! <Function Comment="Ermittelt die am Client cIptoConnect&#13;&#10;eingestellte IP-Addresse des Servers.&#13;&#10;" Name="GetIpOfServer"/>
	FUNCTION GetIpOfServer
		VAR_INPUT
			pChar 	: ^CHAR;			//! <Variable Comment="Pointer, wohin der String kopiert&#13;&#10;werden soll." Name="GetIpOfServer.pChar"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="FALSE .. einlesen nicht möglich.&#13;&#10;TRUE ... erfolgreich eingelesen.&#13;&#10;" Name="GetIpOfServer.retcode"/>
		END_VAR;
				//! <Function Comment="Kümmert sich um den Verbindungsaufbau &#13;&#10;sowie um das Alive Signal für einen&#13;&#10;eventuellen Neuaufbau der Verbindung.&#13;&#10;" Name="Connection"/>
	FUNCTION Connection
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="FALSE .. Verbindung ist Offline&#13;&#10;TRUE  .. Verbindung ist Online." Name="Connection.retcode"/>
		END_VAR;
				//! <Function Comment="Kümmert sich um das Verschicken der&#13;&#10;Nachrichten. Dabei werden die Daten&#13;&#10;vom DataMng geholt und dann entspechend&#13;&#10;der Verbindung verschicke.&#13;&#10;" Name="TransmitDataToStack"/>
	FUNCTION TransmitDataToStack;
				//! <Function Comment="Verschickt ein Alive Paket.&#13;&#10;" Name="SendAlive"/>
	FUNCTION SendAlive
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="FALSE .. Fehler bei der Übertragung.&#13;&#10;TRUE  .. Wurde erfolgreich verschickt.&#13;&#10;" Name="SendAlive.retcode"/>
		END_VAR;
				//! <Function Comment="Hier kann der Status der TCPIP Verbindung&#13;&#10;ausgelesen werden.&#13;&#10;&#13;&#10;Can be used to fetch the state of the TCPIP connection." Name="GetOnlineState"/>
	FUNCTION GLOBAL GetOnlineState
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0..offline&#13;&#10;1..online" Name="GetOnlineState.retcode"/>
		END_VAR;
				//! <Function Comment="Sendet ein Acknowledge Paket zurück &#13;&#10;an den Empfänger.&#13;&#10;&#13;&#10;Sends an acknowledge package to the receiver." Name="SendAcknowledge"/>
	FUNCTION SendAcknowledge
		VAR_INPUT
			pHeader 	: ^t_s_Header;			//! <Variable Comment="Informationen über das Ziel" Name="SendAcknowledge.pHeader"/>
			State 	: DINT;			//! <Variable Comment="1.. Package was delivered&#13;&#10;-1 .. no Reciver with the Destination ID" Name="SendAcknowledge.State"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="FALSE .. Fehler bei der Übertragung.&#13;&#10;TRUE  .. Wurde erfolgreich verschickt.&#13;&#10;" Name="SendAcknowledge.retcode"/>
		END_VAR;
				//! <Function Comment="Es werden Socket Einstellungen &#13;&#10;gesetzt.&#13;&#10;&#13;&#10;SO_REUSEADDR&#13;&#10;SO_DELAYED_ACK&#13;&#10;SO_NAGLE&#13;&#10;&#13;&#10;" Name="SetSocketOptions"/>
	FUNCTION SetSocketOptions
		VAR_INPUT
			socket 	: DINT;			//! <Variable Comment="Socketnumber , für welche die Optionen &#13;&#10;gesetzt werden sollen.&#13;&#10;" Name="SetSocketOptions.socket"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="TRUE .. Erfolgreich.&#13;&#10;FALSE.. Es ist ein Fehler aufgetreten.&#13;&#10;" Name="SetSocketOptions.retcode"/>
		END_VAR;
				//! <Function Comment="Kümmert sich um das Auslesen der Daten &#13;&#10;vom TCPIP - Stack und gibt diese&#13;&#10;dann an den entsprechenden Empfänger&#13;&#10;weiter.&#13;&#10;" Name="ReciveDataFromStack"/>
	FUNCTION ReciveDataFromStack;
				//! <Function Comment="Wird aufgerufen , wenn ein vollständig&#13;&#10;empfangenes Paket vorhanden ist.&#13;&#10;&#13;&#10;" Name="NewMessage"/>
	FUNCTION NewMessage
		VAR_INPUT
			pTCPHeader 	: ^t_s_Header;			//! <Variable Comment="Pointer auf den Header der Nachricht.&#13;&#10;" Name="NewMessage.pTCPHeader"/>
			pData 	: pVoid;			//! <Variable Comment="Pointer auf die User Daten der Nachricht.&#13;&#10;" Name="NewMessage.pData"/>
			Length 	: UDINT;			//! <Variable Comment="Länge der User Daten.&#13;&#10;" Name="NewMessage.Length"/>
		END_VAR;
				//! <Function Comment="Fügt einen Log Eintrag hinzu." Name="AddToLog"/>
	FUNCTION AddToLog
		VAR_INPUT
			pMng_HeaderTCP 	: ^t_s_Header;			//! <Variable Comment="Pointer auf die TCP Header Daten." Name="AddToLog.pMng_HeaderTCP"/>
			TimeOut 	: DINT;			//! <Variable Comment="TimeOut der Message in ms&#13;&#10;" Name="AddToLog.TimeOut"/>
			TimeStamp 	: UDINT;			//! <Variable Comment="TimeStamp wann die Nachricht aufgegeben&#13;&#10;wurde." Name="AddToLog.TimeStamp"/>
			Prio 	: DINT;			//! <Variable Comment="Priorität der Nachricht." Name="AddToLog.Prio"/>
			Direction 	: DINT;			//! <Variable Comment="0..Send&#13;&#10;1..Recive&#13;&#10;2..Status Meldung" Name="AddToLog.Direction"/>
		END_VAR;
				//! <Function Comment="Es können verschiedene Stati in das&#13;&#10;Logging eingefügt werden.&#13;&#10;" Name="LogStatus"/>
	FUNCTION LogStatus
		VAR_INPUT
			Commando 	: t_e_PackageCmd;			//! <Variable Comment="Status" Name="LogStatus.Commando"/>
		END_VAR;
	
	FUNCTION SetTraceRuntimeError
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION ResTraceRuntimeError
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION CreateTaskName
		VAR_INPUT
			pTaskName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Can be used to change settings, such as the port number or the interval for the keepalive message" Name="SetParameter"/>
	FUNCTION GLOBAL SetParameter
		VAR_INPUT
			ParaNo 	: DINT;			//! <Variable Comment="TCPCom_ParaWR_ComPort: Sets the communication port number&#13;&#10;TCPCom_ParaWR_MissingAliveError: Number of missing alive packets that are tolerated before the connection is closed and rebuilt&#13;&#10;TCPCom_ParaWR_AliveSignalTime: interval in wich alive packets are sent&#13;&#10;" Name="SetParameter.ParaNo"/>
			ParaVal 	: DINT;			//! <Variable Comment="Value the parameter shall be set to." Name="SetParameter.ParaVal"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1001.. Invalid Parameter Number" Name="SetParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="Can be used to read settings." Name="ReadParameter"/>
	FUNCTION GLOBAL ReadParameter
		VAR_INPUT
			ParaNo 	: DINT;			//! <Variable Comment="Parameter Number. Currently, only a readout of the Portnumber is possible. Use ParaNo := TCPCom_ParaRD_ComPort in this case." Name="ReadParameter.ParaNo"/>
			pParaVal 	: ^DINT;			//! <Variable Comment="Current value of the parameter will be written to this address." Name="ReadParameter.pParaVal"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1001.. Invalid Parameter Number&#13;&#10;-1002.. pParaVal = NIL" Name="ReadParameter.Retcode"/>
		END_VAR;
	
	FUNCTION ComStop
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION ComStart
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION IsLars
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Call matching Taskdelay Function according to OS" Name="DelayComTask"/>
	FUNCTION DelayComTask
		VAR_INPUT
			udDelay 	: UDINT;			//! <Variable Comment="Delay [ms]" Name="DelayComTask.udDelay"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetLogBuffer::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DeactivateCom::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CheckSum
#pragma using MerkerEx
#pragma using RamRingBuffer
#pragma using String
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd DataManager
#pragma usingLtd SigCLib
#pragma usingLtd StringInternal
#pragma usingLtd TCPCommunicationLogFilter


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB TCPCommunication::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_TCPCOMMUNICATION
1$UINT, 14$UINT, (SIZEOF(::TCPCommunication))$UINT, 
15$UINT, 14$UINT, 0$UINT, 
TO_UDINT(3704218787), "TCPCommunication", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::TCPCommunication.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::TCPCommunication.InitError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2181595834), "InitError", 
(::TCPCommunication.ConnectionType.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(910408916), "ConnectionType", 
(::TCPCommunication.ComPort.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3802332095), "ComPort", 
(::TCPCommunication.Online.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1858763116), "Online", 
(::TCPCommunication.ErrorSend.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3711595188), "ErrorSend", 
(::TCPCommunication.ErrorRecive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2764202895), "ErrorRecive", 
(::TCPCommunication.TransferRateSend.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1592782854), "TransferRateSend", 
(::TCPCommunication.TransferRateReceive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2894260808), "TransferRateReceive", 
(::TCPCommunication.TimeLastSend.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2106194038), "TimeLastSend", 
(::TCPCommunication.TimeLastReceive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2491141214), "TimeLastReceive", 
(::TCPCommunication.LogEnable.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(488952092), "LogEnable", 
(::TCPCommunication.ResetLogBuffer.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3534664286), "ResetLogBuffer", 
(::TCPCommunication.TaskName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3136881463), "TaskName", 
(::TCPCommunication.DeactivateCom.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1236227921), "DeactivateCom", 
//Clients:
(::TCPCommunication.coDataMng.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2513473014), "coDataMng", TO_UDINT(4008337867), "DataManager", 1$UINT, 0$UINT, 
(::TCPCommunication.coIntern.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2486183652), "coIntern", TO_UDINT(3704218787), "TCPCommunication", 1$UINT, 14$UINT, 
(::TCPCommunication.coIpToConnect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1345333764), "coIpToConnect", TO_UDINT(2898603620), "StringInternal", 1$UINT, 82$UINT, 
(::TCPCommunication.coStationToConnect.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1036635602), "coStationToConnect", 
(::TCPCommunication.coLogFilter.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1020641458), "coLogFilter", TO_UDINT(2005587341), "TCPCommunicationLogFilter", 1$UINT, 0$UINT, 
(::TCPCommunication.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::TCPCommunication.coMultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2105478532), "coMultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::TCPCommunication.RamRingBuffer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3534980377), "RamRingBuffer", TO_UDINT(3534980377), "RamRingBuffer", 1$UINT, 1$UINT, 
(::TCPCommunication.RamRingMerkerEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1906079267), "RamRingMerkerEx", TO_UDINT(2225119864), "MerkerEx", 1$UINT, 22$UINT, 
(::TCPCommunication.coSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1750761597), "coSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 23$UINT, 
(::TCPCommunication.ErrRuntime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2805011654), "ErrRuntime", 
(::TCPCommunication.SizeOfComBuffers.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3031176100), "SizeOfComBuffers", 
(::TCPCommunication.CheckSum.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(408699862), "CheckSum", TO_UDINT(916194998), "_CheckSum", 1$UINT, 0$UINT, 
(::TCPCommunication.ThreadName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(394930896), "ThreadName", TO_UDINT(1850111279), "String", 1$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_TCPCommunication 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_TCPCommunication] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION TCPCommunication::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_TCPCommunication, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ComPort.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ComPort.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorSend.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ErrorSend.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorRecive.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ErrorRecive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LogEnable.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LogEnable.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetLogBuffer.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ResetLogBuffer::Write() );
	IF ResetLogBuffer.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DeactivateCom.pMeth			:= StoreMethod( #M_RD_DIRECT(), #DeactivateCom::Write() );
	IF DeactivateCom.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL UserCallbackJobState VAR_INPUT pthis : pvoid; JobID : dint; JobState : DataManagerPriority::t_e_CallbackState; END_VAR;

FUNCTION TCPCommunication::RecivedData
	VAR_INPUT
		DestinationID 	: DINT;
		SourceID 	: DINT;
		udSize 	: UDINT;
		pData 	: pVoid;
		pLogEntrie 	: ^t_s_LogEntry;(* := NIL *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // Daten an Manager weiterleiten , dieser hat die Zuweisung zu den angemeldeten Zielen.
  retcode := coDataMng.RecivedData(DestinationID, SourceID, udSize, pData);
  
  // nur bei interner Verbindung , da die ReciveDataFromStack nicht aufgerufen wird.
  if sConfig.bIsInternConnection then
    sTransfer.dReciveAmount += to_dint(udSize);
    
    // wird nur bei interner Verbindung <> NIL sein
    if pLogEntrie <> NIL then
    
      // Eintrag ins Logfile hinzufügen.
      AddToLog( pMng_HeaderTCP:=#pLogEntrie^.Header, 
                TimeOut:=pLogEntrie^.TimeOut$dint, 
                TimeStamp:=ops.tAbsolute, 
                Prio:=pLogEntrie^.Prio,
                Direction:= 1);
    end_if;
  end_if;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL TCPCommunication::Init
VAR
  dRet        : DINT;
END_VAR

  usInitCounter += 1;

  //DacPat v1.11 Set the task priority of the tcp task to the default value
  if usInitCounter = 1 then
  
    uiTaskPriority := TCPCom_TaskPrio;
  end_if;

  if _firstscan then

    // -------------------------------------------------------------------
    // - CREATE THREAD NAME
    // -------------------------------------------------------------------

    dRet := CreateTaskName(pTaskName := #szTaskName[0]);

    // SprDie v1.13 - in case of Lars set timeout for tcp-connect
    if IsLars() = TRUE then
      udTimeoutConnect := 10;
    else
      udTimeoutConnect := 0;
    end_if;

    // HubChr v1.8 check OS
    if (_rtosversion >= OS_STARTVERSION_SALAMANDER) then
      IsSalamanderOS := TRUE;
    end_if;

    if (dRet = 0) then

      // HubChr v1.7 Workaround for Rtos
      if (IsSalamanderOS = FALSE) & (ops.RtInterv_mSec > TCPCOM_TASKDELAY) then
        udTaskDelay := ops.RtInterv_mSec;
      else
        udTaskDelay := TCPCOM_TASKDELAY;
      end_if;      

      // Create Task
      pTaskComCls := coMultiTask.CreateThread( #CommunicationTask(),  
                                              uiTaskPriority, 
                                              TCPCom_StackSize, 
                                              MT_TASK_SAVETHIS, 
                                              this, 
                                              #szTaskName[0]);

      if pTaskComCls = NIL then
        // is any error detected
        sConfig.TaskErrorNr := coMultiTask.GETLASTERROR();
        sConfig.bTaskOK := FALSE;
        InitError := -1;
      else

        sConfig.bTaskOK := TRUE;

        if (DeactivateCom = 1) then
          eComSteps := TCPCom_Deactivated;
          sConfig.bComDeactivated := true;
        else
          eComSteps := TCPCom_StartConnecting;
          sConfig.bComDeactivated := false;
        end_if;

        #ifdef TCPCom_CheckStack
          sStack.udSizeInit := TCPCom_StackSize AND 16#0FFFFFFF;
        #endif
      end_if;

    else

      sConfig.bTaskOK := false;

    end_if;

    // --- HubChr v1.8, #1973, get CIL interface for different delay-method when on Salamander platform
    sConfig.bCILOK := TRUE;
    
    if (IsSalamanderOS = TRUE) then
      if OS_CILGET("SALAMANDERDEBUG", #pCIL_DEBUG) then // returns 0 upon success
        pCIL_DEBUG := NIL;
        sConfig.bCILOK := FALSE;
        InitError := -2;
      end_if;
    end_if;

    // Get TCP-Interface
    if sConfig.bCILOK = TRUE then // HubChr v1.8 if first interface failed already we don't try to get the TCP
      if OS_CILGET("TCP_USER", #lsl_tcp_user) then 
        lsl_tcp_user := NIL;
        sConfig.bCILOK := FALSE;
        InitError := -2;
      end_if;
    end_if;
    // --- End HubChr v1.8

    
    
    // Prüfen ob interne Verbindung oder Verbindung über TCP benötigt wird.
    if IsClientConnected(#coIntern) then
      sConfig.bIsInternConnection := TRUE;
    end_if;
    
    // Prüfen ob ein ein Server Verbunden ist. ( Server oder Client Verbindung )
    if IsClientConnected(#coIpToConnect) | IsClientConnected(#coStationToConnect) then
      // Wir sind Client und bauen eine Verbindung zu einem Server auf.
      sConfig.bIsClient := TRUE;
    end_if;
    
    // Alive Signal soll überprüft werden.
    sConfig.bCheckAlive  := TRUE;
    // Alive Signal soll geschickt werden.
    sConfig.bSendAlive   := TRUE;
    
    
    // Alive Signal soll mitgelogged werden
    sConfig.bLogAlive := TRUE;
    // Daten sollen mitgelogged werden.
    sConfig.bLogData := TRUE;
    // Acknowledge Commandos sollen mitgelogged werden
    sConfig.bLogAcknowledge := TRUE;
    
    
    // Timeouts Parametrieren.
    sParameter.udTimeOutRecv         := 50ms;
    sParameter.udTimeOutAlive        := 10ms;
    sParameter.udTimeNewConnection   := 500ms;
    
    //20170410 DacPat v1.9 Time interval for sending an alive signal. Can be changed via the SetParameter() method.
    if sParameter.udTimeAliveSignal = 0 then
      sParameter.udTimeAliveSignal   := TCPCom_AliveSignalTime;
    end_if;
    
    //20170410 DacPat v1.9 Time interval for calculating the transferrates. Can be changed via the SetParameter() method.
    if udAliveError = 0 then
      udAliveError := TCPCom_MissingAliveError;
    end_if;
    
    // allocate memory for send- and receivebuffer
    if SizeOfComBuffers = 0 then
      SizeOfComBuffers := TCPCOM_ENTRYSIZE;
    end_if;
    pDataSend := coStdLib.MallocV1(SizeOfComBuffers,TCPCom_MemoryMark);
    pDataRecive := coStdLib.MallocV1(SizeOfComBuffers,TCPCom_MemoryMark);
    if (pDataSend <> NIL) & (pDataRecive <> NIL) then
      sConfig.bMemoryOK := TRUE;
    else
      InitError := -3;
    end_if;
    
    if RamRingBuffer.Prepaire(account:=TCPCom_LogEntries, size:=sizeof(t_s_LogEntry)) = TRUE then
      sConfig.bLogBufferOK := TRUE;
    end_if;
    
    if sConfig.bIsInternConnection = TRUE & sConfig.bIsClient = FALSE then
      ConnectionType := InternConnection;
    elsif sConfig.bIsInternConnection = TRUE & sConfig.bIsClient = TRUE then
      ConnectionType := NotValid;
    elsif sConfig.bIsInternConnection = FALSE & sConfig.bIsClient = TRUE then
      ConnectionType := TCPClient;
    elsif sConfig.bIsInternConnection = FALSE & sConfig.bIsClient = FALSE then
      ConnectionType := TCPServer;
    end_if;

    sConfig.bInitialized := true;

  end_if;

END_FUNCTION

FUNCTION __CDECL TCPCommunication::CommunicationTask
	VAR_INPUT
		Param0 	: pVoid;
	END_VAR

	 // this method is a parallel task, so we need an endless loop
	 while 1 do

    Runtime.udCountAct += 1;

    if sConfig.bMemoryOK = TRUE then
      // call cyclic method
      // HubChr v1.8 don't do anything unless the interfaces are ready!
      if sConfig.bCILOK = TRUE then
        CyclicMethode();
      else
        TRACE_ERR("TCPCommunication: CIL Error - Parallel Task aborted!");
        DeactivateCom.Write(input:=1);
        exit; // Deactivate Task
      end_if;
    end_if;

    // delay time for the parallel task. 
    if (sConfig.bComStopped = false) then
      DelayComTask(udTaskDelay);  // HubChr v1.8
    else
      DelayComTask(TCPCOM_TASKDELAY_OFF); // HubChr v1.8
    end_if;

    #ifdef TCPCom_CheckStack
      sStack.udMinFree := coMultiTask.GETMINSTACK(handle0:=coMultiTask.CURRENTTASKHANDLE());
    #endif

	end_while;

END_FUNCTION

FUNCTION TCPCommunication::CyclicMethode

  // nur wenn eine Verbindung aufgebaut ist, wird geschickt und empfangen.
  if Connection() = TRUE then
  
    // Daten aus dem Manager holen und verschicken.
    TransmitDataToStack();
    
    // Ist eine Interne Verbindung vorhandne , wird die Recive nicht benötigt , wird im Transmit bereits weitergegeben.
    if sConfig.bIsInternConnection = FALSE then
      // Daten welche über TCP kommen empfangen und weiterleiten.
      ReciveDataFromStack();
    end_if;
    
  end_if;

END_FUNCTION

FUNCTION TCPCommunication::Connection
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    dRetcode : dint;
    DestIP : array [0..99] of char;
    retval : iprStates;
  END_VAR

  // Baut die Verbindung zwischen Server/Client oder Client/Server auf.
  case eComSteps of
  
    // Do Nothing
    TCPCom_DoNothing:
  
    // Verbindungsaufbau starten. ( Wenn intern , dann nicht notwendig , gleich online )
    TCPCom_StartConnecting:

      if sConfig.bIsInternConnection then
        eComSteps := TCPCom_ConnectionOKSendAlive;
        LogStatus(PCMD_ConnectionOK);
        sTimeStamp.udAliveCounterExt := ops.tAbsolute;
      else
  
        sParameter.dMainSocket := OS_TCP_USER_SOCKET(); 
        
        if sParameter.dMainSocket >= 0 then
          // Socket Optionen setzen
          if SetSocketOptions(socket:=sParameter.dMainSocket) = TRUE then
            // Prüfen ob Server oder Client
            if sConfig.bIsClient = TRUE then
              eComSteps :=TCPCom_ConnectClientToServer;  
            else
              eComSteps := TCPCom_WaitForClient;
            end_if;
          else
            eComSteps := TCPCom_CloseConnection;
          end_if;
        else 
          eComSteps := TCPCom_DoNothing;
        end_if;
      
      end_if;
      
    // Client : Baut Verbindung zu Server auf.  
    TCPCom_ConnectClientToServer:
    
      // LeiChr  rev1.2  09.07.2015
      // check if we have connected a station number
      if (IsClientConnected(#coStationToConnect)) then
        eComSteps := TCPCom_WaitPrjReady;
      else
        if GetIpOfServer(pChar:=#DestIP[0]) = TRUE then
          dRetcode := OS_TCP_USER_CONNECT(sParameter.dMainSocket, 
                                            0, 
                                            #DestIP[0], 
                                            ComPort, 
                                            0); 
          
          if (dRetcode < 0) & (dRetcode <> TCP_NOT_READY) then 
            // Verbindung schließen und erneut aufmachen.
            eComSteps := TCPCom_CloseConnection; 
          elsif dRetcode = 0 then 
            // Verbindung ist hergestellt.
            eComSteps := TCPCom_ConnectionOKSendAlive;
            LogStatus(PCMD_ConnectionOK);
            
            // ist notwendig wegen Fehler im OS , da bei Connect das Blocking Bit zurückgesetzt wird.
            // Rückgabewert auswerte hat keinen Sinn , da auch noch Fehler im OS ist.
            OS_TCP_USER_IOCTLSOCKET(sParameter.dMainSocket, SET_SOCKET_MODE, 0);
            
            sTimeStamp.udAliveCounterExt := ops.tAbsolute;
          end_if;
        else
          // Fehler IP Adresse nicht gesetzt
          eComSteps :=TCPCom_DoNothing;
        end_if;
      end_if;
    
    // New step LeiChr rev1.2  09.07.2015
    // Wait for project ready to get the ip over station number of lse
    // LeiChr rev1.3  10.08.2015
    // Changed the handling of get IP over station
    // ------------------------------------------
    TCPCom_WaitPrjReady:

      NewInstData.uiCmd := CMD_GETIPOverStation;
      
      retval := coStationToConnect.NewInst(#NewInstData, #NewInstResult);
      
      if (retval = READY) then
        // Überprüfen der Länge der IP Adresse
        if (NewInstResult.uiLng > 0) then
          DestIP[0] := 0;
          coSigCLib.StrCpy(dst0:=#DestIP[0], src0:=#NewInstResult.aData[0]);

          dRetcode := OS_TCP_USER_CONNECT(sParameter.dMainSocket, 
                                            0, 
                                            #DestIP[0], 
                                            ComPort, 
                                            udTimeoutConnect); // SprDie v1.13 - set timeout in case of LARS
          
          if (dRetcode < 0) & (dRetcode <> TCP_NOT_READY) then 
            // Verbindung schließen und erneut aufmachen.
            eComSteps := TCPCom_CloseConnection; 
          elsif dRetcode = 0 then 
            // Verbindung ist hergestellt.
            eComSteps := TCPCom_ConnectionOKSendAlive;
            LogStatus(PCMD_ConnectionOK);
            
            // ist notwendig wegen Fehler im OS , da bei Connect das Blocking Bit zurückgesetzt wird.
            // Rückgabewert auswerte hat keinen Sinn , da auch noch Fehler im OS ist.
            OS_TCP_USER_IOCTLSOCKET(sParameter.dMainSocket, SET_SOCKET_MODE, 0);
            
            sTimeStamp.udAliveCounterExt := ops.tAbsolute;
          end_if;
        // Fehler IP Adresse nicht gesetzt
        else
          eComSteps := TCPCom_DoNothing;
        end_if;
          
      elsif (retval = ERROR) then
        // Fehler IP Adresse nicht gesetzt
        eComSteps :=TCPCom_DoNothing;
      end_if;


  
    // Server : Warten bis Client Verbindung aufgebaut hat.
    TCPCom_WaitForClient:
    
      dRetcode := OS_TCP_USER_LISTEN(sParameter.dMainSocket, 
                                     ComPort, 
                                     1); 

      if dRetcode < 0 then       
        // Verbindung kann nicht hergestellt werden. Abbruch und neu aufbauen.
        eComSteps := TCPCom_CloseConnection;         
      else 
        // Client versucht eine Verbindung aufzubauen.
        eComSteps := TCPCom_AcceptClient; 
      end_if;
      
      
    // Verbindung zulassen.  
    TCPCom_AcceptClient:
      
      sParameter.dConnectionNr := OS_TCP_USER_ACCEPT(sParameter.dMainSocket, sParameter.udTimeOutAccept); 

      if (sParameter.dConnectionNr < 0) & (sParameter.dConnectionNr <> TCP_NOT_READY) then 
        // Verbindung kann nicht hergestellt werden. Abbruch und neu aufbauen.
        eComSteps := TCPCom_CloseConnection; 
      elsif sParameter.dConnectionNr >= 0 then 
        // Socket Optionen setzen
        if SetSocketOptions(socket:=sParameter.dConnectionNr) = TRUE then
          // Verbindung ist hergestellt.
          eComSteps := TCPCom_ConnectionOKSendAlive; 
          LogStatus(PCMD_ConnectionOK);
          sTimeStamp.udAliveCounterExt := ops.tAbsolute;
        else
          eComSteps := TCPCom_CloseConnection;
        end_if;
      end_if;
     
  
    TCPCom_CloseConnection: // Verbindung schließen.
      
      LogStatus(PCMD_ConnectionClosed);
      if sConfig.bIsClient = FALSE then
        OS_TCP_USER_CLOSESOCKET(sParameter.dConnectionNr, 1);   
        sParameter.dConnectionNr :=0;
      end_if;
      OS_TCP_USER_CLOSESOCKET(sParameter.dMainSocket, 1);   
      sParameter.dMainSocket := 0; 
      sTimeStamp.udNewConnection := ops.tAbsolute;

      if (sConfig.bComDeactivated = false) then
        eComSteps := TCPCom_WaitNewConnection; 
      else
        eComSteps := TCPCom_Deactivated;
      end_if;

   TCPCom_WaitNewConnection :
   
      if ( ops.tAbsolute -  sTimeStamp.udNewConnection) >= sParameter.udTimeNewConnection then
        eComSteps := TCPCom_StartConnecting; 
        LogStatus(Commando:=PCMD_TryToConnect);
      end_if;
      
    // Alive Signal verschicken und überprüfen
    TCPCom_ConnectionOKSendAlive: 
       
      if sConfig.bIsInternConnection = FALSE then
      
        if (ops.tAbsolute - sTimeStamp.udLastSendPackAlive) >= sParameter.udTimeAliveSignal then
          if sConfig.bSendAlive <> 0 then
            SendAlive();
          end_if;
          sTimeStamp.udLastSendPackAlive := ops.tAbsolute;
        end_if;
      
        if ( ops.tAbsolute - sTimeStamp.udAliveCounterExt ) >= udAliveError*sParameter.udTimeAliveSignal then // HubChr v1.9
          if sConfig.bCheckAlive <> 0 then
            eComSteps := TCPCom_CloseConnection;
            LogStatus(PCMD_ConnectionTimeOut);
          end_if;
        end_if;

      end_if;        


    TCPCom_Deactivated:

      if (sConfig.bComDeactivated = true) then
        if (sConfig.bComStopped = false) then
          sConfig.bComStopped := true;
          LogStatus(Commando := PCMD_ComDeactivated);
        end_if;
      else
        sConfig.bComStopped := false;
        eComSteps := TCPCom_StartConnecting;
        LogStatus(Commando := PCMD_ComActivated);
      end_if;


  end_case;
  
  if eComSteps = TCPCom_ConnectionOKSendAlive then
    retcode := TRUE;
    Online := 1;
  else
    retcode := FALSE;
    Online :=0;
    TransferRateReceive := 0;
    TransferRateSend := 0;
  end_if;
  
  
  // Transferrate ermitteln ( Senden )
  if (ops.tAbsolute - sTimeStamp.udTransferrateSend) > sParameter.udTimeAliveSignal * udAliveError then    //20170410 DacPat v1.9 The time interval for the calculation of the transferrate ist now adjustable and depends on alive signal time
    sTimeStamp.udTransferrateSend := ops.tAbsolute;
    TransferRateSend:=DIV_AB_BY_C(A:=abs(sTransfer.dSendAmount-sTransfer.dSendAmountOld), B:=8, _C:=to_dint((sParameter.udTimeAliveSignal*udAliveError)/1000))*Online;
    sTransfer.dSendAmountOld := sTransfer.dSendAmount;
  end_if;
  
  // Transferrate ermitteln ( Empfangen )
  if (ops.tAbsolute - sTimeStamp.udTransferrateRecive) > sParameter.udTimeAliveSignal * udAliveError then    //20170410 DacPat v1.9 The time interval for the calculation of the transferrate ist now adjustable and depends on alive signal time
    sTimeStamp.udTransferrateRecive := ops.tAbsolute; 
    TransferRateReceive:=DIV_AB_BY_C(A:=abs(sTransfer.dReciveAmount - sTransfer.dReciveAmountOld), B:=8, _C:=to_dint((sParameter.udTimeAliveSignal*udAliveError)/1000))*Online;
    sTransfer.dReciveAmountOld := sTransfer.dReciveAmount;
  end_if;



END_FUNCTION

FUNCTION TCPCommunication::TransmitDataToStack
  VAR
    tmpEntrie : DataManagerFIFO::t_e_Entry;
    dRetcode : dint;
    pTCPHeader : ^t_s_Header;
    tmpSocket : dint;
    TimeStampStart : udint;
    TimeStampStop  : udint;
    StateOfDestination : dint;
    DataLength : udint;
    #ifdef TCPCom_Send_Acknowledge
    CallBackState : DataManagerPriority::t_e_CallbackState;
    #endif
    retcodetmp : dint;
    ReciveLog  : t_s_LogEntry;
    SendTimeOut : udint;
  END_VAR
  
  // Es besteht eine TCP - Verbindung
  if sConfig.bIsClient then
    tmpSocket := sParameter.dMainSocket;
  else
    tmpSocket := sParameter.dConnectionNr;
  end_if;
  
  if sConfig.bIsInternConnection then
    retcodetmp := 1000;
  else
    #ifndef _LSL_TARGETARCH_ARM
    if ((IsLars() = FALSE) & (IsSalamanderOS = FALSE)) then  //Hopale v1.14 changed if-statement so class works on x86-Salamander systems
      retcodetmp := OS_TCP_USER_IOCTLSOCKET(tmpSocket, WRITE_AVAILABLE, 0);
    else
      retcodetmp := 1000;
    end_if;
    #else
    retcodetmp := 1000;  
    #endif
  end_if;
  
  if retcodetmp > 0 then
  
  GetNextJob: 
    // Job vom Manager holen
    if coDataMng.GetNextJob(#tmpEntrie, pData:=pDataSend+sizeof(t_s_Header), plength:=#DataLength) = TRUE then
      
      // prüfen ob der Eintrag noch gültig ist , oder gelöscht wurde.
      if tmpEntrie.Header.Valid = TRUE then
        
        #ifdef TCPCom_TimeOutCheckBeforeSending
//wbr-20140729, check timeout =0        
        if tmpEntrie.Header.Timeout =0 | ( ops.tabsolute - tmpEntrie.Header.Timestamp ) < tmpEntrie.Header.Timeout then 
        #endif  
          // Daten welche gesendet werden aufbereiten. ( Header + UserDaten )
          pTCPHeader := pDataSend$^t_s_Header;
          pTCPHeader^.Commando := PCMD_Data;
          pTCPHeader^.DestinationID := tmpEntrie.Info.DestinationID;
          pTCPHeader^.SourceID := tmpEntrie.Info.SourceID;
          pTCPHeader^.PackageSize := DataLength + sizeof(t_s_Header);
          // Diese Daten werden für das Acknowledge benötigt.
          pTCPHeader^.JobId := tmpEntrie.Header.JobID;
          pTCPHeader^.pThisSource := tmpEntrie.Info.pthis ;
          pTCPHeader^.pCallBackSource := tmpEntrie.Info.pCallback;
          
          if(tmpEntrie.Info.pCallback <> nil) & (tmpEntrie.Info.pthis <> NIL) then
            // Aufruf das jetzt gesendet wird : Sending.
            tmpEntrie.Info.pCallback$UserCallbackJobState(tmpEntrie.Info.pthis, tmpEntrie.Header.JobID ,_MNG_Sending); 
          end_if;
          
          
          // Überprüfen ob Intern Verbindung oder eine Externe Verbindung über TCP besteht.
          if sConfig.bIsInternConnection then
            
            sTimeStamp.udAliveCounterExt := ops.tAbsolute;
            
            // Send Eintragen.
            AddToLog( pMng_HeaderTCP:=pTCPHeader, 
                      TimeOut:=tmpEntrie.Header.Timeout$dint, 
                      TimeStamp:=tmpEntrie.Header.Timestamp, 
                      Prio:=tmpEntrie.Header.Prio,
                      Direction:= 0);
            
            
            // Daten für Log zusammenbauen. ( Recive )
            
            _memset(dest:=#ReciveLog, usByte:=0, cntr:=sizeof(ReciveLog));
            ReciveLog.Header := pTCPHeader^;
            ReciveLog.Prio := tmpEntrie.Header.Prio;
            ReciveLog.TimeOut := tmpEntrie.Header.Timeout;
            
            
            // interne Verbindung , Daten durchreichen.
            StateOfDestination := coIntern.RecivedData(  DestinationID:= tmpEntrie.Info.DestinationID, 
                                                        SourceID:=tmpEntrie.Info.SourceID, 
                                                        udSize:=DataLength, 
                                                        pData:=pDataSend+sizeof(t_s_Header),
                                                        pLogEntrie:=#ReciveLog );
            
            
            sTransfer.dSendAmount += to_dint(DataLength);
            // Aufruf das geschickt wurde : Sended.
            if(tmpEntrie.Info.pCallback <> nil) & (tmpEntrie.Info.pthis <> NIL) then
              tmpEntrie.Info.pCallback$UserCallbackJobState(tmpEntrie.Info.pthis, tmpEntrie.Header.JobID ,_MNG_Sended );
            end_if;
            
            #ifdef TCPCom_Send_Acknowledge
            // Rückantwort schicken : Recived oder Destination nicht vorhanden.    
            if(tmpEntrie.Info.pCallback <> nil) & (tmpEntrie.Info.pthis <> NIL) then
              case StateOfDestination of
                1 : CallBackState := _MNG_Received;
               -1 : CallBackState := _MNG_NoReceiverConnected;
               -2 : CallBackState := _MNG_GlobalReceiveError; 
                
              end_case;
              
              tmpEntrie.Info.pCallback$UserCallbackJobState(tmpEntrie.Info.pthis, tmpEntrie.Header.JobID ,CallBackState );
            end_if;
            #endif

          else
            // Es besteht eine TCP - Verbindung
            if sConfig.bIsClient then
              tmpSocket := sParameter.dMainSocket;
            else
              tmpSocket := sParameter.dConnectionNr;
            end_if;
            
            TimeStampStart := OS_READMICROSEC();
            // Daten verschicken
            
            if tmpEntrie.Header.Timeout = 0 then
              SendTimeOut := TCPCom_DefSendTimeout;
            else
              SendTimeOut := tmpEntrie.Header.Timeout;
            end_if;
            dRetcode := OS_TCP_USER_SEND(tmpSocket, 
                                         pDataSend$^char, 
                                         pTCPHeader^.PackageSize, 
                                         0,
                                         SendTimeOut); 
             
            if  dRetcode = TCP_NOT_READY then
              ErrorSend += 1;
              eComSteps := TCPCom_CloseConnection;
            end_if;
       
            if dRetcode < 0 & 
               dRetcode <> TCP_NOT_READY then 
               
              ErrorSend +=1;
              eComSteps := TCPCom_CloseConnection;
              
            elsif dRetcode > 0 then  
              if dRetcode = TO_DINT(pTCPHeader^.PackageSize) then
                
                //sTimeStamp.udAliveCounterExt := ops.tAbsolute;
                sTransfer.dSendAmount += to_dint(pTCPHeader^.PackageSize);
                TimeStampStop := OS_READMICROSEC();
                TimeLastSend := TimeStampStop - TimeStampStart;
                
                // Aufruf das geschickt wurde : Sended.
                if(tmpEntrie.Info.pCallback <> nil) & (tmpEntrie.Info.pthis <> NIL) then
                  tmpEntrie.Info.pCallback$UserCallbackJobState(tmpEntrie.Info.pthis, tmpEntrie.Header.JobID , _MNG_Sended);
                end_if;
                
                // Eintrag in Log eintragen.
                AddToLog( pMng_HeaderTCP:=pTCPHeader, 
                          TimeOut:=tmpEntrie.Header.Timeout$dint, 
                          TimeStamp:=tmpEntrie.Header.Timestamp, 
                          Prio:=tmpEntrie.Header.Prio,
                          Direction:= 0);
                
              else
                ErrorSend +=1;
                eComSteps := TCPCom_CloseConnection;
              end_if;      
            end_if;
            
          end_if;
        
        #ifdef TCPCom_TimeOutCheckBeforeSending
        else
        
          // Timeout ist abgelaufen.
          
          if(tmpEntrie.Info.pCallback <> nil) & (tmpEntrie.Info.pthis <> NIL) then
            // Aufruf das die Timeout Zeit abgelaufen ist.
            tmpEntrie.Info.pCallback$UserCallbackJobState(tmpEntrie.Info.pthis, tmpEntrie.Header.JobID ,_MNG_TimeOut); 
          end_if;
          
          Goto GetNextJob;
          
        end_if;
        #endif
      
      else
        // Eintrag wurde glöscht,  nächsten Job holen.
        Goto GetNextJob;
      end_if;
    
    end_if;
  
  end_if;

END_FUNCTION

FUNCTION TCPCommunication::ReciveDataFromStack
VAR
	tmpSocket : dint;
  BytesAvailableOnStack : dint;
  Retcode  : dint;
  FirstHeader : t_s_Header;
  StartPointer : pvoid;
  WritePointer : pVoid;
  TimeStampStart : udint;
  TimeStampStop  : udint;
  BytesReadFromStack   : dint;
  TmpReadLen : udint;
  TimeStampRecive : udint;
END_VAR

  if sConfig.bIsClient then
    tmpSocket := sParameter.dMainSocket;
  else
    tmpSocket := sParameter.dConnectionNr;
  end_if;

  //  Prüfen ob Daten am Stack liegen
  BytesAvailableOnStack:=OS_TCP_USER_NREAD_AVAILABLE(tmpSocket);

  // Es liegen gültige Daten am Stack
  if BytesAvailableOnStack > 0 then
  
    // Nur wenn der Header vollständig ist weiterarbeiten.
    if BytesAvailableOnStack >= sizeof(t_s_Header) then
    
      udAliveCounterExtern +=1;
      sTimeStamp.udAliveCounterExt := ops.tAbsolute;
      TimeStampStart := OS_READMICROSEC();
      
      // Header auslesen
      Retcode := OS_TCP_USER_RECV(  tmpSocket, 
                                    (#FirstHeader)$^char, 
                                    sizeof(FirstHeader), 
                                    0, 
                                    sParameter.udTimeOutRecv);
                                    
      if Retcode > 0 then
      
        sTransfer.dReciveAmount += Retcode;
      
        // Es liegt mindestens ein vollständiges Paket am Stack
        if FirstHeader.PackageSize$dint <= BytesAvailableOnStack then
          
          // Restliche Daten abholen
          Retcode := OS_TCP_USER_RECV(  tmpSocket, 
                                        #tmpRecvData[0], 
                                        FirstHeader.PackageSize - sizeof(t_s_Header), 
                                        0, 
                                        sParameter.udTimeOutRecv);
                                        
          if Retcode > 0 then
          
            udAliveCounterExtern +=1;
            sTimeStamp.udAliveCounterExt := ops.tAbsolute;
            
            if FirstHeader.PackageSize$dint = (Retcode + sizeof(t_s_Header)) then
            
              sTransfer.dReciveAmount += Retcode;
              TimeStampStop := OS_READMICROSEC();
              TimeLastReceive := TimeStampStop - TimeStampStart;
              NewMessage(pTCPHeader:=#FirstHeader, pData:=#tmpRecvData[0], Length:=FirstHeader.PackageSize - sizeof(t_s_Header));
            
            else
              // Paket wurde nicht korrekt übertragen.
              ErrorRecive +=1;
            end_if;
          
          elsif (Retcode < 0) & (Retcode <> TCP_NOT_READY) then 

            ErrorRecive +=1;
          
          elsif (Retcode = 0) then
            
            ErrorRecive +=1;
            
          end_if;
    
        // Es liegen Daten am Stack , jedoch ist das Paket aufgeteilt in mehrere Pakete.
        elsif FirstHeader.PackageSize$dint > BytesAvailableOnStack then
        
          WritePointer := StartPointer := pDataRecive;
        
          BytesReadFromStack := sizeof(t_s_Header);
          TimeStampRecive := ops.tAbsolute;
          while 1 do
          
            // Prüfen ob noch Daten empfangen werden. ( wenn Sender z.B. in ein Timeout gelaufen ist )
            if (ops.tAbsolute - TimeStampRecive) <= 1sec then
            
              //  Prüfen wieviele Daten am Stack liegen
              BytesAvailableOnStack:=OS_TCP_USER_NREAD_AVAILABLE(tmpSocket);
              
              if (FirstHeader.PackageSize - to_udint(BytesReadFromStack)) > sizeof(tmpRecvData) then
                TmpReadLen := SIZEOF(tmpRecvData);
              else
                TmpreadLen := FirstHeader.PackageSize - to_udint(BytesReadFromStack);
              end_if;
              
              // Restliche Daten abholen
              Retcode := OS_TCP_USER_RECV(  tmpSocket, 
                                            #tmpRecvData[0], 
                                            TmpReadLen, 
                                            0, 
                                            sParameter.udTimeOutRecv);
                                            
              if Retcode > 0 then
              
                udAliveCounterExtern +=1;
                sTimeStamp.udAliveCounterExt := ops.tAbsolute;
              
                BytesReadFromStack += Retcode;
                sTransfer.dReciveAmount += Retcode;
                
                _memcpy(ptr1:=WritePointer, ptr2:=#tmpRecvData[0], cntr:=to_udint(Retcode));
                WritePointer += Retcode;
                
                // Prüfen ob Paket vollständig empfangen wurde.
                if FirstHeader.PackageSize = to_udint(BytesReadFromStack) then
                  
                  TimeStampStop := OS_READMICROSEC();
                  TimeLastReceive := TimeStampStop - TimeStampStart;
                  NewMessage(pTCPHeader:=#FirstHeader, pData:=StartPointer, Length:=FirstHeader.PackageSize - sizeof(t_s_Header));
                  
                  exit;
                end_if;
                
              elsif (Retcode < 0) & (Retcode <> TCP_NOT_READY) then 

                ErrorRecive +=1;
                exit;
                
              elsif (Retcode = 0) then
            
                ErrorRecive +=1;
                exit;
            
              end_if;
            
            // Timeout , es wurden zu lange keine Daten empfangen.
            else
              ErrorRecive +=1;
              exit;
            end_if;
            
          end_while;
        
        end_if;
      
      elsif (Retcode < 0) & (Retcode <> TCP_NOT_READY) then 

        ErrorRecive +=1;
        
      elsif (Retcode = 0) then
      
        ErrorRecive +=1;
        
      end_if;
    
    end_if;
  
  // Es ist ein Fehler aufgetreten.
  elsif (BytesAvailableOnStack < 0) & (BytesAvailableOnStack <> TCP_NOT_READY) then 
    
    ErrorRecive +=1;  
 
  end_if;


END_FUNCTION

FUNCTION TCPCommunication::SendAlive
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    Data : t_s_Alive;
    dRetcode : dint;
    tmpSocket : dint;
    TimeStampStart : udint;
    TimeStampStop  : udint;
    retcodetmp : dint;
  END_VAR

  retcode := FALSE;
  // Alive Paket zusammenbauen.
  Data.Header.Commando := PCMD_Alive;
  Data.Header.DestinationID := -1;
  Data.Header.SourceID := -1;
  Data.Header.JobId := -1;
  Data.Header.pCallBackSource := NIL;
  data.Header.pThisSource := NIL;
  Data.Header.PackageSize := sizeof(t_s_Header) + sizeof(t_s_Alive.udAliveCount);
  Data.udAliveCount := udAliveCounterIntern;
  udAliveCounterIntern +=1;

  // Unterscheidung ob Client oder Server. Es muß ein anderer Socket verwendet werden.
  if sConfig.bIsClient then
    tmpSocket := sParameter.dMainSocket;
  else
    tmpSocket := sParameter.dConnectionNr;
  end_if;
  
  #ifndef _LSL_TARGETARCH_ARM
  if ((IsLars() = False) & (IsSalamanderOS = FALSE)) then   //Hopale v1.14 changed if-statement so class works on x86-Salamander systems
    retcodetmp := OS_TCP_USER_IOCTLSOCKET(tmpSocket, WRITE_AVAILABLE, 0);
  else
    retcodetmp := 1000;
  end_if;
  #else
  retcodetmp := 1000;  
  #endif
  
  if retcodetmp >= 0 then
  
    TimeStampStart := OS_READMICROSEC();
    dRetcode := OS_TCP_USER_SEND(tmpSocket, 
                                 (#data)$^char, 
                                 Data.Header.PackageSize, 
                                 0,
                                 sParameter.udTimeOutAlive); 
     
    
    
    if dRetcode < 0 & 
       dRetcode <> TCP_NOT_READY then 
       
      eComSteps := TCPCom_CloseConnection;
      
    elsif dRetcode > 0 then  
      if dRetcode = TO_DINT(Data.Header.PackageSize) then
        // Aufruf das geschickt wurde : Sended.
        retcode := TRUE;
        sTransfer.dSendAmount += to_dint(Data.Header.PackageSize);
        TimeStampStop := OS_READMICROSEC();
        TimeLastSend := TimeStampStop - TimeStampStart;
        
        // Eintrag zum Log hinzufügen
        AddToLog( pMng_HeaderTCP:=#Data.Header, 
                  TimeOut:=sParameter.udTimeOutAlive$dint, 
                  TimeStamp:=ops.tAbsolute, 
                  Prio:=-1,
                  Direction := 0);
        
      end_if;      
    end_if;

  else
  
  end_if;

END_FUNCTION

FUNCTION TCPCommunication::SendAcknowledge
	VAR_INPUT
		pHeader 	: ^t_s_Header;
		State 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    Data : t_s__Acknowledge;
    dRetcode : dint;
    tmpSocket : dint;
    TimeStampStart : udint;
    TimeStampStop  : udint;
  END_VAR

  retcode := FALSE;
  // Alive Paket zusammenbauen.
  Data.Header.Commando := PCMD_Acknowledge;
  Data.Header.DestinationID := pHeader^.SourceID;
  Data.Header.SourceID := pHeader^.DestinationID;
  Data.Header.JobId := pHeader^.JobId;
  data.Header.pThisSource := pHeader^.pThisSource;
  data.Header.pCallBackSource := pHeader^.pCallBackSource;
  Data.dState := State;
  Data.Header.PackageSize := sizeof(t_s_Header) + sizeof(t_s__Acknowledge.dState);
  
  // Unterscheidung ob Client oder Server. Es muß ein anderer Socket verwendet werden.
  if sConfig.bIsClient then
    tmpSocket := sParameter.dMainSocket;
  else
    tmpSocket := sParameter.dConnectionNr;
  end_if;
  
  TimeStampStart := OS_READMICROSEC();
  dRetcode := OS_TCP_USER_SEND(tmpSocket, 
                               (#data)$^char, 
                               Data.Header.PackageSize, 
                               0,
                               sParameter.udTimeOutAlive); 

  if dRetcode < 0 & 
     dRetcode <> TCP_NOT_READY then 
     
    eComSteps := TCPCom_CloseConnection;
    
  elsif dRetcode > 0 then  
    if dRetcode = TO_DINT(Data.Header.PackageSize) then
      // Aufruf das geschickt wurde : Sended.
      retcode := TRUE;
      sTransfer.dSendAmount += to_dint(Data.Header.PackageSize);
      TimeStampStop := OS_READMICROSEC();
      TimeLastSend := TimeStampStop - TimeStampStart;
      
      // Eintrag zum Log hinzufügen.
      AddToLog( pMng_HeaderTCP:=#Data.Header, 
                  TimeOut:=sParameter.udTimeOutAlive$dint, 
                  TimeStamp:=ops.tAbsolute, 
                  Prio:=-1,
                  Direction := 0);
      
    end_if;      
  end_if;

END_FUNCTION

// ********************************************************************
// get ip over set data in string ram
// ********************************************************************
// ********************************************************************
FUNCTION TCPCommunication::GetIpOfServer
	VAR_INPUT
		pChar 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	tmpLength : udint;
  END_VAR

  retcode := FALSE;
  
  // Wurde ein String eingegeben ?
  tmpLength := coIpToConnect.GetLength();
  if tmpLength >= 7 then
    // String auslesen
    if coIpToConnect.ReadDataOff(udOff:=0, pData:=pchar, udMax:=16) > 0 then
      // Null Terminierung setzen
      (pChar + tmpLength)^ :=0;
      retcode := TRUE;
    end_if;
  end_if;

END_FUNCTION


FUNCTION GLOBAL TCPCommunication::GetOnlineState
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := Online;

END_FUNCTION

FUNCTION TCPCommunication::SetSocketOptions
	VAR_INPUT
		socket 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	option_name   : DINT;                      
    option_value  : DINT;                      
    optionalen    : DINT;
    dRetval       : DINT;
  END_VAR
  
  retcode := FALSE;
  
  // Variables for Socket-Option
  option_name   := SO_REUSEADDR;            // 4 ... Option that the Socket could be reopened
  option_value  := 1;                       // 1 ... Option should be activated
  optionalen    := sizeof(option_value);    // size of option_value
  
  dRetval := OS_TCP_USER_SETSOCKOPT(socket, SOL_SOCKET, option_name, #option_value$CHAR, optionalen); // Set Socket Option, that the Socket could be reopened
          
  if dRetval = 0 then
  
    option_name   := SO_DELAYED_ACK;          // 1024 ... _Delayd_Ack (the Acknowlegde should not be sended imidiatly)
    option_value  := 0;                       // 0 ... Option should be deactivated
    optionalen    := sizeof(option_value);    // size of option_value

    dRetval := OS_TCP_USER_SETSOCKOPT(socket, SOL_SOCKET, option_name, #option_value$CHAR, optionalen); // Set Socket Option, that the Socket could be reopened
    
    if dRetval = 0 then         
    
      option_name   := SO_NAGLE;                
      option_value  := 0;                       // 0 ... Option should be deactivated
      optionalen    := sizeof(option_value);    // size of option_value

      dRetval := OS_TCP_USER_SETSOCKOPT(socket, SOL_SOCKET, option_name, #option_value$CHAR, optionalen); // Set Socket Option, that the Socket could be reopened
      
      if dRetval = 0 then         
      
        // Set the socket to non-blocking (onoff=1) or blocking (onoff=0) mode
        dRetval := OS_TCP_USER_IOCTLSOCKET(socket, SET_SOCKET_MODE, 0);
        
        if dRetval = 0 then
          retcode := TRUE;
        else
          retcode := TRUE; // retcode := FALSE;  //testing
        end_if;
      end_if;
      
    end_if;
    
  end_if;

END_FUNCTION

FUNCTION TCPCommunication::NewMessage
	VAR_INPUT
		pTCPHeader 	: ^t_s_Header;
		pData 	: pVoid;
		Length 	: UDINT;
	END_VAR
  VAR
  	StateOfDestination : dint;
    #ifdef TCPCom_Send_Acknowledge
    Acknowledge : t_s__Acknowledge;
    CallBackState : DataManagerPriority::t_e_CallbackState;
    #endif
  END_VAR

  // Eintrag zum Log hinzufügen.
  AddToLog( pMng_HeaderTCP:=pTCPHeader, 
            TimeOut:=-1, 
            TimeStamp:=ops.tAbsolute, 
            Prio:=-1,
            Direction := 1);

  case pTCPHeader^.Commando of
          
    // Alive Signal empfangen
    PCMD_Alive: 
    
    // Daten Paket empfangen.
    PCMD_Data:  
    
      StateOfDestination :=   RecivedData(  DestinationID:= pTCPHeader^.DestinationID, 
                                            SourceID:=pTCPHeader^.SourceID, 
                                            udSize:= Length, 
                                            pData:=pData);
                              

      #ifdef TCPCom_Send_Acknowledge
      SendAcknowledge(pHeader:=pTCPHeader, State:=StateOfDestination);
      #endif

      
    #ifdef TCPCom_Send_Acknowledge  
    // Rückantwort bekommen
    PCMD_Acknowledge : 
    
      Acknowledge.header := pTCPHeader^;
      Acknowledge.dState := (pData$^dint)^;
      
      if(Acknowledge.Header.pCallBackSource <> nil) & (Acknowledge.Header.pThisSource <> NIL) then
        case Acknowledge.dState of
          1 : CallBackState := _MNG_Received;
         -1 : CallBackState := _MNG_NoReceiverConnected;
         -2 : CallBackState := _MNG_GlobalReceiveError; 
        end_case;
        Acknowledge.Header.pCallBackSource$UserCallbackJobState(Acknowledge.Header.pThisSource, Acknowledge.Header.JobId ,CallBackState );
      end_if;
    #endif  
  end_case;

END_FUNCTION

FUNCTION TCPCommunication::AddToLog
	VAR_INPUT
		pMng_HeaderTCP 	: ^t_s_Header;
		TimeOut 	: DINT;
		TimeStamp 	: UDINT;
		Prio 	: DINT;
		Direction 	: DINT;
	END_VAR
  VAR
  	tmpLogEntrie : t_s_LogEntry;
    Valid :  Bool;
  END_VAR

  // Rückgabewert initialisieren.
  valid := FALSE;
  
  // Nur Eintragen , wenn aktiviert.
  if LogEnable <> 0 then
  
    // Daten zusammenbauen.
    tmpLogEntrie.header       := pMng_HeaderTCP^;
    tmpLogEntrie.Prio         := prio;
    tmpLogEntrie.TimeStamp    := TimeStamp;
    tmpLogEntrie.TimeOut$dint      := TimeOut;
    tmpLogEntrie.TCPType      := Direction;
    
    // nachsehen , welche DAten gelogged werden sollen.
    case tmpLogEntrie.Header.Commando of
    
      PCMD_Alive :        valid := sConfig.bLogAlive;
      
      PCMD_Data  :        valid := sConfig.bLogData ;
                          if Valid = TRUE then
                            // DatenFilter Prüfen
                            if IsClientConnected(input:=#coLogFilter) then
                              valid  := coLogFilter.CheckFilter(#tmpLogEntrie);
                            end_if;
                          end_if;
      
      PCMD_Acknowledge :  valid := sConfig.bLogAcknowledge;
                          if Valid = TRUE then
                            // DatenFilter Prüfen
                            if IsClientConnected(input:=#coLogFilter) then
                              valid  := coLogFilter.CheckFilter(#tmpLogEntrie);
                            end_if;
                          end_if;
    else
      // Statusmeldungn
      valid := TRUE;
    end_case;

    // Prüfen ob die Daten in den Buffer übernommen werden .
    if valid = TRUE then
      // nur eintragen , wenn der Buffer erfolgreich initialisert wurde.
      if sConfig.bLogBufferOK = TRUE then
        // Eintragen.
        RamRingBuffer.AddRecord(psrc:=#tmpLogEntrie);
      end_if;
      
    end_if;
  
  end_if;
  
  
END_FUNCTION

FUNCTION TCPCommunication::LogStatus
	VAR_INPUT
		Commando 	: t_e_PackageCmd;
	END_VAR
  VAR
    tmpEntry : t_s_Header;
  END_VAR

  // lokale Veriable initialisieren.
  _memset(dest:=#tmpEntry, usByte:=0, cntr:=sizeof(t_s_Header));
  // Commando in die Struktur eintragen.
  tmpEntry.Commando := Commando;
  // Daten eintragen.
  AddToLog(pMng_HeaderTCP:=#tmpEntry, TimeOut:=0, TimeStamp:=0, Prio:=0, Direction:=2);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL TCPCommunication::ResetLogBuffer::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	if LogEnable = 0 then
    RamRingBuffer.DelAllRecords();
  end_if;
	result := input;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL TCPCommunication::CyWork
VAR_INPUT
  EAX 	: UDINT;
END_VAR
VAR_OUTPUT
  state (EAX) 	: UDINT;
END_VAR

  #ifdef TCPCom_Runtime
    if (ops.tAbsolute - Runtime.udTimeStamp) > TCPCom_Runtime then

      Runtime.udTimeStamp := ops.tAbsolute;

      if (Runtime.udCountAct = Runtime.udCountLast) & (Runtime.udCountLast > 0) & (sConfig.bCILOK = TRUE) then // HubChr v1.7 suppress first runtime error in case of slow bootup

        if (ErrRuntime = 0) then

          ErrRuntime := 1;
          ErrRuntime.Write(input := ErrRuntime);

          #ifdef TCPCom_Runtime_TraceMsg
            SetTraceRuntimeError();
          #endif

          Online := 0;

        end_if;

      else

        if (ErrRuntime = 1) then 

          ErrRuntime := 0;
          ErrRuntime.Write(input := ErrRuntime);

          #ifdef TCPCom_Runtime_TraceMsg
            ResTraceRuntimeError();
          #endif

        end_if;

      end_if;

      Runtime.udCountLast := Runtime.udCountAct;

    end_if;
  #endif

	state := READY;

END_FUNCTION

FUNCTION TCPCommunication::SetTraceRuntimeError
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
  ErrTxt    : ARRAY [0..255] OF CHAR;
  ErrValue  : ARRAY [0..255] OF CHAR;
END_VAR

  Retcode := 0;

  // -----------------------------------------------------------------
  // - CREATE TRACE MESSAGE -
  // -----------------------------------------------------------------

  coSigCLib.StrCpy(dst0 := #ErrTxt[0],
                   src0 := "TCPCommunication Task Runtime Error, Name: ");

  coSigCLib.StrCat(ps1 := #ErrTxt[0],
                   ps2 := #szTaskName[0]);

  coSigCLib.StrCat(ps1 := #ErrTxt[0],
                   ps2 := ", Runtime: ");

  coSigCLib.IToA(val  := TCPCom_Runtime,
                 dst  := #ErrValue[0],
                 base := 10);

  coSigCLib.StrCat(ps1 := #ErrTxt[0],
                   ps2 := #ErrValue[0]);


  // -----------------------------------------------------------------
  // - SET TRACE MESSAGE -
  // -----------------------------------------------------------------

  TRACE_ERR(#ErrTxt[0]);

END_FUNCTION

FUNCTION TCPCommunication::ResTraceRuntimeError
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
  ErrTxt    : ARRAY [0..255] OF CHAR;
  ErrValue  : ARRAY [0..255] OF CHAR;
END_VAR

  Retcode := 0;

  coSigCLib.StrCpy(dst0 := #ErrTxt[0],
                   src0 := "TCPCommunication Task Continues, Name: ");

  coSigCLib.StrCat(ps1 := #ErrTxt[0],
                   ps2 := #szTaskName[0]);

  coSigCLib.StrCat(ps1 := #ErrTxt[0],
                   ps2 := ", Runtime: ");

  coSigCLib.IToA(val  := TCPCom_Runtime,
                 dst  := #ErrValue[0],
                 base := 10);

  coSigCLib.StrCat(ps1 := #ErrTxt[0],
                   ps2 := #ErrValue[0]);

  TRACE_WARN(#ErrTxt[0]);

END_FUNCTION

FUNCTION TCPCommunication::CreateTaskName
VAR_INPUT
  pTaskName 	: ^CHAR;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
  udCRC32       : UDINT;
  udStrLen      : UDINT;
  szObjectName  : ARRAY [0..255] OF CHAR;
  szCRC32       : ARRAY [0..15]  OF CHAR;
END_VAR

  Retcode := 0;

  if (pTaskName = NIL) then
    Retcode := -1001;
    return;
  end_if;


  coSigCLib.StrCpy(dst0 := pTaskName,
                   src0 := TCPCom_TaskName);

  _GetObjName(pThis := this,
              pName := #szObjectName[0]);

  udStrLen := coSigCLib.StrLen(str := #szObjectName[0]);

  udCRC32  := CheckSum.CRC32(pBuffer  := #szObjectName[0],
                             len      := udStrLen,
                             CrcStart := 0);

  coSigCLib.IToA(val  := udCRC32$DINT,
                 dst  := #szCRC32[0],
                 base := 0x10);

  coSigCLib.StrCat(ps1 := pTaskName,
                   ps2 := #szCRC32[0]);

  udStrLen := coSigCLib.StrLen(str := pTaskName);

  ThreadName.WriteDataOff(udLen := udStrLen,
                          udOff := 0,
                          pData := pTaskName);

END_FUNCTION

FUNCTION GLOBAL TCPCommunication::SetParameter
VAR_INPUT
  ParaNo 	: DINT;
  ParaVal 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := 0;

  case ParaNo of

    //**************************************************************************
    TCPCom_ParaWR_ComPort: // - SET COM PORT -
    //**************************************************************************

      ComPort := ParaVal$UDINT;

    //20170410 DacPat v1.9 Added SetParameter for the time interval between each transferrate calculation and each send alive signal 
    //**************************************************************************
    TCPCom_ParaWR_MissingAliveError: // - SET CALC TIME FOR TRANSFERRATE -
    //**************************************************************************
    
      udAliveError := ParaVal$UDINT;
      
    //**************************************************************************
    TCPCom_ParaWR_AliveSignalTime: // - SET TIME FOR SENDING ALIVE SIGNAL -
    //**************************************************************************
    
      sParameter.udTimeAliveSignal := ParaVal$UDINT;
      
    //**************************************************************************
    TCPCOM_ParaWR_TaskPriority: // - SET TASK PRIORITY FOR THE TCP TASK -
    //**************************************************************************
    
      uiTaskPriority := ParaVal$UINT;

    //**************************************************************************
    else // - INVALID PARAMETER NUMBER
    //**************************************************************************

      Retcode := -1001;


  end_case;

END_FUNCTION

FUNCTION GLOBAL TCPCommunication::ReadParameter
VAR_INPUT
  ParaNo 	  : DINT;
  pParaVal 	: ^DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := 0;

  if (pParaVal = NIL) then
    Retcode := -1002;
  end_if;

  case ParaNo of

    //**************************************************************************
    TCPCom_ParaRD_ComPort: // - READ COM PORT -
    //**************************************************************************

      pParaVal^$UDINT := ComPort;

    //20170410 DacPat v1.9 Added ReadParameter for the time interval between each transferrate calculation and each send alive signal 
    //**************************************************************************
    TCPCom_ParaRD_MissingAliveError: // - READ ERROR THRESHOLD FOR ALIVE SIG -
    //**************************************************************************
    
      pParaVal^$UDINT := udAliveError;
      
    //**************************************************************************
    TCPCom_ParaRD_AliveSignalTime: // - READ TIME FOR SENDING ALIVE SIGNAL -
    //**************************************************************************
    
      pParaVal^$UDINT := sParameter.udTimeAliveSignal;
      
    //**************************************************************************
    TCPCom_ParaRD_TaskPriority: // - READ TASK PRIORITY FOR THE TCP TASK -
    //**************************************************************************
    
      pParaVal^$UINT := uiTaskPriority;

    //**************************************************************************
    else // - INVALID PARAMETER NUMBER
    //**************************************************************************

      Retcode := -1001;


  end_case;

END_FUNCTION

FUNCTION TCPCommunication::ComStop
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := 0;

  sConfig.bComDeactivated := true;

  if (eComSteps > TCPCom_StartConnecting) then
    eComSteps := TCPCom_CloseConnection;
  else
    eComSteps := TCPCom_Deactivated;
  end_if;

END_FUNCTION

FUNCTION TCPCommunication::ComStart
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := 0;

  sConfig.bComDeactivated  := false;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL TCPCommunication::DeactivateCom::Write
VAR_INPUT
  input (EAX) 	: DINT;
END_VAR
VAR_OUTPUT
  result (EAX) 	: DINT;
END_VAR
VAR
	dRet          : DINT;
END_VAR

  case DeactivateCom of

    //*****************************************************************************
    0: // - COMMUNICATION IS ACTIVATED
    //*****************************************************************************
      if (input = 1) then
        dRet := ComStop();
        if (dRet = 0) then
          DeactivateCom := input;
          result := DeactivateCom;
        else
          result := ACCESS_DENIED;
        end_if;
      else
        result := DeactivateCom;
      end_if;

    //*****************************************************************************
    1: // - COMMUNICATION IS DEACTIVATED
    //*****************************************************************************
      if (input = 0) then
        dRet := ComStart();
        if (dRet = 0) then
          DeactivateCom := input;
          result := DeactivateCom;
        else
          result := ACCESS_DENIED;
        end_if;
      else
        result := DeactivateCom;
      end_if;

  end_case;

END_FUNCTION

#define DESTPLC_WINPC_98    0x000001B // LARS, Standard PC, Win98/ME
#define DESTPLC_WINPC_NT    0x000001C // LARS, Standard PC, WinNT/Win2000/WinXP
#define DESTPLC_WINIPC_98   0x000001D // LARS, IPC, Win98/ME
#define DESTPLC_WINIPC_NT   0x000001E // LARS, IPC, WinNT/Win2000/WinXP

FUNCTION TCPCommunication::IsLars
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := FALSE;
  case _WHOAMI of
    DESTPLC_WINPC_98,
    DESTPLC_WINPC_NT,
    DESTPLC_WINIPC_98,
    DESTPLC_WINIPC_NT : retcode := TRUE;
  end_case;


END_FUNCTION


FUNCTION TCPCommunication::DelayComTask
	VAR_INPUT
		udDelay 	: UDINT;
	END_VAR

  if IsSalamanderOS = TRUE then 
    OSSD_DELAY(pCIL_DEBUG, udDelay*1000); // Microseconds!
  else
    coMultiTask.TASKDELAY(udDelay);
  end_if;
    
  

END_FUNCTION
