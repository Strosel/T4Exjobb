//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define USB_T21L19T1T0_02_VENDORID  16#5112
#define USB_T21L19T1T0_02_PRODUCTID 2
#define USB_T21L19T1T0_02_VARIANT   65535 //no care

#define USB_T21L19T1T0_02_POLLTIME 8
#define USB_T21L19T1T0_02_MAXCONTRAST 255

#define USB_T21L19T1T0_02event_MOVE    0x01 // input movement
#define USB_T21L19T1T0_02event_PRESS   0x02 // button press
#define USB_T21L19T1T0_02event_RELEASE 0x04 // button release
#define USB_T21L19T1T0_02event_KEYDN   0x08 // key press
#define USB_T21L19T1T0_02event_KEYUP   0x10 // key release

#define USB_T8L2T1T0_02_TIMEOUT 10

#define OS_STARTVERSION_SALAMANDER 0x9100  // salamder starts with v 9.1.00

#ifndef STOREEVENTMAKRO
  #define OS_StoreEvent(p1) _LSL_POS^.piLSE^.pOS_StoreEvent $ P_OS_StoreEvent(p1)
  #define OS_StoreEventEx(p1,p2) _LSL_POS^.piLSE^.pOS_StoreEventEx $ P_OS_StoreEventEx(p1,p2)
  #define STOREEVENTMAKRO
  //[#ENGLISH]
  // This is the macro for the OS event handler
  // [Globals]	
  // [Members]	
  // [Locals]
  // [>pEvent]
  FUNCTION GLOBAL __cdecl P_OS_StoreEvent
  VAR_INPUT
    pEvent        : pVoid;
  END_VAR;
  
  //[#ENGLISH]
  // This is the macro for the OS event handler (Ex)
  // [Globals]	
  // [Members]	
  // [Locals]
  // [>pEvent]
  FUNCTION GLOBAL __cdecl P_OS_StoreEventEx
  VAR_INPUT
    pEvent        : pVoid;
    size          : udint;
  END_VAR; 
#endif

#define DISPLAYSETTINGS_GRAPHIX_MAX_BRIGHTNESS  255 //(2^8-1) = 255
#define DISPLAYSETTINGS_USB_MAX_BRIGHTNESS      255 //(2^8-1) = 255
#define DISPLAYSETTINGS_MIN_BRIGHTNESS_INPUT      0 
#define DISPLAYSETTINGS_MAX_BRIGHTNESS_INPUT    100 

#define DISPLAYSETTINGS_MIN_PWM_INPUT          0
#define DISPLAYSETTINGS_MAX_PWM_INPUT          100 
#define DISPLAYSETTINGS_PWM_PERIODE_TIME       10000

#define USB_REQ_TIMER_UP 1000

#define DISPLAYSETTINGS_USB_INIT_ERROR    -1

#define DISPLAYSETTINGS_BRIGHTNESS_ERROR    -1

#define DISPLAYSETTINGS_TASKOBJECT_NOT_FOUND    -5

#define DISPLAYSETTINGS_STATE_OK                0

#define DISPLAYSETTINGS_BACKGROUNDTASK_ERROR    -1
#define DISPLAYSETTINGS_CAN_OBJECT_ERROR        -2
#define DISPLAYSETTINGS_GRAPHIX_ERROR           -3
#define DISPLAYSETTINGS_PSOC_ERROR               -4

#define DISPLAYSETTINGS_BACKLIGHT_SWITCHOFF_TIME 1000 //1 second
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_Usb.h"
#include "..\..\Source\interfaces\lsl_st_kernel.h"
#include "..\..\Source\interfaces\lsl_st_pci.h"
#include "..\..\Source\interfaces\lsl_st_pwm.h"
#include "..\..\Source\interfaces\lsl_st_gpio.h"

(*!
<Class
	Name               = "DisplaySettings"
	Revision           = "1.37"
	GUID               = "{85D369AD-5E9E-4A68-A5C3-748BD87F05E5}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	DefCyclictime      = "8 ms"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(630,120)"
	Comment            = "Class to set brightness and to switch background on Displays">
	<Channels>
		<Server Name="Brightness" GUID="{EEE3950E-30E4-49F5-B4F2-F893767931F7}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="SRam" Comment="Set brightness to written value (0-100 percent, where 0 is very dark and 100 is very bright)."/>
		<Server Name="ClassState" GUID="{88CE3435-E608-4737-8A0F-444F8517D9DC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0...class ok&#13;&#10;-1..error on ETV (needs Background task)&#13;&#10;-2..error on C-IPC (CAN Object send error)&#13;&#10;-3..error on graphix interface&#13;&#10;-4..error on C-IPC (PsoC Commando send failed)"/>
		<Server Name="LogoBluePWM" GUID="{5EA035B0-EC12-4C4C-BED6-3019AA65685A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set PWM of logo backlight by writing on this output.&#13;&#10;Range is from 0 to 100.&#13;&#10;-1 ... not supported&#13;&#10;0   ... off&#13;&#10;100 ... very bright"/>
		<Server Name="LogoGreenPWM" GUID="{345941A6-9101-41AB-8AFA-E6B2688EC428}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set PWM of logo backlight by writing on this output.&#13;&#10;Range is from 0 to 100.&#13;&#10;-1 ... not supported&#13;&#10;0   ... off&#13;&#10;100 ... very bright"/>
		<Server Name="LogoRedPWM" GUID="{9B430016-E7E2-49FA-9CB3-27B9FC8E9046}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set PWM of logo backlight by writing on this output.&#13;&#10;Range is from 0 to 100.&#13;&#10;-1 ... not supported&#13;&#10;0   ... off&#13;&#10;100 ... very bright"/>
		<Server Name="State" Visualized="true" Comment="Display class state&#13;&#10; 0..Ok&#13;&#10;-1..failed to initialize USB device&#13;&#10;-2..USB not supported&#13;&#10;-3..out of memory">
		</Server>
		<Server Name="SwitchBacklight" GUID="{409AFA9E-4086-4DE5-90C4-0C3802E11F4B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="0=turn off backlight, 1=turn on backlight&#13;&#10;Depends on Hardware, the graphic controller and/or the backlight will be switched"/>
		<Client Name="To_Can" Required="false" Internal="false" Comment="connect to class _CAN automatically"/>
		<Client Name="To_Graphix" Required="false" Internal="false" Comment="connect to class _Grphix automatically"/>
		<Client Name="To_OSKernel" Required="false" Internal="false" Comment="connect to _OSKernel automatically"/>
		<Client Name="To_TaskObjectControl" Required="false" Internal="false" Comment="connect to class _TaskObjectControl automatically"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_Usb.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_kernel.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_pci.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_pwm.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_gpio.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="SvePau"/>
		<Dokumentation Revision="1.37" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="1.36" Date="16.08.2016" Author="ZoePat" Company="Sigmatek" Description="Initvalue for LogoPWM is not supported anymore, because OS uses Logo like &quot;Run-Led&quot;."/>
		<Dokumentation Revision="1.35" Date="12.05.2016" Author="ZoePat" Company="Sigmatek" Description="Set Logo PWM according to OS Interfacepointer (-1 is invalid)."/>
		<Dokumentation Revision="1.34" Date="15.03.2016" Author="EisMic" Company="Sigmatek" Description="Removed internal placed object Beeper. Object was not used from this class but occured a warning with ARM Compiler."/>
		<Dokumentation Revision="1.33" Date="07.08.2014" Author="EisMic" Company="Sigmatek" Description="Change backlight from CPUS with Salamander or Edge CPUs is working again."/>
		<Dokumentation Revision="1.32" Date="18.04.2014" Author="EisMic" Company="Sigmatek" Description="Added an OnDelay for display backlight switch off."/>
		<Dokumentation Revision="1.31" Date="08.04.2014" Author="EisMic" Company="Sigmatek" Description="Added PsoC commando to switch backlight."/>
		<Dokumentation Revision="1.30" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Added query for IMX6 in ReadMethod of SwitchBacklight"/>
		<Dokumentation Revision="1.20" Date="04.12.2013" Author="HlaWol&#13;&#10;RamAnd&#13;&#10;BeiWol" Company="Sigmatek" Description="changed platform query from IMX6 to OS version salamander&#13;&#10;Added include of lsl_st_pci.h&#13;&#10;Added support for ARM ETVs&#13;&#10;Corrected check of background task settings&#13;&#10;The task setting for background task didn&apos;t work with salamader (only required if existing object is updated)."/>
		<Dokumentation Revision="1.10" Date="30.08.2013" Author="FucHer" Company="Sigmatek" Description="AWL deactivated for ARM."/>
		<Dokumentation Revision="1.0" Date="18.07.2013" Author="BeiWol" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="DisplaySettings">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{918CABD7-D9D4-4008-BB8D-D4EAD78717C2}"
				Class      = "USB_DataExchange"
				Position   = "(256,120)"
				Visualized = "false">
				<Channels>
					<Server Name="State"/>
					<Client Name="To_MultiTask"/>
					<Client Name="To_StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(920,210),(748,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using USB_DataExchange

DisplaySettings : CLASS
: USB_DataExchange
	TYPE
	  tPowerMng : BSINT  //! <Type Comment="Type for Power Management Register Mapping." Name="tPowerMng"/>
	  [
	    1 SupplyEnable5V,
	    2 LVDSDriverEnable,
	    3 DisplayEnable,
	    4 DisplayBacklightEnable,
	    5 DisplayPowerOn,
	  ];
#pragma pack(push, 1)
	  tPWM : STRUCT  //! <Type Comment="Type for PWM Register Mapping." Name="tPWM"/>
	    PreScaler : INT;
	    PWMPeriod : INT;
	    PWMOutputOnTime : INT;
	    Reserved : USINT;
	    ControlStatusReg : BSINT
	    [
	      1 SWEnable,
	      2 HWEnable,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Brightness 	: SvrCh_DINT;
	SwitchBacklight 	: SvrCh_DINT;
	ClassState 	: SvrCh_DINT;
	LogoRedPWM 	: SvrCh_DINT;
	LogoGreenPWM 	: SvrCh_DINT;
	LogoBluePWM 	: SvrCh_DINT;
  //Clients:
	To_Can 	: CltChCmd__Can;
	To_OSKernel 	: CltChCmd__OSKernel;
	To_TaskObjectControl 	: CltChCmd__TaskObjectControl;
	To_Graphix 	: CltChCmd__Grafix;
  //Variables:
		us_index 	: USINT;			//! <Variable Comment="USB device Index." Name="us_index"/>
		sd_IsoInReady 	: DINT;			//! <Variable Comment="Isochronous USB In Ready flag." Name="sd_IsoInReady"/>
		sd_AsyOutReady 	: DINT;			//! <Variable Comment="Asynchronous USB Out Ready flag." Name="sd_AsyOutReady"/>
		sd_AsyInReady 	: DINT;			//! <Variable Comment="Asynchronous USB In Ready flag." Name="sd_AsyInReady"/>
		p_PipeIsoIn 	: pVoid;			//! <Variable Comment="Pointer to Isochronous USB Pipe." Name="p_PipeIsoIn"/>
		p_PipeAsyOut 	: pVoid;			//! <Variable Comment="Pointer to Asynchronous USB Pipe." Name="p_PipeAsyOut"/>
		p_PipeAsyIn 	: pVoid;			//! <Variable Comment="Pointer to Asynchronous USB Pipe." Name="p_PipeAsyIn"/>
		us_FW 	: USINT;			//! <Variable Comment="USB Firmware version." Name="us_FW"/>
		pPowerMng 	: ^tPowerMng;			//! <Variable Comment="Pointer to Power Management Register." Name="pPowerMng"/>
		pPWM 	: ^tPWM;			//! <Variable Comment="Pointer to PWM Register." Name="pPWM"/>
		DisplayInternal 	: DINT;			//! <Variable Comment="Marker for SwitchBacklight." Name="DisplayInternal"/>
		ud_UsbReqLastCall 	: UDINT;			//! <Variable Comment="Usb request time marker." Name="ud_UsbReqLastCall"/>
		sStatus 	: DINT;			//! <Variable Comment="VGA status variable." Name="sStatus"/>
		newBrightness 	: DINT;			//! <Variable Comment="Temorary variable for set brightness handling." Name="newBrightness"/>
		actBrightness 	: DINT;			//! <Variable Comment="Temorary variable for set brightness handling." Name="actBrightness"/>
		b_TaskChecked 	: BOOL;
		ud_LastBacklightSwitchOff 	: UDINT;
		b_CheckLater 	: BOOL;
		pPWMColor 	: ^LSL_PWM_TYPE;
		pGPIO 	: ^LSL_GPIO_TYPE;
		dLastRed 	: DINT;
		dLastGreen 	: DINT;
		dLastBlue 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION DisplaySettings
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION GLOBAL SetBrightness
		VAR_INPUT
			Value 	: USINT;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
	
	FUNCTION CallbackIsoIn
		VAR_INPUT
			p_Pipe 	: PPIPEDATA;
			sd_ErrorCode 	: DINT;
			p_Data 	: pVoid;
			sd_DataLength 	: DINT;
		END_VAR;
	
	FUNCTION CallbackAsyOut
		VAR_INPUT
			p_Pipe 	: PPIPEDATA;
			sd_ErrorCode 	: DINT;
			p_Data 	: pVoid;
			sd_DataLength 	: DINT;
		END_VAR;
	
	FUNCTION CallbackAsyIn
		VAR_INPUT
			p_Pipe 	: PPIPEDATA;
			sd_ErrorCode 	: DINT;
			p_Data 	: pVoid;
			sd_DataLength 	: DINT;
		END_VAR;
	
	FUNCTION AWL BackLight_CIPC
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION AWL SCREENLIGHT
		VAR_INPUT
			onoff0 	: UDINT;
		END_VAR;
	
	FUNCTION ChangeBrightness
		VAR_INPUT
			Value 	: USINT;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Brightness::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SwitchBacklight::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SwitchBacklight::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LogoRedPWM::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LogoGreenPWM::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LogoBluePWM::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Can
#pragma usingLtd _Grafix
#pragma usingLtd _OSKernel
#pragma usingLtd _TaskObjectControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DisplaySettings::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DISPLAYSETTINGS
1$UINT, 37$UINT, (SIZEOF(::DisplaySettings))$UINT, 
6$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3306153856), "DisplaySettings", //Class
TO_UDINT(1659734526), "USB_DataExchange", 1$UINT, 13$UINT, //Baseclass
//Servers:
(::DisplaySettings.Brightness.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3538537436), "Brightness", 
(::DisplaySettings.SwitchBacklight.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2450537368), "SwitchBacklight", 
(::DisplaySettings.ClassState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1096059024), "ClassState", 
(::DisplaySettings.LogoRedPWM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2738152523), "LogoRedPWM", 
(::DisplaySettings.LogoGreenPWM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3291842996), "LogoGreenPWM", 
(::DisplaySettings.LogoBluePWM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4097197723), "LogoBluePWM", 
//Clients:
(::DisplaySettings.To_Can.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1707743844), "To_Can", TO_UDINT(3102794146), "_Can", 0$UINT, 4$UINT, 
(::DisplaySettings.To_OSKernel.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2681344549), "To_OSKernel", TO_UDINT(3045737964), "_OSKernel", 0$UINT, 4$UINT, 
(::DisplaySettings.To_TaskObjectControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2751224004), "To_TaskObjectControl", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::DisplaySettings.To_Graphix.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2326662746), "To_Graphix", TO_UDINT(197854207), "_Grafix", 1$UINT, 2$UINT, 
END_FUNCTION


#define USER_CNT_DisplaySettings 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DisplaySettings] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DisplaySettings::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= USB_DataExchange::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= USB_DataExchange::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, USB_DataExchange::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_DisplaySettings;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	USB_DataExchange::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF USB_DataExchange::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Brightness.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Brightness::Write() );
	IF Brightness.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SwitchBacklight.pMeth			:= StoreMethod( #SwitchBacklight::Read(), #SwitchBacklight::Write() );
	IF SwitchBacklight.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LogoRedPWM.pMeth			:= StoreMethod( #M_RD_DIRECT(), #LogoRedPWM::Write() );
	IF LogoRedPWM.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LogoGreenPWM.pMeth			:= StoreMethod( #M_RD_DIRECT(), #LogoGreenPWM::Write() );
	IF LogoGreenPWM.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LogoBluePWM.pMeth			:= StoreMethod( #M_RD_DIRECT(), #LogoBluePWM::Write() );
	IF LogoBluePWM.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= DisplaySettings();

END_FUNCTION

//{{LSL_IMPLEMENTATION
#include <lsl_st_kernel.h>
#include <lsl_st_pci.h>

FUNCTION VIRTUAL GLOBAL DisplaySettings::Init
  VAR
    sd_retval     : DINT;
    objInfo       : LSLOBJ_INFO;
  END_VAR  
  
  // we call baseclass on every init run
  USB_DataExchange::Init(); 


  //first init
  if ( b_TaskChecked = FALSE ) then

    b_TaskChecked := TRUE;

    // if background task is not active => activate it with 100ms
    sd_retval := To_TaskObjectControl.GetObjectInfo(thispointer:=this, tasktype:=OBJ_BG, objinfo:=#objInfo);
    
    // if there is no background for this object
    if ( sd_retval = DISPLAYSETTINGS_TASKOBJECT_NOT_FOUND ) then
      sd_retval := To_TaskObjectControl.ChangeObjectState(thispointer:=this, actioncmd:=ACTION_ADD, tasktype:=OBJ_BG, debugobj:=0, newtime:=100);
      
      // couldn't add background task => class will not work
      if sd_retval <> 0 then
        ClassState := DISPLAYSETTINGS_BACKGROUNDTASK_ERROR;//EtvBlError := 1;
        return;
      end_if;

      sd_retval := To_TaskObjectControl.ChangeObjectState(thispointer:=this, actioncmd:=ACTION_CONTNUE, tasktype:=OBJ_BG, debugobj:=0, newtime:=100);
      
      // couldn't activate background task => class will not work
      if sd_retval <> 0 then
        ClassState := DISPLAYSETTINGS_BACKGROUNDTASK_ERROR;//EtvBlError := 1;
        return;
      end_if;

    end_if;
  end_if;  

  

  if (_FirstScan = true) then
  // last init run
    if(State = DISPLAYSETTINGS_STATE_OK) & (_RtOSversion < OS_STARTVERSION_SALAMANDER) then 

    // just for platforms using USB for brightness control and RTOS 
    
      // Attention: PsoC always has the features to disable display / control brightness
      //            It is not possible to find out (at least not through USB) if this feature 
      //            is actually available on the current platform!
      if( USB_InitDevice( ui_VendorID := 16#5112,
                          ui_ProductID := 16#02, 
                          ui_Variant := 16#FFFF, 
                          p_CallbackIsoIn := #CallbackIsoIn() , 
                          p_CallbackAsyOut := #CallbackAsyOut(), 
                          p_CallbackAsyIn := #CallbackAsyIn(), 
                          p_this := this,
                          p_PipeIsoIn := #p_PipeIsoIn,
                          p_PipeAsyOut := #p_PipeAsyOut,
                          p_PipeAsyIn := #p_PipeAsyIn, 
                          p_Index := #us_index,
                          p_Firmware := #us_FW ) )then
                          
        State := DISPLAYSETTINGS_USB_INIT_ERROR;
      else
        State := DISPLAYSETTINGS_STATE_OK;
      end_if;

      if( State = DISPLAYSETTINGS_USB_INIT_ERROR)then
      
        State := DISPLAYSETTINGS_STATE_OK;   // USB_InitDevice needs State = ok
        
        if( USB_InitDevice( ui_VendorID := 16#228f,
                          ui_ProductID := 16#03, 
                          ui_Variant := 16#FFFF, 
                          p_CallbackIsoIn := #CallbackIsoIn() , 
                          p_CallbackAsyOut := #CallbackAsyOut(), 
                          p_CallbackAsyIn := #CallbackAsyIn(), 
                          p_this := this,
                          p_PipeIsoIn := #p_PipeIsoIn,
                          p_PipeAsyOut := #p_PipeAsyOut,
                          p_PipeAsyIn := #p_PipeAsyIn, 
                          p_Index := #us_index,
                          p_Firmware := #us_FW ) ) then
                          
          State := DISPLAYSETTINGS_USB_INIT_ERROR;
        else
          State := DISPLAYSETTINGS_STATE_OK;
        end_if;
      end_if;       
    end_if;
    
    if _WhoAmI = DESTPLC_C_IPC then
      // Switch on backlight for CIPC
      SwitchBacklight.Write(input:=1);
    end_if;
    
    // set retentive value and reset actbrightness
    Brightness.Write(Brightness);
    actBrightness := -1;      // Invalid value for actBrightness to set brightness
    
    // activate display on system init
    DisplayInternal := 1;
  end_if;
  
  
END_FUNCTION  //FUNCTION VIRTUAL GLOBAL DisplaySettings::Init


FUNCTION DisplaySettings::DisplaySettings
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR  
    pSPCIInfo     	: ^LSL_SPCIINFO;
    SigmaTekDevInfo : ^PCICONFDATA;
    TmpVal          : UDINT;
  END_VAR	

   
  if (_whoami = DESTPLC_ETVEDGE | _whoami = DESTPLC_ETV) then 
    if OS_CILGET("PCICONFIG", #pSPCIInfo) = SYS_ERR_NONE then
      // device in ETV 8", 10", 12", 15", 17", 19"
      SigmaTekDevInfo := SPCIINFO_FINDDEVICE( 16#1405, 0 );
      if SigmaTekDevInfo then
        pPowerMng$^void := SPCIINFO_GETADDRESS( SigmaTekDevInfo );
        SwitchBacklight := (pPowerMng^ AND tPowerMng.DisplayBackLightEnable) <> 0;
      else
        // device in ETV 5"
        // Attention: Device 0xE28 has also been used for fan control (e.g. CIPC)!
        SigmaTekDevInfo := SPCIINFO_FINDDEVICE( 16#0E28, 0 ); 
        if (_whoami = DESTPLC_ETV) & SigmaTekDevInfo then
          pPWM$^void := SPCIINFO_GETADDRESS( SigmaTekDevInfo );
          SwitchBacklight := pPWM^.ControlStatusReg AND 1;
        else
          // device in edge-etv
          if _whoami = DESTPLC_ETVEDGE then
            DisplayInternal := SwitchBacklight := 1;
          else
            ClassState := DISPLAYSETTINGS_BACKGROUNDTASK_ERROR; //EtvBlError := 1;
          end_if;
        end_if;
      end_if;
    else
      ClassState := DISPLAYSETTINGS_BACKGROUNDTASK_ERROR;   //EtvBlError := 1;
    end_if;
  elsif (_WhoAmI = DESTPLC_C_IPC) then
    
#ifdef _LSL_TARGETARCH_x86    
    //init graphic controller
    Backlight_CIPC();
#else
//    not supported
#endif
  end_if;
  
   //Get OS Interfacepointer
  if OS_CILGET(INTERFACE_PWM, #pPWMColor ) = SYS_ERR_NONE then
    if pPWMColor then
      if OS_CILGET(INTERFACE_GPIO, #pGPIO ) = SYS_ERR_NONE then
        if pGPIO then
          // reset pwm outputs to write them with the first .write() call.
          if OS_GPIO_GET(pGPIO, SIGM_INOUTPUT_O_LOGOBEL_PWM1, #TmpVal) < 0 then
            LogoGreenPWM  := -1;
          end_if;
          if OS_GPIO_GET(pGPIO, SIGM_INOUTPUT_O_LOGOBEL_PWM2, #TmpVal) < 0 then
            LogoRedPWM    := -1;
          end_if;
          if OS_GPIO_GET(pGPIO, SIGM_INOUTPUT_O_LOGOBEL_PWM3, #TmpVal) < 0 then
            LogoBluePWM   := -1;
          end_if;
          
          dLastRed   := 0xFFFF;
          dLastGreen := 0xFFFF;
          dLastBlue  := 0xFFFF;
        else
          LogoRedPWM    := -1;
          LogoGreenPWM  := -1;
          LogoBluePWM   := -1;
          TRACE("(DisplaySettings::DisplaySettings) GPIO OS-Interface pointer not valid");
        end_if;
      else
        LogoRedPWM    := -1;
        LogoGreenPWM  := -1;
        LogoBluePWM   := -1;
        TRACE("(DisplaySettings::DisplaySettings) Failed to get GPIO OS-Interface ");
      end_if;
    else
      LogoRedPWM    := -1;
      LogoGreenPWM  := -1;
      LogoBluePWM   := -1;
      TRACE("(DisplaySettings::DisplaySettings) PWM OS-Interface pointer not valid");
    end_if;
  else
      LogoRedPWM    := -1;
      LogoGreenPWM  := -1;
      LogoBluePWM   := -1;
    TRACE("(DisplaySettings::DisplaySettings) Failed to get PWM OS-Interface ");
  end_if;
  
	ret_code := C_OK;

END_FUNCTION //FUNCTION DisplaySettings::DisplaySettings


FUNCTION AWL DisplaySettings::BackLight_CIPC
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
#ifdef _LSL_TARGETARCH_X86
	//look if vga controller is on or off and set server
	l.dx     16#3C4
	l.al     1
	outb

	l.dx	16#3C5
	inb
	test.al	16#20
	jz		LABEL_VGAOn
	l.d		sStatus,0
	jmp		LABEL_End

LABEL_VGAOn
	l.d		sStatus, 1
	
LABEL_End		
	l.w		ret_code, C_OK
#endif
END_FUNCTION //  DisplaySettings::BackLight_CIPC


FUNCTION VIRTUAL GLOBAL DisplaySettings::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  if b_CheckLater then
    b_CheckLater := FALSE;
    SwitchBacklight.Write(input:=DisplayInternal);
  end_if;
  

  if ((_whoami = DESTPLC_ETVEDGE) 
    | (_whoami = DESTPLC_ETV) 
    | (_RtOSversion > OS_STARTVERSION_SALAMANDER))
  then   
    if DisplayInternal <> SwitchBacklight then
      if DisplayInternal then
        DisplayInternal := 1;
        // Attention: Standby command might not work if this was "a Salamander" & has been booted back to LasalOS
        // because of USB-Vendor ID change (0x228f vs 0x5112) --> has to be fixed in OS!
        To_OSKernel.AddToServiceProvider(command:="exec Standby 0", immediatly:=0);
      else
        To_OSKernel.AddToServiceProvider(command:="exec Standby 2", immediatly:=0);
      end_if;

      SwitchBacklight := DisplayInternal;    
    end_if;
  end_if;
  
  // check for brightnesschange
  if newBrightness <> actBrightness then
    ChangeBrightness(newBrightness$USINT);
  end_if;

  
	state := READY;

END_FUNCTION //FUNCTION VIRTUAL GLOBAL DisplaySettings::Background



FUNCTION VIRTUAL GLOBAL DisplaySettings::Brightness::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // check for change and save for backgroundaction if necessary
  if input <> actBrightness then
    
    if ((input >= DISPLAYSETTINGS_MIN_BRIGHTNESS_INPUT) & (input <= DISPLAYSETTINGS_MAX_BRIGHTNESS_INPUT))  then
    // only valid values allowed     
      newBrightness := input;
      actBrightness := Brightness;
      Brightness    := input;
      
      SwitchBacklight.Write(1); // graphix will switch on backlight in any way, so we set it first to have a correct server value
    end_if;
  end_if;
  
  result := input;

END_FUNCTION // FUNCTION VIRTUAL GLOBAL DisplaySettings::Brightness::Write


FUNCTION GLOBAL DisplaySettings::SetBrightness
	VAR_INPUT
		Value 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret0 	: DINT;
	END_VAR
  
  // redirect over to write interface
  ret0 := Brightness.Write(Value);
  
END_FUNCTION //FUNCTION GLOBAL DisplaySettings::SetBrightness


#pragma warning (disable:073)
FUNCTION DisplaySettings::CallbackIsoIn
	VAR_INPUT
		p_Pipe 	: PPIPEDATA;
		sd_ErrorCode 	  : DINT;
		p_Data 	        : pVoid;
		sd_DataLength 	: DINT;
	END_VAR

  sd_IsoInReady     := 1;
  
END_FUNCTION


FUNCTION DisplaySettings::CallbackAsyOut
	VAR_INPUT
		p_Pipe 	        : PPIPEDATA;
		sd_ErrorCode 	  : DINT;
		p_Data 	        : pVoid;
		sd_DataLength 	: DINT;
	END_VAR
  
  sd_AsyOutReady    := 1;

END_FUNCTION


FUNCTION DisplaySettings::CallbackAsyIn
	VAR_INPUT
		p_Pipe 	      : PPIPEDATA;
		sd_ErrorCode 	: DINT;
		p_Data 	      : pVoid;
		sd_DataLength : DINT;
	END_VAR
  
  sd_AsyInReady := 1;

END_FUNCTION
#pragma warning (default:073)


FUNCTION AWL DisplaySettings::SCREENLIGHT 
	VAR_INPUT
		onoff0 	: UDINT;
	END_VAR
#ifdef _LSL_TARGETARCH_X86
	l.dx     16#3C4
	l.al     1
	outb
	l.dx     16#3C5
	inb
	s.al     ah
	o.d      onoff0, 0
	jz       LABEL_SETOFF
	and.ah   16#FF-16#20
	jmp      LABEL_SETOK

LABEL_SETOFF
	or.ah    16#20

LABEL_SETOK
	l.dx     16#3C4
	l.al     1
	outb
	l.dx     16#3C5
	s.ah     al
	outb
#endif
END_FUNCTION // FUNCTION AWL DisplaySettings::SCREENLIGHT 


FUNCTION VIRTUAL GLOBAL DisplaySettings::SwitchBacklight::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
    TX_Data 	: ARRAY[0..2] OF USINT;
    retval		: INT;
    ud_Data : udint;
    d_ret : dint;
  END_VAR
  
  //Only switch on if one second is over since last switch on. Only wait when user want to switch display on
  if input & (SwitchBacklight = 0) & ((ops.tAbsolute - ud_LastBacklightSwitchOff) < DISPLAYSETTINGS_BACKLIGHT_SWITCHOFF_TIME) then
    b_CheckLater := TRUE;
    DisplayInternal := 1;
    return;
  end_if;
  
  if _WhoAmI = DESTPLC_C_IPC then
		
		TX_Data [0] := 16#FD;
		TX_Data [1] := 16#03;
		 
    if input <> 0 then
      // turn on backlight
      SwitchBacklight := 1;
      TX_Data [2] 	:= 1;
    else
      // turn off backlight
      SwitchBacklight := 0;
      TX_Data [2] 	:= 0;
    end_if;
    
        
    //Commando over CAN
    //*****************************************************************************
    retval := To_Can.CanTxObj    (CanNr  := 2,
                                  ObjNr  := 16#80,
                                  length := 3,
                                  data   := #TX_Data);  
          
    //CanError := retval;
    if (retval = 0) then
      ClassState := 0;
    else
      ClassState := DISPLAYSETTINGS_CAN_OBJECT_ERROR;  
    end_if;
  //*****************************************************************************
  
   //Send commando over PsoC 
    if State = DISPLAYSETTINGS_STATE_OK then   // USB is correctly initialized 
      if (ops.tAbsolute - ud_UsbReqLastCall >= USB_REQ_TIMER_UP) then  // Timer up for USB Request
        sd_AsyOutReady  := 1;
      end_if;

      if (sd_AsyOutReady = 1) then
      // sending over usb allowed
        sd_AsyOutReady    := 0;
        //Commando FPEN Ignore: Bit 1:0 -> Display on ; Bit 1: 1 -> Display off
        ud_data := (to_udint(SwitchBacklight XOR 1)) SHL 1;
        d_ret := SendAsyncData( us_index := us_index, us_command := 1, pus_data := ( #ud_Data )$^usint, 2 );
        ud_UsbReqLastCall := ops.tAbsolute;               // For USB timer up
      end_if;
              
      if d_ret = 0 then
        //Psoc Commando was successful
        ClassState := 0;
      else
        ClassState := DISPLAYSETTINGS_PSOC_ERROR;
      end_if;
    end_if;
    
  //*****************************************************************************

#ifdef _LSL_TARGETARCH_x86    
    //set graphic controller
	  SCREENLIGHT( to_udint( SwitchBacklight));
#else
    //not supported
#endif

    
  elsif _whoami = DESTPLC_ETV then

    if pPowerMng then// device in ETV 8", 10", 12", 15", 17", 19"
      if input then
        pPowerMng^ := pPowerMng^ OR tPowerMng.DisplayBackLightEnable;
      else
        pPowerMng^ := pPowerMng^ AND (NOT tPowerMng.DisplayBackLightEnable);
      end_if;
      
//      SwitchBacklight := (pPowerMng^ AND tPowerMng.DisplayBackLightEnable) <> 0;
      DisplayInternal := (pPowerMng^ AND tPowerMng.DisplayBackLightEnable) <> 0;
    elsif pPWM then// device in ETV 5"
      if input then
        pPWM^.ControlStatusReg := pPWM^.ControlStatusReg OR 1;
      else
        pPWM^.ControlStatusReg := pPWM^.ControlStatusReg AND 2#11111110;
      end_if;

//      SwitchBacklight := pPWM^.ControlStatusReg AND 1;
      DisplayInternal := pPWM^.ControlStatusReg AND 1;
    end_if;
  elsif ((_whoami = DESTPLC_ETVEDGE)
       | (_RtOSversion > OS_STARTVERSION_SALAMANDER))
  then// device in edge-etv or os >= salamander
    if input <> 0 then
      input := 1;
    end_if;
    
    DisplayInternal := input;
  else
    SwitchBacklight := 0;
    Trace( "Error in Class DisplaySettings::SwitchBacklight::Write This Class is just for a CIPC and ETV" );
  end_if; 
  
  result := SwitchBacklight;

  //set Timemark for OnDelay
  if SwitchBacklight = 0 then
    ud_LastBacklightSwitchOff := ops.tAbsolute;      
  end_if;

END_FUNCTION //VIRTUAL GLOBAL DisplaySettings::switchBacklight::Write


FUNCTION VIRTUAL GLOBAL DisplaySettings::SwitchBacklight::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  if (_WHOAMI = DESTPLC_ETVEDGE | _WHOAMI = DESTPLC_ETV | _WHOAMI = DESTPLC_IMX6) then  
    if pPowerMng then
      SwitchBacklight := (pPowerMng^ AND tPowerMng.DisplayBackLightEnable) <> 0;
    elsif pPWM then
      SwitchBacklight := pPWM^.ControlStatusReg AND 1;
    end_if;

    output := SwitchBacklight;
  else
    output := 0;
  end_if;

END_FUNCTION //FUNCTION VIRTUAL GLOBAL DisplaySettings::switchBacklight::Read


FUNCTION DisplaySettings::ChangeBrightness
	VAR_INPUT
		Value 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret0 	: DINT;
	END_VAR
  VAR
    ud_Data : udint;
    d_ret   : dint;
    sd_scaleVal   : DINT;
  	sd_retVal     : DINT;
  END_VAR

  // initialize returnvalue
  ret0 := 0;

  // check for platform
  if (_RtOSversion > OS_STARTVERSION_SALAMANDER) then        
  // Set brightness for OS´s starting with salamander

    sd_scaleVal     := (DISPLAYSETTINGS_GRAPHIX_MAX_BRIGHTNESS * Value) / (DISPLAYSETTINGS_MAX_BRIGHTNESS_INPUT - DISPLAYSETTINGS_MIN_BRIGHTNESS_INPUT);
    sd_RetVal$UDINT := To_Graphix.LCD_Brightness(cmd:= LCD_SETVALUE, setvalue:= sd_scaleVal$UDINT);    
   
    if (sd_RetVal = DISPLAYSETTINGS_BRIGHTNESS_ERROR) then
    // change not possible
      ClassState := DISPLAYSETTINGS_GRAPHIX_ERROR;   
    else
    // change successfull
      actBrightness := Value;
      if ClassState = DISPLAYSETTINGS_GRAPHIX_ERROR then
      // reset a possible parameter error
        ClassState := 0;
      end_if;
      
    end_if;
  else  
  // all other platforms
  
    if State = DISPLAYSETTINGS_STATE_OK then   // USB is correctly initialized 
      if (ops.tAbsolute - ud_UsbReqLastCall >= USB_REQ_TIMER_UP) then  // Timer up for USB Request
        sd_AsyOutReady  := 1;
      end_if;

      sd_scaleVal := (DISPLAYSETTINGS_USB_MAX_BRIGHTNESS * Value) / (DISPLAYSETTINGS_MAX_BRIGHTNESS_INPUT - DISPLAYSETTINGS_MIN_BRIGHTNESS_INPUT);
      if (sd_AsyOutReady = 1) then
      // sending over usb allowed
        sd_AsyOutReady    := 0;
        ud_Data           := 4 + to_udint(sd_scaleVal) * 16#100; // command for set pwm/ao
        d_ret             := SendAsyncData( us_index := us_index, us_command := 2, pus_data := ( #ud_Data )$^usint, 2 );
        ud_UsbReqLastCall := ops.tAbsolute;               // For USB timer up
        if (d_ret = 0) then
        // change successfull
          actBrightness := Value;
        end_if; 
      end_if;
    end_if;
  end_if; 

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DisplaySettings::LogoRedPWM::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // check for change and save for backgroundaction if necessary
  if pPWMColor & (LogoRedPWM <> -1) & (input <> dLastRed)  then
    
    if ((input >= DISPLAYSETTINGS_MIN_PWM_INPUT) & (input <= DISPLAYSETTINGS_MAX_PWM_INPUT))  then
    // only valid values allowed     
      LogoRedPWM := dLastRed := input;
      
      OS_PWM_CONFIG(  pPWMColor,(SIGM_INOUTPUT_O_LOGOBEL_PWM2)
                    , (LogoRedPWM)$DINT
                    , DISPLAYSETTINGS_PWM_PERIODE_TIME
                    );
            
    end_if;
  end_if;
  
  result := LogoRedPWM;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DisplaySettings::LogoGreenPWM::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // check for change and save for backgroundaction if necessary
  if pPWMColor & (LogoGreenPWM <> -1) & (input <> dLastGreen)  then
    
    if ((input >= DISPLAYSETTINGS_MIN_PWM_INPUT) & (input <= DISPLAYSETTINGS_MAX_PWM_INPUT))  then
    // only valid values allowed     
      LogoGreenPWM := dLastGreen := input;
      
      OS_PWM_CONFIG(  pPWMColor,SIGM_INOUTPUT_O_LOGOBEL_PWM1
                    , (LogoGreenPWM)$DINT
                    , DISPLAYSETTINGS_PWM_PERIODE_TIME
                    ); 
            
    end_if;
  end_if;
  
  result := LogoGreenPWM;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DisplaySettings::LogoBluePWM::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // check for change and save for backgroundaction if necessary
  if pPWMColor & (LogoBluePWM <> -1) & (input <> dLastBlue)  then
    
    if ((input >= DISPLAYSETTINGS_MIN_PWM_INPUT) & (input <= DISPLAYSETTINGS_MAX_PWM_INPUT))  then
    // only valid values allowed     
      LogoBluePWM := dLastBlue := input;
      
      OS_PWM_CONFIG(  pPWMColor,SIGM_INOUTPUT_O_LOGOBEL_PWM3
                    , (LogoBluePWM)$DINT
                    , DISPLAYSETTINGS_PWM_PERIODE_TIME
                    );
            
    end_if;
  end_if;
  
  result := LogoBluePWM;

END_FUNCTION
