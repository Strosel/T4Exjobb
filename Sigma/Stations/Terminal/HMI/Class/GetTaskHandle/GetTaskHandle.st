//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "GetTaskHandle"
	Revision           = "0.2"
	GUID               = "{9D1DBB2A-F63B-4122-B2FA-0DF31A091491}"
	RealtimeTask       = "true"
	DefRealtime        = "1000 ms"
	CyclicTask         = "true"
	DefCyclictime      = "1000 ms"
	BackgroundTask     = "true"
	DefBackground      = "1000 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(404,120)"
	Comment            = "Wird verwendet , um herauszufinden , in&#13;&#10;welchem Task man sich gerade befindet.&#13;&#10;&#13;&#10;Used to find out in which task the code is actually running.">
	<Channels>
		<Server Name="ClassSvr" GUID="{A879BAC0-B180-491D-802B-21A2B90E99D7}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Lsl_st_ifssr.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HötAnt"/>
		<Dokumentation Revision="1.0" Date="2015-01-08" Author="ObeChr" Company="Sigmatek" Description="Prepared class for library"/>
		<Dokumentation Revision="0.1" Date="2014-08-04" Author="HötAnt" Company="Sigmatek" Description="Created class"/>
	</RevDoku>
</Class>
*)
GetTaskHandle : CLASS
	TYPE
	  _ActTask :  //! <Type Public="true" Comment="mögliche Standard Tasks." Name="_ActTask"/>
	  (
	    AT_Real,
	    AT_Cyclic,
	    AT_Background,
	    AT_NoStdTask
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		TaskHandleRT 	: UDINT;			//! <Variable Comment="Taskhandle , welches nur einmal im &#13;&#10;ersten Durchlauf der Methode ausgelesen wird.&#13;&#10;&#13;&#10;Taskhandle, which is read out once in the first call of the method." Name="TaskHandleRT"/>
		TaskHandleCY 	: UDINT;			//! <Variable Comment="Taskhandle , welches nur einmal im &#13;&#10;ersten Durchlauf der Methode ausgelesen wird.&#13;&#10;&#13;&#10;Taskhandle, which is read out once in the first call of the method." Name="TaskHandleCY"/>
		TaskHandleBG 	: UDINT;			//! <Variable Comment="Taskhandle , welches nur einmal im &#13;&#10;ersten Durchlauf der Methode ausgelesen wird.&#13;&#10;&#13;&#10;Taskhandle, which is read out once in the first call of the method." Name="TaskHandleBG"/>
		MerkerRT 	: BOOL;			//! <Variable Comment="Merker , damit das Taskhandle nur&#13;&#10;einmal ausgelesen wird.&#13;&#10;&#13;&#10;Flag, so the taskhandle is only read out once." Name="MerkerRT"/>
		MerkerCY 	: BOOL;			//! <Variable Comment="Merker , damit das Taskhandle nur&#13;&#10;einmal ausgelesen wird.&#13;&#10;&#13;&#10;Flag, so the taskhandle is only read out once." Name="MerkerCY"/>
		MerkerBG 	: BOOL;			//! <Variable Comment="Merker , damit das Taskhandle nur&#13;&#10;einmal ausgelesen wird.&#13;&#10;&#13;&#10;Flag, so the taskhandle is only read out once." Name="MerkerBG"/>
  //Functions:
				//! <Function Comment="Only used to get Taskhandle." Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Only used to get Taskhandle." Name="RtWork"/>
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Only used to get Taskhandle." Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="liefert den Task zurück , in welchem man&#13;&#10;sich aktuell befindet.&#13;&#10;&#13;&#10;Returns currently used task." Name="GetActualTask"/>
	FUNCTION GLOBAL GetActualTask
		VAR_OUTPUT
			retcode 	: _ActTask;			//! <Variable Comment="aktueller Task." Name="GetActualTask.retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB GetTaskHandle::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_GETTASKHANDLE
0$UINT, 2$UINT, (SIZEOF(::GetTaskHandle))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2602835227), "GetTaskHandle", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::GetTaskHandle.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
END_FUNCTION


#define USER_CNT_GetTaskHandle 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_GetTaskHandle] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION GetTaskHandle::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_GetTaskHandle, pCmd := #vmt.CmdTable);
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL GetTaskHandle::GetActualTask
	VAR_OUTPUT
		retcode 	: _ActTask;
	END_VAR
  VAR
    aktTaskHandle : udint;
  END_VAR

  // das aktuelle Task Handle auslesen 
  aktTaskHandle := OS_SSR_CURRENTTASKHANDLE();

  // mit dem gespeichertem Taskhandle der RT-Methode vergleichen
  if TaskHandleRT = aktTaskHandle then
    // Wir befinden uns im RealTime Task.
    retcode := AT_Real;
    // Aufgabe erfüllt , Abbruch.
    return;
  end_if;

  // mit dem gespeichertem Taskhandle der CY-Methode vergleichen
  if TaskHandleCY = aktTaskHandle then
    // Wir befinden uns im Cyclic Task.
    retcode := AT_Cyclic;
    // Aufgabe erfüllt , Abbruch.
    return;
  end_if;

  // mit dem gespeichertem Taskhandle der BG-Methode vergleichen
  if TaskHandleBG = aktTaskHandle then
    // Wir befinden uns im Background Task.
    retcode := AT_Background;
    // Aufgabe erfüllt , Abbruch.
    return;
  end_if;

  // Wird befinden uns in keinem Standart Task. ( vom User oder Os angelegter Task )
  retcode := AT_NoStdTask;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL GetTaskHandle::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // Einmaliges auslesen des Taskhandles vom RT-Task.
	if merkerRT = FALSE then
    TaskHandleRT := OS_SSR_CURRENTTASKHANDLE();
    // Merker setzen , damit es nur einmal gemacht wird.
    merkerRT := TRUE;
  end_if;
  state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL GetTaskHandle::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // Einmaliges auslesen des Taskhandles vom CY-Task.
	if merkerCY = FALSE then
    TaskHandleCY := OS_SSR_CURRENTTASKHANDLE();
    // Merker setzen , damit es nur einmal gemacht wird.
    merkerCY := TRUE;
  end_if;
	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL GetTaskHandle::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // Einmaliges auslesen des Taskhandles vom BG-Task.
	if merkerBG = FALSE then
    TaskHandleBG := OS_SSR_CURRENTTASKHANDLE();
    // Merker setzen , damit es nur einmal gemacht wird.
    merkerBG := TRUE;
  end_if;
	state := READY;

END_FUNCTION